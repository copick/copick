{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"copick","text":"<p>copick is a cross-platform, storage-agnostic and server-less dataset API for cryoET datasets. Access to the data is provided through an object-oriented API that abstracts away the underlying storage using the fsspec-family of libraries.</p>"},{"location":"#why-copick","title":"Why copick?","text":"<ul> <li> <p> storage-agnostic</p> <p>Access data on local or shared storage, via SSH or on the cloud with the same API. No need for your own boilerplate!</p> <p> Get started now </p> </li> <li> <p> cloud-ready</p> <p>Access image data quickly and in parallel thanks to multiscale OME-Zarr. Easily load data from the CZ cryoET Data Portal!</p> <p> Learn more</p> </li> <li> <p> server-less</p> <p>No need for a dedicated server or database to access your data, just point copick to your data and go!</p> <p> Deploy copick using album</p> </li> <li> <p> cross-platform</p> <p>copick works on any platform that supports Python. Compute on Linux, visualize on Windows or Mac!</p> <p> Learn about copick and HPC</p> </li> <li> <p> ecosystem</p> <p>Using the copick API allows visualizing and curating data in ChimeraX and Napari right away!</p> <p> Explore tools</p> </li> <li> <p> open source</p> <p>Copick is released under the open source MIT license.</p> <p> License</p> </li> </ul>"},{"location":"#data","title":"Data","text":"<p>Currently, copick supports the following types of data frequently encountered in cryoET datasets:</p> <ul> <li>tomograms</li> <li>feature maps</li> <li>dense segmentations</li> <li>mesh annotations</li> <li>point annotations</li> </ul>"},{"location":"#storage-backends","title":"Storage backends","text":"<p>Copick should support any storage backend that is supported by fsspec.</p> <p>The following backends are included in tests and should work out of the box:</p> <ul> <li>local filesystem</li> <li>s3</li> <li>smb</li> <li>access via ssh</li> </ul>"},{"location":"cli/","title":"CLI Reference","text":"<p>The Copick CLI provides a comprehensive set of commands for managing Copick projects, configurations, and data.</p> <p>Environment Variable Support</p> <p>The configuration file path can be set using the <code>COPICK_CONFIG</code> environment variable instead of passing <code>--config</code> every time:</p> <pre><code>export COPICK_CONFIG=/path/to/config.json\ncopick browse  # Uses config from environment variable\n</code></pre>"},{"location":"cli/#commands","title":"Commands","text":""},{"location":"cli/#copick-browse","title":"<code>copick browse</code>","text":"<p>Browse Copick projects interactively using a terminal user interface.</p> <p>Usage: <pre><code>copick browse [OPTIONS]\n</code></pre></p> <p>Options:</p> Option Type Description Default <code>-c, --config PATH</code> Path Path to the configuration file Uses <code>COPICK_CONFIG</code> env var <code>-ds, --dataset-ids ID</code> Integer Dataset IDs to include (multiple inputs possible) None <code>--debug / --no-debug</code> Boolean Enable debug logging <code>no-debug</code> <p>Examples:</p> <pre><code># Browse a local project\ncopick browse --config my_project.json\n\n# Browse CryoET Data Portal datasets\ncopick browse --dataset-ids 10000 --dataset-ids 10001\n\n# Using environment variable\nexport COPICK_CONFIG=my_project.json\ncopick browse\n</code></pre>"},{"location":"cli/#copick-config","title":"<code>copick config</code>","text":"<p>Manage Copick configuration files.</p> <p>Subcommands:</p> <ul> <li><code>copick config dataportal</code> - Set up a configuration file from CZDP dataset IDs</li> <li><code>copick config filesystem</code> - Set up a configuration file for a local project</li> </ul>"},{"location":"cli/#copick-config-dataportal","title":"<code>copick config dataportal</code>","text":"<p>Generate a configuration file from CryoET Data Portal datasets.</p> <p>Usage: <pre><code>copick config dataportal [OPTIONS]\n</code></pre></p> <p>Options:</p> Option Type Description Default <code>-ds, --dataset-id INTEGER</code> Integer Dataset IDs from the CryoET Data Portal (required, multiple allowed) None <code>--overlay TEXT</code> Path Path to the local overlay directory (required) None <code>--output TEXT</code> Path Path to save the generated configuration file <code>config.json</code> <code>--debug / --no-debug</code> Boolean Enable debug logging <code>no-debug</code> <p>Examples:</p> <pre><code># Single dataset\ncopick config dataportal --dataset-id 10000 --overlay ./overlay --output my_config.json\n\n# Multiple datasets\ncopick config dataportal -ds 10000 -ds 10001 --overlay ./overlay --output multi_config.json\n</code></pre>"},{"location":"cli/#copick-config-filesystem","title":"<code>copick config filesystem</code>","text":"<p>Generate a configuration file for a local project directory.</p> <p>Usage: <pre><code>copick config filesystem [OPTIONS]\n</code></pre></p> <p>Options:</p> Option Type Description Default <code>--overlay-root TEXT</code> Path Overlay root path (required) None <code>--objects TEXT</code> String List of desired objects in the format: <code>name,is_particle,[radius],[pdb_id]</code> (required, multiple allowed) None <code>--config TEXT</code> Path Path to the output JSON configuration file <code>config.json</code> <code>--proj-name TEXT</code> String Name of the project configuration <code>project</code> <code>--proj-description TEXT</code> String Description of the project configuration <code>Config Project for SessionXXa</code> <code>--debug / --no-debug</code> Boolean Enable debug logging <code>no-debug</code> <p>Object Format: Objects are specified using the format: <code>name,is_particle,[radius],[pdb_id]</code></p> <ul> <li><code>name</code>: The name of the object (required, cannot contain underscores)</li> <li><code>is_particle</code>: <code>True</code> or <code>False</code> indicating if this is a particle (required)</li> <li><code>radius</code>: Radius in pixels for particles (optional, only for particles)</li> <li><code>pdb_id</code>: PDB ID for the particle structure (optional, only for particles)</li> </ul> <p>Examples:</p> <pre><code># Basic filesystem config with membrane and ribosome\ncopick config filesystem \\\n    --overlay-root /path/to/project \\\n    --objects membrane,False \\\n    --objects ribosome,True,120,4V9D \\\n    --config my_project.json\n\n# Complex project with multiple particles\ncopick config filesystem \\\n    --overlay-root /mnt/data/experiment \\\n    --objects membrane,False \\\n    --objects ribosome,True,120,4V9D \\\n    --objects proteasome,True,80,6MSB \\\n    --objects apoferritin,True,60,4V1W \\\n    --proj-name \"Cellular_Tomography\" \\\n    --proj-description \"Cellular structures from cryo-ET experiment\" \\\n    --config cellular_config.json\n\n# Minimal config\ncopick config filesystem \\\n    --overlay-root ./data \\\n    --objects virus,True,150\n</code></pre>"},{"location":"cli/#copick-add","title":"<code>copick add</code>","text":"<p>Add entities to Copick projects.</p> <p>Subcommands:</p> <ul> <li><code>copick add tomogram</code> - Add a tomogram to the project</li> <li><code>copick add segmentation</code> - Add a segmentation to the project</li> <li><code>copick add object</code> - Add a pickable object to the project configuration</li> <li><code>copick add object-volume</code> - Add volume data to an existing pickable object</li> </ul>"},{"location":"cli/#copick-add-tomogram","title":"<code>copick add tomogram</code>","text":"<p>Add one or more tomograms to the project from MRC or Zarr files.</p> <p>Usage: <pre><code>copick add tomogram [OPTIONS] PATH\n</code></pre></p> <p>Arguments:</p> Argument Type Description <code>PATH</code> Path Path to tomogram file(s) (MRC or Zarr format) or glob pattern (e.g., <code>*.mrc</code>) <p>Options:</p> Option Type Description Default <code>-c, --config PATH</code> Path Path to the configuration file Uses <code>COPICK_CONFIG</code> env var <code>--run TEXT</code> String The name of the run. If not specified, will use the name of the file (stripping extension), ignored if PATH is glob pattern. <code>\"\"</code> <code>--run-regex TEXT</code> String Regular expression to extract the run name from the filename. The regex should capture the run name in the first group. <code>(.*)</code> <code>--tomo-type TEXT</code> String The name of the tomogram (e.g. wbp) <code>wbp</code> <code>--file-type TEXT</code> String The file type ('mrc' or 'zarr') Auto-detected <code>--voxel_size FLOAT</code> Float Voxel size in Angstrom (overrides header value) None <code>--create-pyramid / --no-create-pyramid</code> Boolean Compute the multiscale pyramid <code>create-pyramid</code> <code>--pyramid-levels INTEGER</code> Integer Number of pyramid levels (each level is 2x downscaling) <code>3</code> <code>--chunk-size TEXT</code> String Chunk size for the output Zarr file <code>256,256,256</code> <code>--overwrite / --no-overwrite</code> Boolean Overwrite the object if it exists <code>no-overwrite</code> <code>--create / --no-create</code> Boolean Create the object if it does not exist <code>create</code> <code>--debug / --no-debug</code> Boolean Enable debug logging <code>no-debug</code> <p>Batch Processing with Glob Patterns</p> <p>You can add multiple tomograms at once using glob patterns. When using glob patterns, run names are automatically derived from filenames, and a progress bar shows the processing status.</p> <p>Examples:</p> <pre><code># Add single MRC tomogram with default settings\ncopick add tomogram --config config.json --run TS_001 data/tomogram.mrc\n\n# Add multiple tomograms using glob pattern (auto-detects run names from filenames)\ncopick add tomogram --config config.json data/tomograms/*.mrc\n\n# Add all MRC files in current directory\ncopick add tomogram --config config.json *.mrc\n\n# Add tomograms with specific naming pattern\ncopick add tomogram --config config.json \"data/TS_*_recon.mrc\"\n\n# Add Zarr tomogram with custom voxel size and pyramid levels\ncopick add tomogram --config config.json --voxel_size 10.0 --pyramid-levels 4 data/tomogram.zarr\n\n# Add multiple Zarr files without pyramid generation (faster)\ncopick add tomogram --config config.json --no-create-pyramid data/*.zarr\n\n# Add tomogram with custom chunk size\ncopick add tomogram --config config.json --chunk-size \"128,128,128\" data/tomogram.mrc\n\n# Add multiple tomograms with custom settings\ncopick add tomogram --config config.json --tomo-type \"denoised\" --voxel_size 8.0 data/processed_*.mrc\n\n# Extract run names using regex pattern\n# For file \"Position_60_7_Vol_CTF.mrc\", this will create run \"Position_60_7\"\ncopick add tomogram --config config.json --run-regex \"^(Position_.*)_Vol_CTF\" data/Position_60_7_Vol_CTF.mrc\n\n# Use regex with glob pattern for multiple files with structured naming\ncopick add tomogram --config config.json --run-regex \"^(Position_.*)_Vol_CTF\" data/Position_*_Vol_CTF.mrc\n</code></pre>"},{"location":"cli/#copick-add-segmentation","title":"<code>copick add segmentation</code>","text":"<p>Add one or more segmentations to the project from MRC or Zarr files.</p> <p>Usage: <pre><code>copick add segmentation [OPTIONS] PATH\n</code></pre></p> <p>Arguments:</p> Argument Type Description <code>PATH</code> Path Path to segmentation file(s) (MRC or Zarr format) or glob pattern (e.g., <code>*.mrc</code>) <p>Options:</p> Option Type Description Default <code>-c, --config PATH</code> Path Path to the configuration file Uses <code>COPICK_CONFIG</code> env var <code>--run TEXT</code> String The name of the run. If not specified, will use the name of the file (stripping extension), ignored if PATH is glob pattern. <code>\"\"</code> <code>--run-regex TEXT</code> String Regular expression to extract the run name from the filename. The regex should capture the run name in the first group. <code>(.*)</code> <code>--voxel-size FLOAT</code> Float Voxel size in Angstrom (overrides header value) None <code>--name TEXT</code> String Name of the segmentation None <code>--user-id TEXT</code> String User ID of the segmentation <code>copick</code> <code>--session-id TEXT</code> String Session ID of the segmentation <code>1</code> <code>--overwrite / --no-overwrite</code> Boolean Overwrite the object if it exists <code>no-overwrite</code> <code>--create / --no-create</code> Boolean Create the object if it does not exist <code>create</code> <code>--debug / --no-debug</code> Boolean Enable debug logging <code>no-debug</code> <p>Examples:</p> <pre><code># Add single segmentation with default settings\ncopick add segmentation --config config.json --run TS_001 --name membrane data/segmentation.mrc\n\n# Add multiple segmentations using glob pattern\ncopick add segmentation --config config.json --name organelles data/segmentations/*.mrc\n\n# Add segmentation with custom user and session\ncopick add segmentation --config config.json --run TS_001 --name mitochondria --user-id alice --session-id 2 data/mito_seg.mrc\n\n# Add segmentation with custom voxel size\ncopick add segmentation --config config.json --run TS_001 --name membrane --voxel-size 10.0 data/membrane.zarr\n\n# Extract run names using regex pattern for segmentations\n# For file \"Position_60_7_Vol_CTF.mrc\", this will create run \"Position_60_7\"\ncopick add segmentation --config config.json --run-regex \"^(Position_.*)_Vol_CTF\" --name membrane data/Position_60_7_Vol_CTF.mrc\n</code></pre>"},{"location":"cli/#copick-add-object","title":"<code>copick add object</code>","text":"<p>Add a pickable object to the project configuration.</p> <p>Usage: <pre><code>copick add object [OPTIONS]\n</code></pre></p> <p>Options:</p> Option Type Description Default <code>-c, --config PATH</code> Path Path to the configuration file Uses <code>COPICK_CONFIG</code> env var <code>--name TEXT</code> String Name of the object to add (required) None <code>--object-type CHOICE</code> String Type of object: 'particle' or 'segmentation' <code>particle</code> <code>--label INTEGER</code> Integer Numeric label/id for the object. If not provided, will use the next available label None <code>--color TEXT</code> String RGBA color for the object as comma-separated values (e.g. '255,0,0,255' for red) None <code>--emdb-id TEXT</code> String EMDB ID for the object None <code>--pdb-id TEXT</code> String PDB ID for the object None <code>--identifier TEXT</code> String Identifier for the object (e.g. Gene Ontology ID or UniProtKB accession) None <code>--map-threshold FLOAT</code> Float Threshold to apply to the map when rendering the isosurface None <code>--radius FLOAT</code> Float Radius of the particle, when displaying as a sphere <code>50</code> <code>--metadata TEXT</code> String JSON string containing custom metadata for the object (e.g. '{\"source\": \"experimental_data\", \"confidence\": 0.95}') None <code>--volume PATH</code> Path Path to volume file to associate with the object None <code>--volume-format CHOICE</code> String Format of the volume file ('mrc' or 'zarr') Auto-detected <code>--voxel-size FLOAT</code> Float Voxel size for the volume data. Required if volume is provided None <code>--exist-ok / --no-exist-ok</code> Boolean Whether existing objects with the same name should be overwritten <code>no-exist-ok</code> <code>--debug / --no-debug</code> Boolean Enable debug logging <code>no-debug</code> <p>Examples:</p> <pre><code># Add a basic particle object\ncopick add object --config config.json --name ribosome --object-type particle --radius 120\n\n# Add a particle with PDB reference and custom color\ncopick add object --config config.json --name ribosome --object-type particle --radius 120 --pdb-id 4V9D --color \"255,0,0,255\"\n\n# Add a segmentation object with custom label\ncopick add object --config config.json --name membrane --object-type segmentation --label 1 --color \"0,255,0,128\"\n\n# Add a particle with associated volume data\ncopick add object --config config.json --name proteasome --object-type particle --radius 80 --volume data/proteasome.mrc --voxel-size 10.0\n\n# Add object with EMDB reference and identifier\ncopick add object --config config.json --name apoferritin --object-type particle --emdb-id EMD-1234 --identifier \"GO:0006826\" --radius 60\n\n# Add object with custom metadata\ncopick add object --config config.json --name ribosome --object-type particle --radius 120 --metadata '{\"source\": \"experimental_data\", \"confidence\": 0.95, \"notes\": \"High-resolution structure\"}'\n</code></pre>"},{"location":"cli/#copick-add-object-volume","title":"<code>copick add object-volume</code>","text":"<p>Add volume data to an existing pickable object.</p> <p>Usage: <pre><code>copick add object-volume [OPTIONS]\n</code></pre></p> <p>Options:</p> Option Type Description Default <code>-c, --config PATH</code> Path Path to the configuration file Uses <code>COPICK_CONFIG</code> env var <code>--object-name TEXT</code> String Name of the existing object (required) None <code>--volume-path PATH</code> Path Path to the volume file (required) None <code>--volume-format CHOICE</code> String Format of the volume file ('mrc' or 'zarr') Auto-detected <code>--voxel-size FLOAT</code> Float Voxel size of the volume data in Angstrom None <code>--debug / --no-debug</code> Boolean Enable debug logging <code>no-debug</code> <p>Examples:</p> <pre><code># Add volume data to an existing object\ncopick add object-volume --config config.json --object-name ribosome --volume-path data/ribosome_volume.mrc\n\n# Add volume with custom voxel size\ncopick add object-volume --config config.json --object-name proteasome --volume-path data/proteasome.zarr --voxel-size 8.0\n\n# Add volume with explicit format specification\ncopick add object-volume --config config.json --object-name membrane --volume-path data/membrane_vol --volume-format zarr\n</code></pre>"},{"location":"cli/#copick-new","title":"<code>copick new</code>","text":"<p>Create new Copick entities.</p> <p>Subcommands:</p> <ul> <li><code>copick new picks</code> - Create empty picks for a given particle name</li> <li><code>copick new run</code> - Create an empty run with the given name</li> <li><code>copick new voxelspacing</code> - Create an empty voxelspacing with the given name</li> </ul>"},{"location":"cli/#copick-new-picks","title":"<code>copick new picks</code>","text":"<p>Create empty picks for a given particle name.</p> <p>Usage: <pre><code>copick new picks [OPTIONS]\n</code></pre></p> <p>Options:</p> Option Type Description Default <code>-c, --config PATH</code> Path Path to the configuration file Uses <code>COPICK_CONFIG</code> env var <code>--particle-name TEXT</code> String Name of the particle to create picks for (required) None <code>--out-user TEXT</code> String User ID to write picks to <code>copick</code> <code>--out-session TEXT</code> String Session ID to write picks to <code>0</code> <code>--overwrite BOOLEAN</code> Boolean Overwrite existing picks <code>False</code> <code>--debug / --no-debug</code> Boolean Enable debug logging <code>no-debug</code> <p>Examples:</p> <pre><code># Create empty picks for ribosomes\ncopick new picks --config config.json --particle-name ribosome\n\n# Create picks with custom user and session\ncopick new picks --config config.json --particle-name proteasome --out-user alice --out-session 1\n\n# Create picks with overwrite enabled\ncopick new picks --config config.json --particle-name ribosome --overwrite True\n</code></pre>"},{"location":"cli/#copick-new-run","title":"<code>copick new run</code>","text":"<p>Create an empty run with the given name.</p> <p>Usage: <pre><code>copick new run [OPTIONS] NAME\n</code></pre></p> <p>Arguments:</p> Argument Type Description <code>NAME</code> String The name of the new run to be created <p>Options:</p> Option Type Description Default <code>-c, --config PATH</code> Path Path to the configuration file Uses <code>COPICK_CONFIG</code> env var <code>--overwrite / --no-overwrite</code> Boolean Overwrite the object if it exists <code>no-overwrite</code> <code>--create / --no-create</code> Boolean Create the object if it does not exist <code>create</code> <code>--debug / --no-debug</code> Boolean Enable debug logging <code>no-debug</code> <p>Examples:</p> <pre><code># Create a new run\ncopick new run --config config.json TS_005\n\n# Create run with overwrite enabled\ncopick new run --config config.json --overwrite TS_005\n</code></pre>"},{"location":"cli/#copick-new-voxelspacing","title":"<code>copick new voxelspacing</code>","text":"<p>Create an empty voxelspacing with the given name.</p> <p>Usage: <pre><code>copick new voxelspacing [OPTIONS] VOXEL_SPACING\n</code></pre></p> <p>Arguments:</p> Argument Type Description <code>VOXEL_SPACING</code> Float The voxel spacing in Angstrom to be added to the run <p>Options:</p> Option Type Description Default <code>-c, --config PATH</code> Path Path to the configuration file Uses <code>COPICK_CONFIG</code> env var <code>--run RUN</code> String Name of the run to add voxel spacing to (required) None <code>--overwrite / --no-overwrite</code> Boolean Overwrite the object if it exists <code>no-overwrite</code> <code>--create / --no-create</code> Boolean Create the object if it does not exist <code>create</code> <code>--debug / --no-debug</code> Boolean Enable debug logging <code>no-debug</code> <p>Examples:</p> <pre><code># Add 10.0 Angstrom voxel spacing to run\ncopick new voxelspacing --config config.json --run TS_001 10.0\n\n# Add voxel spacing with overwrite enabled\ncopick new voxelspacing --config config.json --run TS_001 --overwrite 5.0\n</code></pre>"},{"location":"cli/#copick-sync","title":"<code>copick sync</code>","text":"<p>Synchronize data between Copick projects with support for parallel processing, name mapping, and user filtering.</p> <p>Subcommands:</p> <ul> <li><code>copick sync picks</code> - Synchronize picks between two Copick projects</li> <li><code>copick sync meshes</code> - Synchronize meshes between two Copick projects</li> <li><code>copick sync segmentations</code> - Synchronize segmentations between two Copick projects</li> <li><code>copick sync tomograms</code> - Synchronize tomograms between two Copick projects</li> </ul>"},{"location":"cli/#copick-sync-picks","title":"<code>copick sync picks</code>","text":"<p>Synchronize pick annotations between two Copick projects with support for name mapping and user filtering.</p> <p>Usage: <pre><code>copick sync picks [OPTIONS]\n</code></pre></p> <p>Options:</p> Option Type Description Default <code>-c, --config PATH</code> Path Path to the source configuration file Uses <code>COPICK_CONFIG</code> env var <code>--source-dataset-ids</code> String Comma-separated list of dataset IDs to use as source from CryoET Data Portal <code>\"\"</code> <code>--target-config PATH</code> Path Path to the target configuration file (required) None <code>--source-runs</code> String Comma-separated list of source run names to synchronize <code>\"\"</code> (all runs) <code>--target-runs</code> String Comma-separated mapping of source run names to target run names (e.g. 'run1:target1,run2:target2') <code>\"\"</code> (same names) <code>--source-objects</code> String Comma-separated list of source object names to synchronize <code>\"\"</code> (all objects) <code>--target-objects</code> String Comma-separated mapping of source object names to target object names (e.g. 'ribosome:ribo,membrane:mem') <code>\"\"</code> (same names) <code>--source-users</code> String Comma-separated list of source user IDs to synchronize <code>\"\"</code> (all users) <code>--target-users</code> String Comma-separated mapping of source user IDs to target user IDs (e.g. 'user1:target1,user2:target2') <code>\"\"</code> (same user IDs) <code>--exist-ok/--no-exist-ok</code> Boolean Allow overwriting existing picks in the target project <code>no-exist-ok</code> <code>--max-workers</code> Integer Maximum number of worker threads to use for synchronization <code>4</code> <code>--log/--no-log</code> Boolean Enable verbose logging of the synchronization process <code>no-log</code> <code>--debug/--no-debug</code> Boolean Enable debug logging <code>no-debug</code> <p>Examples:</p> <pre><code># Sync all picks from all runs\ncopick sync picks -c source_config.json --target-config target_config.json\n\n# Sync specific runs with name mapping\ncopick sync picks -c source_config.json --target-config target_config.json \\\n    --source-runs \"run1,run2\" --target-runs \"run1:new_run1,run2:new_run2\"\n\n# Sync specific objects with name mapping\ncopick sync picks -c source_config.json --target-config target_config.json \\\n    --source-objects \"ribosome,membrane\" --target-objects \"ribosome:ribo,membrane:mem\"\n\n# Sync picks from specific users with user mapping\ncopick sync picks -c source_config.json --target-config target_config.json \\\n    --source-users \"user1,user2\" --target-users \"user1:analyst1,user2:analyst2\" \\\n    --exist-ok --log\n\n# Sync from CryoET Data Portal to local project\ncopick sync picks \\\n    --source-dataset-ids \"12345,67890\" \\\n    --target-config target_config.json \\\n    --max-workers 8 --log\n</code></pre>"},{"location":"cli/#copick-sync-meshes","title":"<code>copick sync meshes</code>","text":"<p>Synchronize mesh data between two Copick projects with support for name mapping and user filtering.</p> <p>Usage: <pre><code>copick sync meshes [OPTIONS]\n</code></pre></p> <p>Options:</p> Option Type Description Default <code>-c, --config PATH</code> Path Path to the source configuration file Uses <code>COPICK_CONFIG</code> env var <code>--source-dataset-ids</code> String Comma-separated list of dataset IDs to use as source from CryoET Data Portal <code>\"\"</code> <code>--target-config PATH</code> Path Path to the target configuration file (required) None <code>--source-runs</code> String Comma-separated list of source run names to synchronize <code>\"\"</code> (all runs) <code>--target-runs</code> String Comma-separated mapping of source run names to target run names (e.g. 'run1:target1,run2:target2') <code>\"\"</code> (same names) <code>--source-objects</code> String Comma-separated list of source object names to synchronize <code>\"\"</code> (all objects) <code>--target-objects</code> String Comma-separated mapping of source object names to target object names (e.g. 'ribosome:ribo,membrane:mem') <code>\"\"</code> (same names) <code>--source-users</code> String Comma-separated list of source user IDs to synchronize <code>\"\"</code> (all users) <code>--target-users</code> String Comma-separated mapping of source user IDs to target user IDs (e.g. 'user1:target1,user2:target2') <code>\"\"</code> (same user IDs) <code>--exist-ok/--no-exist-ok</code> Boolean Allow overwriting existing meshes in the target project <code>no-exist-ok</code> <code>--max-workers</code> Integer Maximum number of worker threads to use for synchronization <code>4</code> <code>--log/--no-log</code> Boolean Enable verbose logging of the synchronization process <code>no-log</code> <code>--debug/--no-debug</code> Boolean Enable debug logging <code>no-debug</code> <p>Examples:</p> <pre><code># Sync all meshes from all runs\ncopick sync meshes -c source_config.json --target-config target_config.json\n\n# Sync specific runs with name mapping\ncopick sync meshes -c source_config.json --target-config target_config.json \\\n    --source-runs \"run1,run2\" --target-runs \"run1:new_run1,run2:new_run2\"\n\n# Sync specific objects with name mapping\ncopick sync meshes -c source_config.json --target-config target_config.json \\\n    --source-objects \"ribosome,membrane\" --target-objects \"ribosome:ribo,membrane:mem\"\n\n# Parallel processing with logging\ncopick sync meshes -c source_config.json --target-config target_config.json \\\n    --max-workers 8 --log\n</code></pre>"},{"location":"cli/#copick-sync-segmentations","title":"<code>copick sync segmentations</code>","text":"<p>Synchronize segmentation data between two Copick projects with voxel spacing filtering, name mapping, and user filtering.</p> <p>Usage: <pre><code>copick sync segmentations [OPTIONS]\n</code></pre></p> <p>Options:</p> Option Type Description Default <code>-c, --config PATH</code> Path Path to the source configuration file Uses <code>COPICK_CONFIG</code> env var <code>--source-dataset-ids</code> String Comma-separated list of dataset IDs to use as source from CryoET Data Portal <code>\"\"</code> <code>--target-config PATH</code> Path Path to the target configuration file (required) None <code>--source-runs</code> String Comma-separated list of source run names to synchronize <code>\"\"</code> (all runs) <code>--target-runs</code> String Comma-separated mapping of source run names to target run names (e.g. 'run1:target1,run2:target2') <code>\"\"</code> (same names) <code>--voxel-spacings</code> String Comma-separated list of voxel spacings to consider for synchronization <code>\"\"</code> (all voxel spacings) <code>--source-names</code> String Comma-separated list of source segmentation names to synchronize <code>\"\"</code> (all segmentations) <code>--target-names</code> String Comma-separated mapping of source segmentation names to target names (e.g. 'seg1:target1,seg2:target2') <code>\"\"</code> (same names) <code>--source-users</code> String Comma-separated list of source user IDs to synchronize <code>\"\"</code> (all users) <code>--target-users</code> String Comma-separated mapping of source user IDs to target user IDs (e.g. 'user1:target1,user2:target2') <code>\"\"</code> (same user IDs) <code>--exist-ok/--no-exist-ok</code> Boolean Allow overwriting existing segmentations in the target project <code>no-exist-ok</code> <code>--max-workers</code> Integer Maximum number of worker threads to use for synchronization <code>4</code> <code>--log/--no-log</code> Boolean Enable verbose logging of the synchronization process <code>no-log</code> <code>--debug/--no-debug</code> Boolean Enable debug logging <code>no-debug</code> <p>Examples:</p> <pre><code># Sync all segmentations from all runs\ncopick sync segmentations -c source_config.json --target-config target_config.json\n\n# Sync specific runs and voxel spacings\ncopick sync segmentations -c source_config.json --target-config target_config.json \\\n    --source-runs \"run1,run2\" --voxel-spacings \"10.0,20.0\"\n\n# Sync specific segmentations with name mapping\ncopick sync segmentations -c source_config.json --target-config target_config.json \\\n    --source-names \"membrane,organelle\" --target-names \"membrane:cell_membrane,organelle:mitochondria\"\n\n# Complete synchronization with all options\ncopick sync segmentations -c source_config.json --target-config target_config.json \\\n    --source-runs \"run1,run2\" --target-runs \"run1:exp1,run2:exp2\" \\\n    --voxel-spacings \"10.0,20.0\" \\\n    --source-names \"membrane,organelle\" --target-names \"membrane:cell_membrane,organelle:mitochondria\" \\\n    --source-users \"user1,user2\" --target-users \"user1:analyst1,user2:analyst2\" \\\n    --exist-ok --max-workers 8 --log\n</code></pre>"},{"location":"cli/#copick-sync-tomograms","title":"<code>copick sync tomograms</code>","text":"<p>Synchronize tomogram data between two Copick projects with voxel spacing and tomogram type filtering.</p> <p>Usage: <pre><code>copick sync tomograms [OPTIONS]\n</code></pre></p> <p>Options:</p> Option Type Description Default <code>-c, --config PATH</code> Path Path to the source configuration file Uses <code>COPICK_CONFIG</code> env var <code>--source-dataset-ids</code> String Comma-separated list of dataset IDs to use as source from CryoET Data Portal <code>\"\"</code> <code>--target-config PATH</code> Path Path to the target configuration file (required) None <code>--source-runs</code> String Comma-separated list of source run names to synchronize <code>\"\"</code> (all runs) <code>--target-runs</code> String Comma-separated mapping of source run names to target run names (e.g. 'run1:target1,run2:target2') <code>\"\"</code> (same names) <code>--voxel-spacings</code> String Comma-separated list of voxel spacings to consider for synchronization <code>\"\"</code> (all voxel spacings) <code>--source-tomo-types</code> String Comma-separated list of source tomogram types to synchronize <code>\"\"</code> (all tomogram types) <code>--target-tomo-types</code> String Comma-separated mapping of source tomogram types to target types (e.g. 'wbp:filtered,raw:original') <code>\"\"</code> (same types) <code>--exist-ok/--no-exist-ok</code> Boolean Allow overwriting existing tomograms in the target project <code>no-exist-ok</code> <code>--max-workers</code> Integer Maximum number of worker threads to use for synchronization <code>4</code> <code>--log/--no-log</code> Boolean Enable verbose logging of the synchronization process <code>no-log</code> <code>--debug/--no-debug</code> Boolean Enable debug logging <code>no-debug</code> <p>Examples:</p> <pre><code># Sync all tomograms from all runs\ncopick sync tomograms -c source_config.json --target-config target_config.json\n\n# Sync specific runs and voxel spacings\ncopick sync tomograms -c source_config.json --target-config target_config.json \\\n    --source-runs \"run1,run2\" --voxel-spacings \"10.0,20.0\"\n\n# Sync specific tomogram types with name mapping\ncopick sync tomograms -c source_config.json --target-config target_config.json \\\n    --source-tomo-types \"wbp,raw\" --target-tomo-types \"wbp:filtered,raw:original\"\n\n# Complete tomogram synchronization\ncopick sync tomograms -c source_config.json --target-config target_config.json \\\n    --source-runs \"run1,run2\" --target-runs \"run1:exp1,run2:exp2\" \\\n    --voxel-spacings \"10.0\" \\\n    --source-tomo-types \"wbp,denoised\" --target-tomo-types \"wbp:processed,denoised:clean\" \\\n    --exist-ok --max-workers 6 --log\n</code></pre>"},{"location":"cli/#copick-info","title":"<code>copick info</code>","text":"<p>Display information about the Copick CLI and available plugins.</p> <p>Usage: <pre><code>copick info\n</code></pre></p> <p>Examples:</p> <pre><code># Show CLI information and available plugins\ncopick info\n</code></pre>"},{"location":"cli/#plugin-system","title":"Plugin System","text":"<p>Extensibility</p> <p>The Copick CLI supports extensibility through plugins. External packages can register additional commands by defining entry points in multiple supported groups.</p>"},{"location":"cli/#supported-entry-point-groups","title":"Supported Entry Point Groups","text":"<p>The plugin system supports the following entry point groups:</p> <ul> <li><code>copick.commands</code>: Commands added directly to the main CLI (e.g., <code>copick mycommand</code>)</li> <li><code>copick.inference.commands</code>: Commands under the inference group (e.g., <code>copick inference mymodel</code>)</li> <li><code>copick.training.commands</code>: Commands under the training group (e.g., <code>copick training mytrain</code>)</li> <li><code>copick.evaluation.commands</code>: Commands under the evaluation group (e.g., <code>copick evaluation myscore</code>)</li> <li><code>copick.process.commands</code>: Commands under the process group (e.g., <code>copick process mymethod</code>)</li> <li><code>copick.convert.commands</code>: Commands under the convert group (e.g., <code>copick convert myconverter</code>)</li> </ul>"},{"location":"cli/#plugin-registration","title":"Plugin Registration","text":"<p>Using pyproject.toml: <pre><code># Commands added to main CLI group\n[project.entry-points.\"copick.commands\"]\nmycommand = \"my_copick_plugin.cli.cli:mycommand\"\n\n# Commands added to inference group\n[project.entry-points.\"copick.inference.commands\"]\nmymodel-infer = \"my_copick_plugin.cli.cli:mymodel_infer\"\n\n# Commands added to training group\n[project.entry-points.\"copick.training.commands\"]\nmymodel-train = \"my_copick_plugin.cli.cli:mymodel_train\"\n\n# Commands added to evaluation group\n[project.entry-points.\"copick.evaluation.commands\"]\nmyscore = \"my_copick_plugin.cli.cli:myscore\"\n\n# Commands added to process group\n[project.entry-points.\"copick.process.commands\"]\nmymethod = \"my_copick_plugin.cli.cli:mymethod\"\n\n# Commands added to convert group\n[project.entry-points.\"copick.convert.commands\"]\nmyconverter = \"my_copick_plugin.cli.cli:myconverter\"\n</code></pre></p>"},{"location":"cli/#plugin-implementation","title":"Plugin Implementation","text":"<p>Creating Click Commands: <pre><code>import click\nfrom copick.cli.util import add_config_option, add_debug_option\nfrom copick.util.log import get_logger\n\n@click.command(short_help=\"A command added to the main copick CLI.\")\n@add_config_option\n@click.option(\"--option\", \"-o\", type=str, default=None, help=\"An example option.\")\n@add_debug_option\n@click.pass_context\ndef mycommand(ctx: click.Context, config: str, option: str, debug: bool):\n    \"\"\"A command that serves as an example for how to implement a CLI command in copick.\"\"\"\n    logger = get_logger(__name__, debug=debug)\n    logger.info(f\"Running mycommand with config: {config}, option: {option}\")\n    # Add your command logic here\n\n@click.command(short_help=\"An inference command.\")\n@add_config_option\n@click.option(\"--model-path\", type=str, help=\"Path to model file.\")\n@add_debug_option\n@click.pass_context\ndef mymodel_infer(ctx: click.Context, config: str, model_path: str, debug: bool):\n    \"\"\"A command that serves as an example for how to implement an inference CLI command in copick.\"\"\"\n    logger = get_logger(__name__, debug=debug)\n    logger.info(f\"Running inference with model: {model_path}\")\n    # Add your inference logic here\n\n@click.command(short_help=\"A training command.\")\n@add_config_option\n@click.option(\"--epochs\", type=int, default=100, help=\"Number of training epochs.\")\n@add_debug_option\n@click.pass_context\ndef mymodel_train(ctx: click.Context, config: str, epochs: int, debug: bool):\n    \"\"\"A command that serves as an example for how to implement a training CLI command in copick.\"\"\"\n    logger = get_logger(__name__, debug=debug)\n    logger.info(f\"Starting training for {epochs} epochs\")\n    # Add your training logic here\n</code></pre></p>"},{"location":"cli/#demo-package","title":"Demo Package","text":"<p>A complete demo package is available at copick-plugin-demo that demonstrates:</p> <ul> <li>Project structure for copick plugins</li> <li>Commands for all supported entry point groups</li> <li>Proper use of copick utilities like <code>add_config_option</code> and <code>add_debug_option</code></li> <li>Entry point configuration in <code>pyproject.toml</code></li> <li>Example command implementations</li> </ul> <p>You can use this demo as a template for creating your own copick plugins.</p>"},{"location":"cli/#usage","title":"Usage","text":"<p>After installing your package, the commands will be available: <pre><code># Main CLI commands\ncopick mycommand --config path/to/config.json --option value\n\n# Grouped commands\ncopick inference mymodel-infer --config path/to/config.json --model-path ./model.pt\ncopick training mymodel-train --config path/to/config.json --epochs 50\ncopick evaluation myscore --config path/to/config.json\ncopick process mymethod --config path/to/config.json\ncopick convert myconverter --config path/to/config.json\n</code></pre></p>"},{"location":"cli/#best-practices","title":"Best Practices","text":"<ol> <li>Use descriptive command names that clearly indicate their purpose</li> <li>Follow the existing naming conventions with hyphens for multi-word commands</li> <li>Always use <code>@add_config_option</code> and <code>@add_debug_option</code> decorators for consistency</li> <li>Add proper docstrings for your commands - they become the help text</li> <li>Use appropriate entry point groups to organize your commands logically</li> <li>Test your plugins with the demo package structure as a reference</li> </ol>"},{"location":"cli/#common-workflows","title":"Common Workflows","text":""},{"location":"cli/#setup-from-data-portal","title":"Setup from Data Portal","text":"<p>Create a new project from CryoET Data Portal datasets:</p> <pre><code># Create configuration from data portal\ncopick config dataportal --dataset-id 10000 --overlay ./overlay --output project.json\n\n# Set environment variable for convenience\nexport COPICK_CONFIG=project.json\n\n# Browse the project\ncopick browse\n</code></pre>"},{"location":"cli/#add-data-to-project","title":"Add Data to Project","text":"<p>Add tomograms, segmentations, and objects to your project:</p> <pre><code># Add a single tomogram\ncopick add tomogram --run TS_001 data/tomogram.mrc\n\n# Add multiple tomograms using glob pattern\ncopick add tomogram data/tomograms/*.mrc\n\n# Add pickable objects to the project configuration\ncopick add object --name ribosome --object-type particle --radius 120 --pdb-id 4V9D --color \"255,0,0,255\"\ncopick add object --name membrane --object-type segmentation --label 1 --color \"0,255,0,128\"\n\n# Add volume data to existing objects\ncopick add object-volume --object-name ribosome --volume-path data/ribosome_reference.mrc --voxel-size 10.0\n\n# Add segmentation data\ncopick add segmentation --run TS_001 --name membrane --user-id analyst data/membrane_seg.mrc\n\n# Create empty picks for annotation\ncopick new picks --particle-name ribosome\n\n# Browse to verify\ncopick browse\n</code></pre>"},{"location":"cli/#work-with-multiple-datasets","title":"Work with Multiple Datasets","text":"<p>Combine multiple datasets in one project:</p> <pre><code># Create configuration with multiple datasets\ncopick config dataportal -ds 10000 -ds 10001 -ds 10002 --overlay ./overlay --output multi_project.json\n\n# Browse all datasets together\ncopick browse --config multi_project.json\n</code></pre>"},{"location":"cli/#synchronize-data-between-projects","title":"Synchronize Data Between Projects","text":"<p>Synchronize data between different Copick projects:</p> <pre><code># Basic synchronization of all data types\ncopick sync picks -c source_config.json --target-config target_config.json --log\ncopick sync meshes -c source_config.json --target-config target_config.json --log\ncopick sync segmentations -c source_config.json --target-config target_config.json --log\ncopick sync tomograms -c source_config.json --target-config target_config.json --log\n\n# Sync from CryoET Data Portal to local project\ncopick sync picks \\\n    --source-dataset-ids \"12345,67890\" \\\n    --target-config local_project.json \\\n    --max-workers 8 --log\n\n# Sync with name mapping and user filtering\ncopick sync picks -c source_config.json --target-config target_config.json \\\n    --source-runs \"run1,run2\" --target-runs \"run1:experiment_A,run2:experiment_B\" \\\n    --source-objects \"ribosome,membrane\" --target-objects \"ribosome:large_ribosomal_subunit,membrane:plasma_membrane\" \\\n    --source-users \"user1,user2\" --target-users \"user1:analyst1,user2:analyst2\" \\\n    --exist-ok --log\n\n# Selective synchronization of specific voxel spacings and segmentation types\ncopick sync segmentations -c source_config.json --target-config target_config.json \\\n    --voxel-spacings \"10.0,20.0\" \\\n    --source-names \"membrane,organelle\" --target-names \"membrane:cell_membrane,organelle:mitochondria\" \\\n    --log\n\ncopick sync tomograms -c source_config.json --target-config target_config.json \\\n    --voxel-spacings \"10.0\" \\\n    --source-tomo-types \"wbp,denoised\" --target-tomo-types \"wbp:processed,denoised:clean\" \\\n    --log\n</code></pre>"},{"location":"cli/#development-and-debugging","title":"Development and Debugging","text":"<p>Debug and test your Copick workflows:</p> <pre><code># Run commands with debug logging\ncopick browse --config project.json --debug\n\n# Create a new run for testing\ncopick new run --config project.json TEST_RUN\n\n# Add a voxel spacing to the test run\ncopick new voxelspacing --config project.json --run TEST_RUN 10.0\n\n# Add a tomogram with detailed output\ncopick add tomogram --config project.json --run TEST_RUN --debug data/test_tomogram.mrc\n\n# Test synchronization with debug logging\ncopick sync picks -c source_config.json --target-config target_config.json --debug --log\n</code></pre>"},{"location":"contributing/","title":"Contributing to Copick","text":"<p>We welcome contributions to copick! Whether you're reporting bugs, suggesting features, improving documentation, or contributing code, your help is appreciated.</p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":""},{"location":"contributing/#development-setup","title":"Development Setup","text":"<ol> <li> <p>Fork and clone the repository:    <pre><code>git fork https://github.com/copick/copick.git\ngit clone https://github.com/&lt;your-username&gt;/copick.git\ncd copick\n</code></pre></p> </li> <li> <p>Create a virtual environment (recommended):    <pre><code>python -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n</code></pre></p> </li> <li> <p>Install with development dependencies:    <pre><code>pip install -e \".[dev,test]\"\n</code></pre></p> </li> <li> <p>Install pre-commit hooks:    <pre><code>pre-commit install\n</code></pre></p> </li> <li> <p>Run tests to ensure everything is working:    <pre><code>pytest\n</code></pre></p> </li> </ol>"},{"location":"contributing/#development-commands","title":"Development Commands","text":"<p>All development commands are documented in <code>CLAUDE.md</code> for AI assistants, but here are the key ones:</p>"},{"location":"contributing/#testing","title":"Testing","text":"<pre><code># Run all tests\npytest\n\n# Run a specific test file\npytest tests/test_filesystem.py\n\n# Run with coverage\npytest --cov=copick\n\n# Run all tests including integration tests (default)\nRUN_ALL=1 pytest\n\n# Run only fast tests (skip integration tests)\nRUN_ALL=0 pytest\n</code></pre>"},{"location":"contributing/#code-quality","title":"Code Quality","text":"<pre><code># Format code with black\nblack src/ tests/\n\n# Lint with ruff\nruff check src/ tests/\n\n# Fix auto-fixable ruff issues\nruff check --fix src/ tests/\n\n# Run pre-commit hooks\npre-commit run --all-files\n</code></pre>"},{"location":"contributing/#documentation","title":"Documentation","text":"<pre><code># Serve documentation locally\nmkdocs serve\n\n# Build documentation\nmkdocs build\n</code></pre>"},{"location":"contributing/#commit-message-guidelines","title":"Commit Message Guidelines","text":"<p>All pull requests must use Conventional Commits for commit messages. This helps us automatically generate changelogs and determine version bumps.</p>"},{"location":"contributing/#format","title":"Format","text":"<pre><code>&lt;type&gt;[optional scope]: &lt;description&gt;\n\n[optional body]\n\n[optional footer(s)]\n</code></pre>"},{"location":"contributing/#types","title":"Types","text":"<ul> <li><code>feat</code>: A new feature</li> <li><code>fix</code>: A bug fix</li> <li><code>docs</code>: Documentation only changes</li> <li><code>style</code>: Changes that do not affect the meaning of the code (white-space, formatting, etc)</li> <li><code>refactor</code>: A code change that neither fixes a bug nor adds a feature</li> <li><code>perf</code>: A code change that improves performance</li> <li><code>test</code>: Adding missing tests or correcting existing tests</li> <li><code>build</code>: Changes that affect the build system or external dependencies</li> <li><code>ci</code>: Changes to our CI configuration files and scripts</li> <li><code>chore</code>: Other changes that don't modify src or test files</li> </ul>"},{"location":"contributing/#examples","title":"Examples","text":"<pre><code>feat: add support for new tomogram format\nfix: resolve memory leak in zarr loading\ndocs: update installation instructions\ntest: add unit tests for mesh operations\nrefactor: simplify configuration loading logic\nperf: optimize zarr array reading for large volumes\n</code></pre>"},{"location":"contributing/#plugin-development","title":"Plugin Development","text":"<p>Copick supports a plugin system that allows external Python packages to register CLI commands. Commands can be added to the main CLI or organized into groups like <code>inference</code>, <code>training</code>, <code>evaluation</code>, <code>process</code>, and <code>convert</code>.</p>"},{"location":"contributing/#supported-entry-point-groups","title":"Supported Entry Point Groups","text":"<p>The plugin system supports the following entry point groups:</p> <ul> <li><code>copick.commands</code>: Commands added directly to the main CLI (e.g., <code>copick mycommand</code>)</li> <li><code>copick.inference.commands</code>: Commands under the inference group (e.g., <code>copick inference mymodel</code>)</li> <li><code>copick.training.commands</code>: Commands under the training group (e.g., <code>copick training mytrain</code>)</li> <li><code>copick.evaluation.commands</code>: Commands under the evaluation group (e.g., <code>copick evaluation myscore</code>)</li> <li><code>copick.process.commands</code>: Commands under the process group (e.g., <code>copick process mymethod</code>)</li> <li><code>copick.convert.commands</code>: Commands under the convert group (e.g., <code>copick convert myconverter</code>)</li> </ul>"},{"location":"contributing/#creating-a-plugin","title":"Creating a Plugin","text":"<ol> <li> <p>Set up your package structure:    <pre><code>my-copick-plugin/\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 my_copick_plugin/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u2514\u2500\u2500 cli/\n\u2502           \u251c\u2500\u2500 __init__.py\n\u2502           \u2514\u2500\u2500 cli.py\n\u251c\u2500\u2500 pyproject.toml\n\u2514\u2500\u2500 README.md\n</code></pre></p> </li> <li> <p>In your package's <code>pyproject.toml</code>, add entry points for the desired groups:    <pre><code># Commands added to main CLI group\n[project.entry-points.\"copick.commands\"]\nmycommand = \"my_copick_plugin.cli.cli:mycommand\"\n\n# Commands added to inference group\n[project.entry-points.\"copick.inference.commands\"]\nmymodel-infer = \"my_copick_plugin.cli.cli:mymodel_infer\"\n\n# Commands added to training group\n[project.entry-points.\"copick.training.commands\"]\nmymodel-train = \"my_copick_plugin.cli.cli:mymodel_train\"\n\n# Commands added to evaluation group\n[project.entry-points.\"copick.evaluation.commands\"]\nmyscore = \"my_copick_plugin.cli.cli:myscore\"\n\n# Commands added to process group\n[project.entry-points.\"copick.process.commands\"]\nmymethod = \"my_copick_plugin.cli.cli:mymethod\"\n\n# Commands added to convert group\n[project.entry-points.\"copick.convert.commands\"]\nmyconverter = \"my_copick_plugin.cli.cli:myconverter\"\n</code></pre></p> </li> <li> <p>Create Click commands in your package:    <pre><code>import click\n\nfrom copick.cli.util import add_config_option, add_debug_option\nfrom copick.util.log import get_logger\n\n@click.command(short_help=\"A command added to the main copick CLI.\")\n@add_config_option\n@click.option(\"--option\", \"-o\", type=str, default=None, help=\"An example option.\")\n@add_debug_option\n@click.pass_context\ndef mycommand(ctx: click.Context, config: str, option: str, debug: bool):\n    \"\"\"A command that serves as an example for how to implement a CLI command in copick.\"\"\"\n    logger = get_logger(__name__, debug=debug)\n    logger.info(f\"Running mycommand with config: {config}, option: {option}\")\n    # Add your command logic here\n\n@click.command(short_help=\"An inference command.\")\n@add_config_option\n@click.option(\"--model-path\", type=str, help=\"Path to model file.\")\n@add_debug_option\n@click.pass_context\ndef mymodel_infer(ctx: click.Context, config: str, model_path: str, debug: bool):\n    \"\"\"A command that serves as an example for how to implement an inference CLI command in copick.\"\"\"\n    logger = get_logger(__name__, debug=debug)\n    logger.info(f\"Running inference with model: {model_path}\")\n    # Add your inference logic here\n</code></pre></p> </li> <li> <p>After installing your package, the commands will be available via:    <pre><code>copick mycommand --config path/to/config.json --option value\ncopick inference mymodel-infer --config path/to/config.json --model-path ./model.pt\ncopick training mymodel-train --config path/to/config.json\ncopick evaluation myscore --config path/to/config.json\ncopick process mymethod --config path/to/config.json\ncopick convert myconverter --config path/to/config.json\n</code></pre></p> </li> </ol>"},{"location":"contributing/#demo-package","title":"Demo Package","text":"<p>A complete demo package is available at copick-plugin-demo that demonstrates:</p> <ul> <li>Project structure for copick plugins</li> <li>Commands for all supported entry point groups</li> <li>Proper use of copick utilities like <code>add_config_option</code> and <code>add_debug_option</code></li> <li>Entry point configuration in <code>pyproject.toml</code></li> <li>Example command implementations</li> </ul> <p>You can use this demo as a template for creating your own copick plugins.</p> <p>Thank you for contributing to copick! \ud83d\ude80</p>"},{"location":"datamodel/","title":"Data Model","text":""},{"location":"datamodel/#data-entities","title":"Data Entities","text":""},{"location":"datamodel/#root","title":"Root","text":"<p>The project's root. This is the entry point for the copick API. It allows access to information about the pickable objects and runs contained in the project.</p> Example Code - Print available objects and runs <pre><code>\"\"\"Print all objects and runs in a copick project.\"\"\"\n\nimport copick\n\n# Initialize the root object from a configuration file\nroot = copick.from_file(\"path/to/config.json\")\n\n# List all available objects\nobj_info = [(o.name, o.label) for o in root.pickable_objects]\n\nprint(\"Pickable objects in this project:\")\nfor name, label in obj_info:\n    print(f\"  {name}: {label}\")\n\n# Execute a function on each run in the project\nruns = root.runs\n\nprint(\"Runs in this project:\")\nfor run in runs:\n    print(f\"Run: {run.name}\")\n    # Do something with the run\n</code></pre> <p>Refer to the API Reference for more information on the CopickRoot API.</p>"},{"location":"datamodel/#pickable-object","title":"Pickable Object","text":"<p>Objects are any entity that can be labeled inside a 3D image using points, meshes or dense segmentation masks. In most cases, these will be macromolecular complexes or other cellular structures, like membranes. They can also be more abstract entities like \"contamination particles\", \"carbon edges\", or \"sample boundaries\".</p> <p>In the configuration file, each object is defined by a JSON object, that allows the user to specify the object's name, label, color, radius, and other properties.</p> <p>Naming Conventions</p> <p>Object names should never contain underscores!</p> Example Code - Read an object's density map. <pre><code>\"\"\"Read a density map from an object's zarr-store into a numpy array.\"\"\"\n\nimport copick\nimport numpy as np\nimport zarr\n\n# Initialize the root object from a configuration file\nroot = copick.from_file(\"path/to/config.json\")\n\n# Get the object named 'proteasome'\nproteasome = root.get_object(\"proteasome\")\n\n# Read the density map for the object from its zarr-store\nzarr_array = zarr.open(proteasome.zarr())[\"0\"]\ndensity_map = np.array(zarr_array)\n</code></pre> <p>Refer to the API Reference for more information on the CopickObject API.</p> <p>Example Object Definition</p> <p>The following is an example of a pickable object definition in the configuration file: <pre><code>{\n    \"name\": \"proteasome\",\n    \"is_particle\": true,\n    \"pdb_id\": \"3J9I\",\n    \"emdb_id\": \"1234\",\n    \"identifier\": \"GO:0001234\",\n    \"label\": 1,\n    \"color\": [255, 0, 0, 255],\n    \"radius\": 60,\n    \"map_threshold\": 0.0418,\n    \"metadata\": {\n        \"source\": \"experimental_data\",\n        \"confidence\": 0.95,\n        \"notes\": \"High-resolution structure\"\n    }\n}\n</code></pre></p> <ul> <li><code>name</code>: The name of the object, which should be unique within one project.</li> <li> <p><code>is_particle</code>: A boolean indicating whether the object can be represented by point annotations. By default, all     objects can be represented by mesh annotations or dense segmentations.</p> </li> <li> <p><code>pdb_id</code>: The PDB ID of the object, if available.</p> </li> <li><code>emdb_id</code>: The EMDB ID of the object, if available.</li> <li><code>identifier</code>: The GO ID of the object or a UniProtKB accession, if available. When using the data portal, this     field is used to find matching annotations in the data portal.</li> <li><code>label</code>: An integer that indicates which numeric label should be used in segmentations to represent this object.</li> <li><code>color</code>: An array of four integers that represent the RGBA color of the object when rendered in a 3D viewer.</li> <li><code>radius</code>: An integer that represents the radius of the object in angstroms. This is used to determine the size of the     object when rendering it as a sphere in a 3D viewer.</li> <li><code>map_threshold</code>: A float that represents the threshold value to use when a density map is used to represent the     object. This is used to determine the isosurface level to use when rendering the object as a mesh. Density maps are     discovered by the copick API by looking for files with the same name as the object in the <code>Objects</code> directory of     the project's root.</li> <li><code>metadata</code>: An optional dictionary that can contain arbitrary key-value pairs for storing additional custom     information about the object. This field allows users to attach project-specific metadata such as confidence scores,     data sources, or processing notes.</li> </ul>"},{"location":"datamodel/#run","title":"Run","text":"<p>A run is a collection of data that is associated with a particular location on the sample. Run objects allow access to any 3D image data, segmentations, and annotations that are associated with a particular location on the sample. Images are stored in groups based on their voxel spacing, while point annotations, mesh annotations, and dense segmentations are related to the run as a whole.</p> Example Code - List available segmentations for a run <pre><code>\"\"\"Print all segmentations for a run in a copick project.\"\"\"\n\nimport copick\n\n# Initialize the root object from a configuration file\nroot = copick.from_file(\"path/to/config.json\")\n\n# Get the run named 'TS_001'\nrun = root.get_run(\"TS_001\")\n\n# List all available segmentations for the run\nsegmentations = run.segmentations\nfor segmentation in segmentations:\n    print(f\"Segmentation: {segmentation.name}\")\n</code></pre> <p>Refer to the API Reference for more information on the CopickRun API.</p>"},{"location":"datamodel/#voxel-spacing","title":"Voxel Spacing","text":"<p>A voxel spacing groups together all tomograms of a particular resolution. Voxel spacings are rounded to the third decimal place.</p> Example Code - List available tomograms for a voxel spacing <pre><code>\"\"\"Print the list of tomograms for a given voxel spacing.\"\"\"\n\nimport copick\n\n# Initialize the root object from a configuration file\nroot = copick.from_file(\"path/to/config.json\")\n\n# Get the run named 'TS_001'\nrun = root.get_run(\"TS_001\")\n\n# Get the voxel spacing with a resolution of 10 angstroms\nvoxel_spacing = run.get_voxel_spacing(10.000)\n\n# List all available tomograms for the voxel spacing\ntomograms = voxel_spacing.tomograms\nfor tomogram in tomograms:\n    print(f\"Tomogram: {tomogram.name}\")\n</code></pre> <p>Refer to the API Reference for more information on the CopickVoxelSpacing API.</p>"},{"location":"datamodel/#image-data","title":"Image data","text":""},{"location":"datamodel/#tomogram","title":"Tomogram","text":"<p>At each resolution, multiple tomograms can be stored. Tomograms are stored as OME-NGFF files, which are a zarr-based format that allows for efficient access to multiscale 3D image data. The filename of the zarr file allows relating the image to its reconstruction method or processing steps. Typical useful tomogram types are <code>wbp</code>, <code>sirt</code>, <code>denoised</code>, etc.</p> Example Code - Read a tomogram into a numpy array <pre><code>\"\"\"Read a tomogram from a zarr-store into a numpy array.\"\"\"\n\nimport copick\nimport numpy as np\nimport zarr\n\n# Initialize the root object from a configuration file\nroot = copick.from_file(\"path/to/config.json\")\n\n# Get the run named 'TS_001'\nrun = root.get_run(\"TS_001\")\n\n# Get the voxel spacing with a resolution of 10 angstroms\nvoxel_spacing = run.get_voxel_spacing(10.000)\n\n# Get the tomogram named 'wbp'\ntomogram = voxel_spacing.get_tomogram(\"wbp\")\n\n# Read the tomogram from its zarr-store\n# Scale \"0\" is the unbinned tomogram\nzarr_array = zarr.open(tomogram.zarr())[\"0\"]\ntomogram_data = np.array(zarr_array)\n\n# Scale \"1\" is the tomogram binned by 2\nzarr_array_bin2 = zarr.open(tomogram.zarr())[\"1\"]\ntomogram_data_bin2 = np.array(zarr_array_bin2)\n</code></pre> <p>Refer to the API Reference for more information on the CopickTomogram API.</p> <p>Example tomogram file name</p> <p>Tomograms are named according to the following pattern: <pre><code>wbp.zarr\n</code></pre></p> <p>The <code>wbp</code> part of the filename is the type of tomogram. This could be <code>wbp</code>, <code>sirt</code>, <code>denoised</code>, etc.</p>"},{"location":"datamodel/#feature-map","title":"Feature Map","text":"<p>Feature maps are stored as OME-NGFF files with relation to the tomogram they are computed from. Feature maps are stored as zarr files, and can be used to store any type of data that is computed from a tomogram. They may be useful for interactive segmentation tasks.</p> Example Code - Read a feature map into a numpy array <pre><code>\"\"\"Read a feature map from a zarr-store into a numpy array.\"\"\"\n\nimport copick\nimport numpy as np\nimport zarr\n\n# Initialize the root object from a configuration file\nroot = copick.from_file(\"path/to/config.json\")\n\n# Get the run named 'TS_001'\nrun = root.get_run(\"TS_001\")\n\n# Get the voxel spacing with a resolution of 10 angstroms\nvoxel_spacing = run.get_voxel_spacing(10.000)\n\n# Get the tomogram named 'wbp'\ntomogram = voxel_spacing.get_tomogram(\"wbp\")\n\n# Get the feature map named 'sobel'\nfeature_map = tomogram.get_features(\"sobel\")\n\n# Read the feature map from its zarr-store\nzarr_array = zarr.open(feature_map.zarr())[\"0\"]\nfeature_map_data = np.array(zarr_array)\n</code></pre> <p>Refer to the API Reference for more information on the CopickFeatures API.</p> <p>Example feature map file name</p> <p>Feature maps are named according to the following pattern: <pre><code>wbp_density_features.zarr\n</code></pre></p> <p>The <code>wbp</code> part of the filename is the type of tomogram that the feature map was computed from. The <code>sobel</code> part of the filename is the type of feature that the feature map represents. This could be <code>density</code>, <code>gradient</code>, <code>curvature</code>, etc.</p>"},{"location":"datamodel/#annotation-data","title":"Annotation data","text":""},{"location":"datamodel/#point-annotations","title":"Point Annotations","text":"<p>Point annotations are stored as JSON files in the <code>Picks</code> directory of the run. Each file contains a list of points in angstrom coordinates that represent the location of a particular object in the tomogram. The filename of the JSON file allows relating the points to the user or tool that created them, as well as the object that they represent.</p> <p>Naming Conventions</p> <p>user_ids, session_ids, and object names should never contain underscores!</p> Example Code - Read point annotations from copick <pre><code>\"\"\"Read points from a CopickPicks object.\"\"\"\n\nimport copick\nimport numpy as np\n\n# Initialize the root object from a configuration file\nroot = copick.from_file(\"path/to/config.json\")\n\n# Get the first run in the project\nrun = root.runs[0]\n\n# Get 'proteasome' picks of user 'alice'\npicks = run.get_picks(object_name=\"proteasome\", user_id=\"alice\")[0]\n\n# Get the points from the picks\npoint_arr = np.ndarray((len(picks.points), 3))\nfor idx, pt in enumerate(picks.points):\n    point_arr[idx, :] = [pt.location.x, pt.location.y, pt.location.z]\n</code></pre> <p>Refer to the API Reference for more information on the CopickPicks API.</p> <p>Example point file name</p> <p>Point files are named according to the following pattern: <pre><code>good.picker_0_proteasome.json\n</code></pre></p> <p>The <code>good.picker</code> part of the filename is the user or tool that created the points. The <code>0</code> part of the filename is the session id of the user or tool that created the points. The <code>proteasome</code> part of the filename is the name of the object that the points represent.</p>"},{"location":"datamodel/#mesh-annotations","title":"Mesh Annotations","text":"<p>Mesh annotations are stored as glb files in the <code>Meshes</code> directory of the run. Each file contains a 3D mesh, with vertices in angstrom coordinates, that represents the shape of a particular object in the tomogram. The filename of the glb file allows relating the mesh to the user or tool that created it, as well as the object that it represents.</p> <p>Naming Conventions</p> <p>user_ids, session_ids, and object names should never contain underscores!</p> Example Code - Read mesh annotations and visualize them in 3D <pre><code>\"\"\"Read a mesh from a CopickMesh object and display it.\"\"\"\n\nimport copick\n\n# Initialize the root object from a configuration file\nroot = copick.from_file(\"path/to/config.json\")\n\n# Get the first run in the project\nrun = root.runs[0]\n\n# Get a membrane mesh from user 'bob'\nmesh = run.get_meshes(object_name=\"membrane\", user_id=\"bob\")[0]\n\n# Show the mesh\nmesh.mesh.show()\n</code></pre> <p>Refer to the API Reference for more information on the CopickMesh API.</p> <p>Example mesh file name</p> <p>Mesh files are named according to the following pattern: <pre><code>good.picker_0_proteasome.glb\n</code></pre></p> <p>The <code>good.picker</code> part of the filename is the user or tool that created the mesh. The <code>0</code> part of the filename is the session id of the user or tool that created the mesh. The <code>proteasome</code> part of the filename is the name of the object that the mesh represents.</p>"},{"location":"datamodel/#dense-segmentations","title":"Dense Segmentations","text":"<p>Dense segmentations are stored as OME-NGFF files in the <code>Segmentations</code> directory of the run. Each can either contain a binary segmentation (values of 0 or 1) or a multilabel segmentation (where permissable labels are defined by the labels among the pickable objects). The filename of the zarr file allows relating the segmentation to the user or tool that created it, as well as the object that it represents.</p> <p>Naming Conventions</p> <p>user_ids, session_ids, and object names should never contain underscores!</p> Example Code - Read a segmentation into a numpy array <pre><code>\"\"\"Read a segmentation from a CopickSegmentation object.\"\"\"\n\nimport copick\nimport numpy as np\nimport zarr\n\n# Initialize the root object from a configuration file\nroot = copick.from_file(\"path/to/config.json\")\n\n# Get the first run in the project\nrun = root.runs[0]\n\n# Get 'proteasome' segmentation of user 'alice'\nsegmentation = run.get_segmentations(object_name=\"proteasome\", user_id=\"alice\")[0]\n\n# Get the segmentation array from the segmentation\nseg_zarr = zarr.open(segmentation.zarr())[\"0\"]\nseg = np.array(seg_zarr)\n</code></pre> <p>Refer to the API Reference for more information on the CopickSegmentation API.</p> <p>Example segmentation file names</p> <p>Segmentation files are named according to the following pattern: <pre><code>10.000_good.picker_0_proteasome.zarr\n</code></pre></p> <p>The <code>10.000</code> part of the filename is the voxel spacing of the tomogram that the segmentation was created from. The <code>good.picker</code> part of the filename is the user or tool that created the segmentation. The <code>0</code> part of the filename is the session id of the user or tool that created the segmentation. The <code>proteasome</code> part of the filename is the name of the object that the segmentation represents. This is a binary segmentation.</p> <pre><code>10.000_good.picker_0_segmentation-multilabel.zarr\n</code></pre> <p>The <code>10.000</code> part of the filename is the voxel spacing of the tomogram that the segmentation was created from. The <code>good.picker</code> part of the filename is the user or tool that created the segmentation. The <code>0</code> part of the filename is the session id of the user or tool that created the segmentation. The <code>segmentation</code> part of the filename is an arbitrary name that describes the segmentation. This is a multilabel segmentation, thus all objects in the project could be represented in this segmentation.</p>"},{"location":"datamodel/#on-disk-data-model","title":"On-disk Data Model","text":"<p>The on-disk data model of copick is as follows:</p> <pre><code>\ud83d\udcc1 copick_root\n\u251c\u2500 \ud83d\udcc4 copick_config.json\n\u251c\u2500 \ud83d\udcc1 Objects\n\u2502  \u2514\u2500 \ud83d\udcc4 [pickable_object_name].zarr\n\u2514\u2500 \ud83d\udcc1 ExperimentRuns\n   \u2514\u2500 \ud83d\udcc1 [run_name] (index: src/io/copick_models.py:CopickPicks.runs)\n      \u251c\u2500 \ud83d\udcc1 VoxelSpacing[xx.yyy]/\n      \u2502  \u251c\u2500 \ud83d\udcc1 [tomotype].zarr/\n      \u2502  \u2502  \u2514\u2500 [OME-NGFF spec at 100%, 50% and 25% scale]\n      \u2502  \u2514\u2500 \ud83d\udcc1 [tomotype]_[feature_type]_features.zarr/\n      \u2502     \u2514\u2500 [OME-NGFF spec at 100% scale]\n      \u251c\u2500 \ud83d\udcc1 VoxelSpacing[x2.yy2]/\n      \u2502  \u251c\u2500 \ud83d\udcc1 [tomotype].zarr/\n      \u2502  \u2502  \u2514\u2500 [OME-NGFF spec at 100%, 50% and 25% scale]\n      \u2502  \u2514\u2500 \ud83d\udcc1 [tomotype]_[feature_type]_features.zarr/\n      \u2502     \u2514\u2500 [OME-NGFF spec at 100% scale]\n      \u251c\u2500 \ud83d\udcc1 Picks/\n      \u2502  \u2514\u2500 \ud83d\udcc4 [user_id | tool_name]_[session_id | 0]_[object_name].json\n      \u251c\u2500 \ud83d\udcc1 Meshes/\n      \u2502  \u2514\u2500 \ud83d\udcc4 [user_id | tool_name]_[session_id | 0]_[object_name].glb\n      \u2514\u2500 \ud83d\udcc1 Segmentations/\n         \u251c\u2500 \ud83d\udcc1 [xx.yyy]_[user_id | tool_name]_[session_id | 0]_[object_name].zarr\n         \u2502   \u2514\u2500 [OME-NGFF spec at 100% scale, 50% and 25% scale]\n         \u2514\u2500 \ud83d\udcc1 [xx.yyy]_[user_id | tool_name]_[session_id | 0]_[name]-multilabel.zarr\n             \u2514\u2500 [OME-NGFF spec at 100% scale, 50% and 25% scale]\n</code></pre>"},{"location":"quickstart/","title":"Quick Start","text":""},{"location":"quickstart/#requirements","title":"Requirements","text":"<p>copick runs on Python 3.9 and above on Linux, MacOS, and Windows.</p> <p>It requires the following packages:</p> <ul> <li>fsspec</li> <li>pydantic</li> <li>numpy</li> <li>trimesh</li> <li>zarr</li> </ul>"},{"location":"quickstart/#installation","title":"Installation","text":"<p>copick can be installed using pip. Using the <code>all</code> extra installs necessary requirements for all tested filesystem implementations from the fsspec family (<code>local</code>, <code>s3fs</code>, <code>smb</code>, <code>sshfs</code>). A separate <code>smb</code> extra is available.</p> <pre><code>pip install \"copick[all]\"\n</code></pre> <p>Note</p> <p><code>copick&gt;=1.2.0</code> will fail to install with <code>pip~=25.1.0</code>. We recommend using <code>pip&gt;=25.2</code> or  <code>uv pip</code> when installing copick.</p>"},{"location":"quickstart/#example-dataset","title":"Example dataset","text":"<p>An example dataset can be obtained from Zenodo.</p> <p>To test with the example dataset:</p> <ol> <li>Download and unpack the example dataset</li> <li> <p>Add the location of the <code>sample_project</code>-directory in the unpacked dataset to <code>filesystem_overlay_only.json</code> <pre><code>{\n    \"name\": \"test\",\n    \"description\": \"A test project.\",\n    \"version\": \"1.0.0\",\n\n    \"pickable_objects\": [\n        {\n            \"name\": \"proteasome\",\n            \"is_particle\": true,\n            \"pdb_id\": \"3J9I\",\n            \"label\": 1,\n            \"color\": [255, 0, 0, 255],\n            \"radius\": 60,\n            \"map_threshold\": 0.0418\n        },\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"pdb_id\": \"7P6Z\",\n            \"label\": 2,\n            \"color\": [0, 255, 0, 255],\n            \"radius\": 150,\n            \"map_threshold\": 0.037\n\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"label\": 3,\n            \"color\": [0, 0, 0, 255]\n        }\n    ],\n\n    // Change this path to the location of sample_project\n    \"overlay_root\": \"local:///PATH/TO/EXTRACTED/PROJECT/\",\n\n    \"overlay_fs_args\": {\n        \"auto_mkdir\": true\n    }\n}\n</code></pre></p> </li> <li> <p>Start copick with the configuration file</p> <pre><code>from copick.impl.filesystem import CopickRootFSSpec\nroot = CopickRootFSSpec.from_file('path/to/filesystem_overlay_only.json')\n</code></pre> </li> <li> <p>Access the data using the copick API</p> <pre><code>import zarr\n\nfrom copick.impl.filesystem import CopickRootFSSpec\nroot = CopickRootFSSpec.from_file('path/to/filesystem_overlay_only.json')\n\n# Get a run by name\nrun = root.get_run(\"TS_001\")\n\n # Get a tomogram by name\ntomogram = run.get_voxel_spacing(10).get_tomogram(\"wbp\")\n\n# Access the data\ngroup = zarr.open(tomogram.zarr())\narrays = list(group.arrays())\n_, array = arrays[0]\n</code></pre> </li> </ol>"},{"location":"tools/","title":"Tools","text":"<p>There is a growing list of tools that support the copick dataset API, some of them are listed below:</p>"},{"location":"tools/#visualization","title":"Visualization","text":""},{"location":"tools/#chimerax-copick","title":"ChimeraX-copick","text":"ChimeraX-copick interface with dataset 10301, Run 14069 <p>A UCSF ChimeraX plugin for visualizing copick datasets and particle curation. The plugin is available in the ChimeraX Toolshed and can be installed from within ChimeraX.</p> <ul> <li> Repository</li> <li> Tutorial</li> <li> Website</li> <li> Docs</li> </ul>"},{"location":"tools/#cellcanvas","title":"CellCanvas","text":"<p>A Napari plugin for interactive segmentation and visualization of 3D images, supporting the copick dataset API.</p> <ul> <li> Repository</li> <li> Tutorial</li> <li> Website</li> <li> Docs</li> </ul>"},{"location":"tools/#napari-copick","title":"napari-copick","text":"<p>A Napari plugin for visualizing copick datasets and particle curation.</p> <ul> <li> Repository</li> <li> Tutorial</li> <li> Website</li> <li> Docs</li> </ul>"},{"location":"tools/#copick-live","title":"copick-live","text":"<p>CopickLive is a Dash Plotly web server for tracking progress of collaborative particle picking and curation projects using copick.</p> <ul> <li> Repository</li> <li> Tutorial</li> <li> Website</li> <li> Docs</li> </ul>"},{"location":"tools/#analysis","title":"Analysis","text":""},{"location":"tools/#deepfinder","title":"deepfinder","text":"<p>A deep learning-based tool for particle picking in cryo-EM data. It uses a U-Net architecture to detect particles in tomograms. Images can be loaded from the copick dataset API, and results can be saved back to the copick project.</p> <ul> <li> Repository</li> <li> Tutorial</li> <li> Website</li> <li> Docs</li> </ul>"},{"location":"tools/#copick-catalog","title":"copick-catalog","text":"<p>An album-catalog for manipulating copick data entities. Includes solutions to fit planes to points, manipulate meshes and more.</p> <ul> <li> Repository</li> <li> Tutorial</li> <li> Website</li> <li> Docs</li> </ul>"},{"location":"tools/#cellcanvas-catalog","title":"cellcanvas-catalog","text":"<p>An album-catalog for CellCanvas, including solutions creating and manipulating copick data.</p> <ul> <li> Repository</li> <li> Tutorial</li> <li> Website</li> <li> Docs</li> </ul>"},{"location":"api_reference/api/","title":"API Overview","text":""},{"location":"api_reference/api/#abstract-data-entities","title":"Abstract Data Entities","text":"<p>The copick API allows object-oriented access to cryoET data entities. Each data entity has a corresponding metadata model defined in pydantic. There is a set of abstract base classes that define the common interface for all data entities and the associated metadata models. The data entities are organized in a hierarchy that reflects the on-disk data model of copick and the structure of a typical cryoET dataset.</p> <p>The abstract data entities are defined in the <code>copick.models</code> module and given in the table below.</p> Data Entity Class Metadata Class Project Root CopickRoot CopickConfig ... Copick Object CopickObject PickableObject ... Run CopickRun CopickRunMeta ...... Picks CopickPicks CopickPicksFile ...... Mesh CopickMesh CopickMeshMeta ...... Segmentation CopickSegmentation CopickSegmentationMeta ...... Voxel Spacing CopickVoxelSpacing CopickVoxelSpacingMeta ......... Tomogram CopickTomogram CopickTomogramMeta ......... Features CopickFeatures CopickFeaturesMeta"},{"location":"api_reference/api/#implementations","title":"Implementations","text":"<p>There are concrete implementations of the abstract data entities that are used to access data in a copick dataset.</p> <ul> <li>Overlay: An extenstion to the abstract copick API implementation that adds methods to seamlessly overlay data from different sources.</li> <li>Filesystem: A concrete implementation that reads and writes data to any storage supported by <code>fsspec</code>.</li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickFeatures/","title":"CopickFeatures","text":""},{"location":"api_reference/base_classes/data_entity_models/CopickFeatures/#copick.models.CopickFeatures","title":"copick.models.CopickFeatures","text":"<p>Encapsulates all data pertaining to a specific feature map, i.e. the Zarr-store for the feature map.</p> <p>Attributes:</p> <ul> <li> <code>tomogram</code>               (<code>CopickTomogram</code>)           \u2013            <p>Reference to the tomogram this feature map belongs to.</p> </li> <li> <code>meta</code>               (<code>CopickFeaturesMeta</code>)           \u2013            <p>Metadata for this feature map.</p> </li> <li> <code>tomo_type</code>               (<code>str</code>)           \u2013            <p>Type of the tomogram that the features were computed on.</p> </li> <li> <code>feature_type</code>               (<code>str</code>)           \u2013            <p>Type of the features contained.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickFeatures/#copick.models.CopickFeatures.__init__","title":"__init__","text":"<pre><code>__init__(tomogram: CopickTomogram, meta: CopickFeaturesMeta)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>tomogram</code>               (<code>CopickTomogram</code>)           \u2013            <p>Reference to the tomogram this feature map belongs to.</p> </li> <li> <code>meta</code>               (<code>CopickFeaturesMeta</code>)           \u2013            <p>Metadata for this feature map.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickFeatures/#copick.models.CopickFeatures.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the feature map record.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickFeatures/#copick.models.CopickFeatures.zarr","title":"zarr","text":"<pre><code>zarr() -&gt; MutableMapping\n</code></pre> <p>Override to return the Zarr store for this feature set. Also needs to handle creating the store if it doesn't exist.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickFeatures/#copick.models.CopickFeatures.numpy","title":"numpy","text":"<pre><code>numpy(zarr_group: str = '0', slices: Tuple[slice, ...] = None) -&gt; np.ndarray\n</code></pre> <p>Returns the content of the Zarr-File for this feature map as a numpy array. Multiscale group and slices are supported.</p> <p>Parameters:</p> <ul> <li> <code>zarr_group</code>               (<code>str</code>, default:                   <code>'0'</code> )           \u2013            <p>Zarr group to access.</p> </li> <li> <code>slices</code>               (<code>Tuple[slice, ...]</code>, default:                   <code>None</code> )           \u2013            <p>Tuple of slices for the axes.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: The object as a numpy array.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickFeatures/#copick.models.CopickFeatures.set_region","title":"set_region","text":"<pre><code>set_region(data: ndarray, zarr_group: str = '0', slices: Tuple[slice, ...] = None) -&gt; None\n</code></pre> <p>Set the content of the Zarr-File for this feature map from a numpy array. Multiscale group and slices are supported.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>ndarray</code>)           \u2013            <p>The data to set.</p> </li> <li> <code>zarr_group</code>               (<code>str</code>, default:                   <code>'0'</code> )           \u2013            <p>Zarr group to access.</p> </li> <li> <code>slices</code>               (<code>Tuple[slice, ...]</code>, default:                   <code>None</code> )           \u2013            <p>Tuple of slices for the axes.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickMesh/","title":"CopickMesh","text":""},{"location":"api_reference/base_classes/data_entity_models/CopickMesh/#copick.models.CopickMesh","title":"copick.models.CopickMesh","text":"<p>Encapsulates all data pertaining to a specific mesh. This includes the mesh (<code>trimesh.parent.Geometry</code>) and other metadata.</p> <p>Attributes:</p> <ul> <li> <code>run</code>               (<code>CopickRun</code>)           \u2013            <p>Reference to the run this mesh belongs to.</p> </li> <li> <code>meta</code>               (<code>CopickMeshMeta</code>)           \u2013            <p>Metadata for this mesh.</p> </li> <li> <code>mesh</code>               (<code>Geometry</code>)           \u2013            <p>Mesh for this pick. Either populated from storage or lazily loaded when <code>CopickMesh.mesh</code> is accessed for the first time.</p> </li> <li> <code>from_tool</code>               (<code>bool</code>)           \u2013            <p>Flag to indicate if this pick was generated by a tool.</p> </li> <li> <code>from_user</code>               (<code>bool</code>)           \u2013            <p>Flag to indicate if this pick was generated by a user.</p> </li> <li> <code>pickable_object_name</code>               (<code>str</code>)           \u2013            <p>Pickable object name from <code>CopickConfig.pickable_objects[...].name</code></p> </li> <li> <code>user_id</code>               (<code>str</code>)           \u2013            <p>Unique identifier for the user or tool name.</p> </li> <li> <code>session_id</code>               (<code>str</code>)           \u2013            <p>Unique identifier for the pick session</p> </li> <li> <code>color</code>           \u2013            <p>Color of the pickable object this pick belongs to.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickMesh/#copick.models.CopickMesh.load","title":"load","text":"<pre><code>load() -&gt; Geometry\n</code></pre> <p>Load the mesh from storage.</p> <p>Returns:</p> <ul> <li> <code>Geometry</code>           \u2013            <p>trimesh.parent.Geometry: The loaded mesh.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickMesh/#copick.models.CopickMesh.store","title":"store","text":"<pre><code>store()\n</code></pre> <p>Store the mesh.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickMesh/#copick.models.CopickMesh.refresh","title":"refresh","text":"<pre><code>refresh() -&gt; None\n</code></pre> <p>Refresh <code>CopickMesh.mesh</code> from storage.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickMesh/#copick.models.CopickMesh.delete","title":"delete","text":"<pre><code>delete() -&gt; None\n</code></pre> <p>Delete the mesh record.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickObject/","title":"CopickObject","text":""},{"location":"api_reference/base_classes/data_entity_models/CopickObject/#copick.models.CopickObject","title":"copick.models.CopickObject","text":"<p>Object that can be picked or segmented in a tomogram.</p> <p>Attributes:</p> <ul> <li> <code>meta</code>               (<code>PickableObject</code>)           \u2013            <p>Metadata for this object.</p> </li> <li> <code>root</code>               (<code>CopickRoot</code>)           \u2013            <p>Reference to the root this object belongs to.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name of the object.</p> </li> <li> <code>is_particle</code>               (<code>bool</code>)           \u2013            <p>Whether this object should be represented by points (True) or segmentation masks (False).</p> </li> <li> <code>label</code>               (<code>Union[int, None]</code>)           \u2013            <p>Numeric label/id for the object, as used in multilabel segmentation masks. Must be unique.</p> </li> <li> <code>color</code>               (<code>Union[Tuple[int, int, int, int], None]</code>)           \u2013            <p>RGBA color for the object.</p> </li> <li> <code>emdb_id</code>               (<code>Union[str, None]</code>)           \u2013            <p>EMDB ID for the object.</p> </li> <li> <code>pdb_id</code>               (<code>Union[str, None]</code>)           \u2013            <p>PDB ID for the object.</p> </li> <li> <code>map_threshold</code>               (<code>Union[float, None]</code>)           \u2013            <p>Threshold to apply to the map when rendering the isosurface.</p> </li> <li> <code>radius</code>               (<code>Union[float, None]</code>)           \u2013            <p>Radius of the particle, when displaying as a sphere.</p> </li> <li> <code>metadata</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>Additional metadata for the object (user-defined contents).</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickObject/#copick.models.CopickObject.__init__","title":"__init__","text":"<pre><code>__init__(root: CopickRoot, meta: PickableObject)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>root(CopickRoot)</code>           \u2013            <p>The copick project root.</p> </li> <li> <code>meta</code>               (<code>PickableObject</code>)           \u2013            <p>The metadata for this object.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickObject/#copick.models.CopickObject.zarr","title":"zarr","text":"<pre><code>zarr() -&gt; Union[None, MutableMapping]\n</code></pre> <p>Override this method to return a zarr store for this object. Should return None if CopickObject.is_particle is False or there is no associated map.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickObject/#copick.models.CopickObject.numpy","title":"numpy","text":"<pre><code>numpy(zarr_group: str = '0', x: slice = slice(None, None), y: slice = slice(None, None), z: slice = slice(None, None)) -&gt; Union[None, np.ndarray]\n</code></pre> <p>Returns the content of the Zarr-File for this object as a numpy array. Multiscale group and slices are supported.</p> <p>Parameters:</p> <ul> <li> <code>zarr_group</code>               (<code>str</code>, default:                   <code>'0'</code> )           \u2013            <p>Zarr group to access.</p> </li> <li> <code>x</code>               (<code>slice</code>, default:                   <code>slice(None, None)</code> )           \u2013            <p>Slice for the x-axis.</p> </li> <li> <code>y</code>               (<code>slice</code>, default:                   <code>slice(None, None)</code> )           \u2013            <p>Slice for the y-axis.</p> </li> <li> <code>z</code>               (<code>slice</code>, default:                   <code>slice(None, None)</code> )           \u2013            <p>Slice for the z-axis.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Union[None, ndarray]</code>           \u2013            <p>np.ndarray: The object as a numpy array.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickObject/#copick.models.CopickObject.from_numpy","title":"from_numpy","text":"<pre><code>from_numpy(data: ndarray, voxel_size: float, dtype: Optional[dtype] = np.float32) -&gt; None\n</code></pre> <p>Set the object from a numpy array.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>ndarray</code>)           \u2013            <p>The segmentation as a numpy array.</p> </li> <li> <code>voxel_size</code>               (<code>float</code>)           \u2013            <p>Voxel size of the object.</p> </li> <li> <code>dtype</code>               (<code>Optional[dtype]</code>, default:                   <code>float32</code> )           \u2013            <p>Data type of the segmentation. Default is <code>np.float32</code>.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickObject/#copick.models.CopickObject.set_region","title":"set_region","text":"<pre><code>set_region(data: ndarray, zarr_group: str = '0', x: slice = slice(None, None), y: slice = slice(None, None), z: slice = slice(None, None)) -&gt; None\n</code></pre> <p>Set a region of the object from a numpy array.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>ndarray</code>)           \u2013            <p>The object's subregion as a numpy array.</p> </li> <li> <code>zarr_group</code>               (<code>str</code>, default:                   <code>'0'</code> )           \u2013            <p>Zarr group to access.</p> </li> <li> <code>x</code>               (<code>slice</code>, default:                   <code>slice(None, None)</code> )           \u2013            <p>Slice for the x-axis.</p> </li> <li> <code>y</code>               (<code>slice</code>, default:                   <code>slice(None, None)</code> )           \u2013            <p>Slice for the y-axis.</p> </li> <li> <code>z</code>               (<code>slice</code>, default:                   <code>slice(None, None)</code> )           \u2013            <p>Slice for the z-axis.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickObject/#copick.models.CopickObject.delete","title":"delete","text":"<pre><code>delete() -&gt; None\n</code></pre> <p>Delete the object.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickPicks/","title":"CopickPicks","text":""},{"location":"api_reference/base_classes/data_entity_models/CopickPicks/#copick.models.CopickPicks","title":"copick.models.CopickPicks","text":"<p>Encapsulates all data pertaining to a specific set of picked points. This includes the locations, orientations, and other metadata for the set of points.</p> <p>Attributes:</p> <ul> <li> <code>run</code>               (<code>CopickRun</code>)           \u2013            <p>Reference to the run this pick belongs to.</p> </li> <li> <code>meta</code>               (<code>CopickPicksFile</code>)           \u2013            <p>Metadata for this pick.</p> </li> <li> <code>points</code>               (<code>List[CopickPoint]</code>)           \u2013            <p>Points for this pick. Either populated from storage or lazily loaded when <code>CopickPicks.points</code> is accessed for the first time.</p> </li> <li> <code>from_tool</code>               (<code>bool</code>)           \u2013            <p>Flag to indicate if this pick was generated by a tool.</p> </li> <li> <code>pickable_object_name</code>               (<code>str</code>)           \u2013            <p>Pickable object name from <code>CopickConfig.pickable_objects[...].name</code></p> </li> <li> <code>user_id</code>               (<code>str</code>)           \u2013            <p>Unique identifier for the user or tool name.</p> </li> <li> <code>session_id</code>               (<code>str</code>)           \u2013            <p>Unique identifier for the pick session</p> </li> <li> <code>trust_orientation</code>               (<code>bool</code>)           \u2013            <p>Flag to indicate if the angles are known for this pick or should be ignored.</p> </li> <li> <code>color</code>               (<code>Union[Tuple[int, int, int, int], None]</code>)           \u2013            <p>Color of the pickable object this pick belongs to.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickPicks/#copick.models.CopickPicks.__init__","title":"__init__","text":"<pre><code>__init__(run: CopickRun, file: CopickPicksFile)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>run</code>               (<code>CopickRun</code>)           \u2013            <p>Reference to the run this pick belongs to.</p> </li> <li> <code>file</code>               (<code>CopickPicksFile</code>)           \u2013            <p>Metadata for this set of points.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickPicks/#copick.models.CopickPicks.load","title":"load","text":"<pre><code>load() -&gt; CopickPicksFile\n</code></pre> <p>Load the points from storage.</p> <p>Returns:</p> <ul> <li> <code>CopickPicksFile</code> (              <code>CopickPicksFile</code> )          \u2013            <p>The loaded points.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickPicks/#copick.models.CopickPicks.store","title":"store","text":"<pre><code>store()\n</code></pre> <p>Store the points (set using <code>CopickPicks.points</code> property).</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickPicks/#copick.models.CopickPicks.refresh","title":"refresh","text":"<pre><code>refresh() -&gt; None\n</code></pre> <p>Refresh the points from storage.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickPicks/#copick.models.CopickPicks.delete","title":"delete","text":"<pre><code>delete() -&gt; None\n</code></pre> <p>Delete the pick record.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickPicks/#copick.models.CopickPicks.numpy","title":"numpy","text":"<pre><code>numpy() -&gt; Tuple[np.ndarray, np.ndarray]\n</code></pre> <p>Return the points as a [N, 3] numpy array (N, [x, y, z]) and the transforms as a [N, 4, 4] numpy array. Format of the transforms is:         <pre><code>[[rxx, rxy, rxz, tx],\n [ryx, ryy, ryz, ty],\n [rzx, rzy, rzz, tz],\n [  0,   0,   0,  1]]\n</code></pre></p> <p>Returns:</p> <ul> <li> <code>Tuple[ndarray, ndarray]</code>           \u2013            <p>Tuple[np.ndarray, np.ndarray]: The picks and transforms as numpy arrays.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickPicks/#copick.models.CopickPicks.from_numpy","title":"from_numpy","text":"<pre><code>from_numpy(positions: ndarray, transforms: Optional[ndarray] = None) -&gt; None\n</code></pre> <p>Set the points and transforms from numpy arrays.</p> <p>Parameters:</p> <ul> <li> <code>positions</code>               (<code>ndarray</code>)           \u2013            <p>[N, 3] numpy array of positions (N, [x, y, z]).</p> </li> <li> <code>transforms</code>               (<code>Optional[ndarray]</code>, default:                   <code>None</code> )           \u2013            <p>[N, 4, 4] numpy array of orientations. If None, transforms will be set to the identity matrix. Format of the transforms is: <pre><code>[[rxx, rxy, rxz, tx],\n [ryx, ryy, ryz, ty],\n [rzx, rzy, rzz, tz],\n [  0,   0,   0,  1]]\n</code></pre></p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRoot/","title":"CopickRoot","text":""},{"location":"api_reference/base_classes/data_entity_models/CopickRoot/#copick.models.CopickRoot","title":"copick.models.CopickRoot","text":"<p>Root of a copick project. Contains references to the runs and pickable objects.</p> <p>Attributes:</p> <ul> <li> <code>config</code>               (<code>CopickConfig</code>)           \u2013            <p>Configuration of the copick project.</p> </li> <li> <code>user_id</code>               (<code>str</code>)           \u2013            <p>Unique identifier for the user.</p> </li> <li> <code>session_id</code>               (<code>str</code>)           \u2013            <p>Unique identifier for the session.</p> </li> <li> <code>runs</code>               (<code>List[CopickRun]</code>)           \u2013            <p>References to the runs for this project. Lazy loaded upon access.</p> </li> <li> <code>pickable_objects</code>               (<code>List[CopickObject]</code>)           \u2013            <p>References to the pickable objects for this project.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRoot/#copick.models.CopickRoot.__init__","title":"__init__","text":"<pre><code>__init__(config: CopickConfig)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>CopickConfig</code>)           \u2013            <p>Configuration of the copick project.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRoot/#copick.models.CopickRoot.query","title":"query","text":"<pre><code>query() -&gt; List[CopickRun]\n</code></pre> <p>Override this method to query for runs.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickRoot/#copick.models.CopickRoot.get_run","title":"get_run","text":"<pre><code>get_run(name: str, **kwargs) -&gt; Union[CopickRun, None]\n</code></pre> <p>Get run by name.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name of the run to retrieve.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional keyword arguments for the run metadata.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CopickRun</code> (              <code>Union[CopickRun, None]</code> )          \u2013            <p>The run with the given name, or None if not found.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRoot/#copick.models.CopickRoot.get_object","title":"get_object","text":"<pre><code>get_object(name: str) -&gt; Union[CopickObject, None]\n</code></pre> <p>Get object by name.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name of the object to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CopickObject</code> (              <code>Union[CopickObject, None]</code> )          \u2013            <p>The object with the given name, or None if not found.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRoot/#copick.models.CopickRoot.refresh","title":"refresh","text":"<pre><code>refresh() -&gt; None\n</code></pre> <p>Refresh the list of runs.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickRoot/#copick.models.CopickRoot.save_config","title":"save_config","text":"<pre><code>save_config(config_path: str) -&gt; None\n</code></pre> <p>Save the configuration to a JSON file.</p> <p>Parameters:</p> <ul> <li> <code>config_path</code>               (<code>str</code>)           \u2013            <p>Path to the configuration file to save.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRoot/#copick.models.CopickRoot.new_run","title":"new_run","text":"<pre><code>new_run(name: str, exist_ok: bool = False, **kwargs) -&gt; CopickRun\n</code></pre> <p>Create a new run.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name of the run to create.</p> </li> <li> <code>exist_ok</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to raise an error if the run already exists.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional keyword arguments for the run metadata.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CopickRun</code> (              <code>CopickRun</code> )          \u2013            <p>The newly created run.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If a run with the given name already exists.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRoot/#copick.models.CopickRoot.delete_run","title":"delete_run","text":"<pre><code>delete_run(name: str) -&gt; None\n</code></pre> <p>Delete a run by name.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name of the run to delete.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRoot/#copick.models.CopickRoot.new_object","title":"new_object","text":"<pre><code>new_object(name: str, is_particle: bool, label: Optional[int] = None, color: Optional[Tuple[int, int, int, int]] = None, emdb_id: Optional[str] = None, pdb_id: Optional[str] = None, identifier: Optional[str] = None, map_threshold: Optional[float] = None, radius: Optional[float] = None, metadata: Optional[Dict[str, Any]] = None, exist_ok: bool = False) -&gt; CopickObject\n</code></pre> <p>Create a new pickable object and add it to the configuration.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name of the object.</p> </li> <li> <code>is_particle</code>               (<code>bool</code>)           \u2013            <p>Whether this object should be represented by points (True) or segmentation masks (False).</p> </li> <li> <code>label</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Numeric label/id for the object. If None, will use the next available label.</p> </li> <li> <code>color</code>               (<code>Optional[Tuple[int, int, int, int]]</code>, default:                   <code>None</code> )           \u2013            <p>RGBA color for the object. If None, will use a default color.</p> </li> <li> <code>emdb_id</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>EMDB ID for the object.</p> </li> <li> <code>pdb_id</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>PDB ID for the object.</p> </li> <li> <code>identifier</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Identifier for the object (e.g. Gene Ontology ID or UniProtKB accession).</p> </li> <li> <code>map_threshold</code>               (<code>Optional[float]</code>, default:                   <code>None</code> )           \u2013            <p>Threshold to apply to the map when rendering the isosurface.</p> </li> <li> <code>radius</code>               (<code>Optional[float]</code>, default:                   <code>None</code> )           \u2013            <p>Radius of the particle, when displaying as a sphere.</p> </li> <li> <code>metadata</code>               (<code>Optional[Dict[str, Any]]</code>, default:                   <code>None</code> )           \u2013            <p>Additional metadata for the object (user-defined contents).</p> </li> <li> <code>exist_ok</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether existing objects with the same name should be overwritten..</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CopickObject</code> (              <code>CopickObject</code> )          \u2013            <p>The newly created object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If an object with the given name already exists and exist_ok is False.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/","title":"CopickRun","text":""},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun","title":"copick.models.CopickRun","text":"<p>Encapsulates all data pertaining to a physical location on a sample (i.e. typically one tilt series and the associated tomograms). This includes voxel spacings (of the reconstructed tomograms), picks, meshes, and segmentations.</p> <p>Attributes:</p> <ul> <li> <code>meta</code>               (<code>CopickRunMeta</code>)           \u2013            <p>Metadata for this run.</p> </li> <li> <code>root</code>               (<code>CopickRoot</code>)           \u2013            <p>Reference to the root project this run belongs to.</p> </li> <li> <code>voxel_spacings</code>               (<code>List[CopickVoxelSpacing]</code>)           \u2013            <p>Voxel spacings for this run. Either populated from config or lazily loaded when CopickRun.voxel_spacings is accessed for the first time.</p> </li> <li> <code>picks</code>               (<code>List[CopickPicks]</code>)           \u2013            <p>Picks for this run. Either populated from config or lazily loaded when CopickRun.picks is accessed for the first time.</p> </li> <li> <code>meshes</code>               (<code>List[CopickMesh]</code>)           \u2013            <p>Meshes for this run. Either populated from config or lazily loaded when CopickRun.meshes is accessed for the first time.</p> </li> <li> <code>segmentations</code>               (<code>List[CopickSegmentation]</code>)           \u2013            <p>Segmentations for this run. Either populated from config or lazily loaded when CopickRun.segmentations is accessed for the first time.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.query_voxelspacings","title":"query_voxelspacings","text":"<pre><code>query_voxelspacings() -&gt; List[CopickVoxelSpacing]\n</code></pre> <p>Override this method to query for voxel_spacings.</p> <p>Returns:</p> <ul> <li> <code>List[CopickVoxelSpacing]</code>           \u2013            <p>List[CopickVoxelSpacing]: List of voxel spacings for this run.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.query_picks","title":"query_picks","text":"<pre><code>query_picks() -&gt; List[CopickPicks]\n</code></pre> <p>Override this method to query for picks.</p> <p>Returns:</p> <ul> <li> <code>List[CopickPicks]</code>           \u2013            <p>List[CopickPicks]: List of picks for this run.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.query_meshes","title":"query_meshes","text":"<pre><code>query_meshes() -&gt; List[CopickMesh]\n</code></pre> <p>Override this method to query for meshes.</p> <p>Returns:</p> <ul> <li> <code>List[CopickMesh]</code>           \u2013            <p>List[CopickMesh]: List of meshes for this run.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.query_segmentations","title":"query_segmentations","text":"<pre><code>query_segmentations() -&gt; List[CopickSegmentation]\n</code></pre> <p>Override this method to query for segmentations.</p> <p>Returns:</p> <ul> <li> <code>List[CopickSegmentation]</code>           \u2013            <p>List[CopickSegmentation]: List of segmentations for this run.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.get_voxel_spacing","title":"get_voxel_spacing","text":"<pre><code>get_voxel_spacing(voxel_size: float, **kwargs) -&gt; Union[CopickVoxelSpacing, None]\n</code></pre> <p>Get voxel spacing object by voxel size value.</p> <p>Parameters:</p> <ul> <li> <code>voxel_size</code>               (<code>float</code>)           \u2013            <p>Voxel size value to search for.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional keyword arguments for the voxel spacing metadata.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CopickVoxelSpacing</code> (              <code>Union[CopickVoxelSpacing, None]</code> )          \u2013            <p>The voxel spacing object with the given voxel size value, or None if not found.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.user_picks","title":"user_picks","text":"<pre><code>user_picks() -&gt; List[CopickPicks]\n</code></pre> <p>Get all user generated picks (i.e. picks that have <code>CopickPicks.session_id != 0</code>).</p> <p>Returns:</p> <ul> <li> <code>List[CopickPicks]</code>           \u2013            <p>List[CopickPicks]: List of user-generated picks.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.tool_picks","title":"tool_picks","text":"<pre><code>tool_picks() -&gt; List[CopickPicks]\n</code></pre> <p>Get all tool generated picks (i.e. picks that have <code>CopickPicks.session_id == 0</code>).</p> <p>Returns:</p> <ul> <li> <code>List[CopickPicks]</code>           \u2013            <p>List[CopickPicks]: List of tool-generated picks.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.get_picks","title":"get_picks","text":"<pre><code>get_picks(object_name: Union[str, Iterable[str]] = None, user_id: Union[str, Iterable[str]] = None, session_id: Union[str, Iterable[str]] = None) -&gt; List[CopickPicks]\n</code></pre> <p>Get picks by name, user_id or session_id (or combinations).</p> <p>Parameters:</p> <ul> <li> <code>object_name</code>               (<code>Union[str, Iterable[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Name of the object to search for.</p> </li> <li> <code>user_id</code>               (<code>Union[str, Iterable[str]]</code>, default:                   <code>None</code> )           \u2013            <p>User ID to search for.</p> </li> <li> <code>session_id</code>               (<code>Union[str, Iterable[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Session ID to search for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[CopickPicks]</code>           \u2013            <p>List[CopickPicks]: List of picks that match the search criteria.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.user_meshes","title":"user_meshes","text":"<pre><code>user_meshes() -&gt; List[CopickMesh]\n</code></pre> <p>Get all user generated meshes (i.e. meshes that have <code>CopickMesh.session_id != 0</code>).</p> <p>Returns:</p> <ul> <li> <code>List[CopickMesh]</code>           \u2013            <p>List[CopickMesh]: List of user-generated meshes.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.tool_meshes","title":"tool_meshes","text":"<pre><code>tool_meshes() -&gt; List[CopickMesh]\n</code></pre> <p>Get all tool generated meshes (i.e. meshes that have <code>CopickMesh.session_id == 0</code>).</p> <p>Returns:</p> <ul> <li> <code>List[CopickMesh]</code>           \u2013            <p>List[CopickMesh]: List of tool-generated meshes.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.get_meshes","title":"get_meshes","text":"<pre><code>get_meshes(object_name: Union[str, Iterable[str]] = None, user_id: Union[str, Iterable[str]] = None, session_id: Union[str, Iterable[str]] = None) -&gt; List[CopickMesh]\n</code></pre> <p>Get meshes by name, user_id or session_id (or combinations).</p> <p>Parameters:</p> <ul> <li> <code>object_name</code>               (<code>Union[str, Iterable[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Name of the object to search for.</p> </li> <li> <code>user_id</code>               (<code>Union[str, Iterable[str]]</code>, default:                   <code>None</code> )           \u2013            <p>User ID to search for.</p> </li> <li> <code>session_id</code>               (<code>Union[str, Iterable[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Session ID to search for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[CopickMesh]</code>           \u2013            <p>List[CopickMesh]: List of meshes that match the search criteria.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.user_segmentations","title":"user_segmentations","text":"<pre><code>user_segmentations() -&gt; List[CopickSegmentation]\n</code></pre> <p>Get all user generated segmentations (i.e. segmentations that have <code>CopickSegmentation.session_id != 0</code>).</p> <p>Returns:</p> <ul> <li> <code>List[CopickSegmentation]</code>           \u2013            <p>List[CopickSegmentation]: List of user-generated segmentations.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.tool_segmentations","title":"tool_segmentations","text":"<pre><code>tool_segmentations() -&gt; List[CopickSegmentation]\n</code></pre> <p>Get all tool generated segmentations (i.e. segmentations that have <code>CopickSegmentation.session_id == 0</code>).</p> <p>Returns:</p> <ul> <li> <code>List[CopickSegmentation]</code>           \u2013            <p>List[CopickSegmentation]: List of tool-generated segmentations.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.get_segmentations","title":"get_segmentations","text":"<pre><code>get_segmentations(user_id: Union[str, Iterable[str]] = None, session_id: Union[str, Iterable[str]] = None, is_multilabel: bool = None, name: Union[str, Iterable[str]] = None, voxel_size: Union[float, Iterable[float]] = None) -&gt; List[CopickSegmentation]\n</code></pre> <p>Get segmentations by user_id, session_id, name, type or voxel_size (or combinations).</p> <p>Parameters:</p> <ul> <li> <code>user_id</code>               (<code>Union[str, Iterable[str]]</code>, default:                   <code>None</code> )           \u2013            <p>User ID to search for.</p> </li> <li> <code>session_id</code>               (<code>Union[str, Iterable[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Session ID to search for.</p> </li> <li> <code>is_multilabel</code>               (<code>bool</code>, default:                   <code>None</code> )           \u2013            <p>Whether the segmentation is multilabel or not.</p> </li> <li> <code>name</code>               (<code>Union[str, Iterable[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Name of the segmentation to search for.</p> </li> <li> <code>voxel_size</code>               (<code>Union[float, Iterable[float]]</code>, default:                   <code>None</code> )           \u2013            <p>Voxel size to search for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[CopickSegmentation]</code>           \u2013            <p>List[CopickSegmentation]: List of segmentations that match the search criteria.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.new_voxel_spacing","title":"new_voxel_spacing","text":"<pre><code>new_voxel_spacing(voxel_size: float, exist_ok: bool = False, **kwargs) -&gt; CopickVoxelSpacing\n</code></pre> <p>Create a new voxel spacing object.</p> <p>Parameters:</p> <ul> <li> <code>voxel_size</code>               (<code>float</code>)           \u2013            <p>Voxel size value for the contained tomograms.</p> </li> <li> <code>exist_ok</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to raise an error if the voxel spacing already exists.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional keyword arguments for the voxel spacing metadata.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CopickVoxelSpacing</code> (              <code>CopickVoxelSpacing</code> )          \u2013            <p>The newly created voxel spacing object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If a voxel spacing with the given voxel size already exists for this run.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.new_picks","title":"new_picks","text":"<pre><code>new_picks(object_name: str, session_id: str, user_id: Optional[str] = None, exist_ok: bool = False) -&gt; CopickPicks\n</code></pre> <p>Create a new picks object.</p> <p>Parameters:</p> <ul> <li> <code>object_name</code>               (<code>str</code>)           \u2013            <p>Name of the object to pick.</p> </li> <li> <code>session_id</code>               (<code>str</code>)           \u2013            <p>Session ID for the picks.</p> </li> <li> <code>user_id</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>User ID for the picks.</p> </li> <li> <code>exist_ok</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to raise an error if the picks already exists.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CopickPicks</code> (              <code>CopickPicks</code> )          \u2013            <p>The newly created picks object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If picks for the given object name, session ID and user ID already exist, if the object name is not found in the pickable objects, or if the user ID is not set in the root config or supplied.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.new_mesh","title":"new_mesh","text":"<pre><code>new_mesh(object_name: str, session_id: str, user_id: Optional[str] = None, exist_ok: bool = False, **kwargs) -&gt; CopickMesh\n</code></pre> <p>Create a new mesh object.</p> <p>Parameters:</p> <ul> <li> <code>object_name</code>               (<code>str</code>)           \u2013            <p>Name of the object to mesh.</p> </li> <li> <code>session_id</code>               (<code>str</code>)           \u2013            <p>Session ID for the mesh.</p> </li> <li> <code>user_id</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>User ID for the mesh.</p> </li> <li> <code>exist_ok</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to raise an error if the mesh already exists.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional keyword arguments for the mesh metadata.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CopickMesh</code> (              <code>CopickMesh</code> )          \u2013            <p>The newly created mesh object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If a mesh for the given object name, session ID and user ID already exist, if the object name is not found in the pickable objects, or if the user ID is not set in the root config or supplied.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.new_segmentation","title":"new_segmentation","text":"<pre><code>new_segmentation(voxel_size: float, name: str, session_id: str, is_multilabel: bool, user_id: Optional[str] = None, exist_ok: bool = False, **kwargs) -&gt; CopickSegmentation\n</code></pre> <p>Create a new segmentation object.</p> <p>Parameters:</p> <ul> <li> <code>voxel_size</code>               (<code>float</code>)           \u2013            <p>Voxel size for the segmentation.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name of the segmentation.</p> </li> <li> <code>session_id</code>               (<code>str</code>)           \u2013            <p>Session ID for the segmentation.</p> </li> <li> <code>is_multilabel</code>               (<code>bool</code>)           \u2013            <p>Whether the segmentation is multilabel or not.</p> </li> <li> <code>user_id</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>User ID for the segmentation.</p> </li> <li> <code>exist_ok</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to raise an error if the segmentation already exists.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional keyword arguments for the segmentation metadata.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CopickSegmentation</code> (              <code>CopickSegmentation</code> )          \u2013            <p>The newly created segmentation object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If a segmentation for the given name, session ID, user ID, voxel size and multilabel flag already exist, if the object name is not found in the pickable objects, if the voxel size is not found in the voxel spacings, or if the user ID is not set in the root config or supplied.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.refresh_voxel_spacings","title":"refresh_voxel_spacings","text":"<pre><code>refresh_voxel_spacings() -&gt; None\n</code></pre> <p>Refresh the voxel spacings.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.refresh_picks","title":"refresh_picks","text":"<pre><code>refresh_picks() -&gt; None\n</code></pre> <p>Refresh the picks.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.refresh_meshes","title":"refresh_meshes","text":"<pre><code>refresh_meshes() -&gt; None\n</code></pre> <p>Refresh the meshes.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.refresh_segmentations","title":"refresh_segmentations","text":"<pre><code>refresh_segmentations() -&gt; None\n</code></pre> <p>Refresh the segmentations.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.refresh","title":"refresh","text":"<pre><code>refresh() -&gt; None\n</code></pre> <p>Refresh all child types.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.ensure","title":"ensure","text":"<pre><code>ensure(create: bool = False) -&gt; bool\n</code></pre> <p>Check if the run record exists, optionally create it if it does not.</p> <p>Parameters:</p> <ul> <li> <code>create</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to create the run record if it does not exist.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the run record exists, False otherwise.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.delete","title":"delete","text":"<pre><code>delete() -&gt; None\n</code></pre> <p>Delete the run record.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.delete_voxel_spacings","title":"delete_voxel_spacings","text":"<pre><code>delete_voxel_spacings(voxel_size: float = None) -&gt; None\n</code></pre> <p>Delete a voxel spacing by voxel size.</p> <p>Parameters:</p> <ul> <li> <code>voxel_size</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>Voxel size to delete.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.delete_picks","title":"delete_picks","text":"<pre><code>delete_picks(object_name: str = None, user_id: str = None, session_id: str = None) -&gt; None\n</code></pre> <p>Delete picks by name, user_id or session_id (or combinations).</p> <p>Parameters:</p> <ul> <li> <code>object_name</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Name of the object to delete.</p> </li> <li> <code>user_id</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>User ID to delete.</p> </li> <li> <code>session_id</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Session ID to delete.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.delete_meshes","title":"delete_meshes","text":"<pre><code>delete_meshes(object_name: str = None, user_id: str = None, session_id: str = None) -&gt; None\n</code></pre> <p>Delete meshes by name, user_id or session_id (or combinations).</p> <p>Parameters:</p> <ul> <li> <code>object_name</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Name of the object to delete.</p> </li> <li> <code>user_id</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>User ID to delete.</p> </li> <li> <code>session_id</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Session ID to delete.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.delete_segmentations","title":"delete_segmentations","text":"<pre><code>delete_segmentations(user_id: str = None, session_id: str = None, is_multilabel: bool = None, name: str = None, voxel_size: float = None) -&gt; None\n</code></pre> <p>Delete segmentation by name, user_id or session_id (or combinations).</p> <p>Parameters:</p> <ul> <li> <code>user_id</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>User ID to delete.</p> </li> <li> <code>session_id</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Session ID to delete.</p> </li> <li> <code>is_multilabel</code>               (<code>bool</code>, default:                   <code>None</code> )           \u2013            <p>Whether the segmentation is multilabel or not.</p> </li> <li> <code>name</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Name of the segmentation to delete.</p> </li> <li> <code>voxel_size</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>Voxel size to delete.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickSegmentation/","title":"CopickSegmentation","text":""},{"location":"api_reference/base_classes/data_entity_models/CopickSegmentation/#copick.models.CopickSegmentation","title":"copick.models.CopickSegmentation","text":"<p>Encapsulates all data pertaining to a specific segmentation. This includes the Zarr-store for the segmentation and other metadata.</p> <p>Attributes:</p> <ul> <li> <code>run</code>               (<code>CopickRun</code>)           \u2013            <p>Reference to the run this segmentation belongs to.</p> </li> <li> <code>meta</code>               (<code>CopickSegmentationMeta</code>)           \u2013            <p>Metadata for this segmentation.</p> </li> <li> <code>zarr</code>               (<code>MutableMapping</code>)           \u2013            <p>Zarr store for this segmentation. Either populated from storage or lazily loaded when <code>CopickSegmentation.zarr</code> is accessed for the first time.</p> </li> <li> <code>from_tool</code>               (<code>bool</code>)           \u2013            <p>Flag to indicate if this segmentation was generated by a tool.</p> </li> <li> <code>from_user</code>               (<code>bool</code>)           \u2013            <p>Flag to indicate if this segmentation was generated by a user.</p> </li> <li> <code>user_id</code>               (<code>str</code>)           \u2013            <p>Unique identifier for the user or tool name.</p> </li> <li> <code>session_id</code>               (<code>str</code>)           \u2013            <p>Unique identifier for the segmentation session</p> </li> <li> <code>is_multilabel</code>               (<code>bool</code>)           \u2013            <p>Flag to indicate if this is a multilabel segmentation. If False, it is a single label segmentation.</p> </li> <li> <code>voxel_size</code>               (<code>float</code>)           \u2013            <p>Voxel size of the tomogram this segmentation belongs to.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Pickable Object name or multilabel name of the segmentation.</p> </li> <li> <code>color</code>           \u2013            <p>Color of the pickable object this segmentation belongs to.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickSegmentation/#copick.models.CopickSegmentation.__init__","title":"__init__","text":"<pre><code>__init__(run: CopickRun, meta: CopickSegmentationMeta)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>run</code>               (<code>CopickRun</code>)           \u2013            <p>Reference to the run this segmentation belongs to.</p> </li> <li> <code>meta</code>               (<code>CopickSegmentationMeta</code>)           \u2013            <p>Metadata for this segmentation.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickSegmentation/#copick.models.CopickSegmentation.delete","title":"delete","text":"<pre><code>delete() -&gt; None\n</code></pre> <p>Delete the segmentation record.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickSegmentation/#copick.models.CopickSegmentation.zarr","title":"zarr","text":"<pre><code>zarr() -&gt; MutableMapping\n</code></pre> <p>Override to return the Zarr store for this segmentation. Also needs to handle creating the store if it doesn't exist.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickSegmentation/#copick.models.CopickSegmentation.numpy","title":"numpy","text":"<pre><code>numpy(zarr_group: str = '0', x: slice = slice(None, None), y: slice = slice(None, None), z: slice = slice(None, None)) -&gt; np.ndarray\n</code></pre> <p>Returns the content of the Zarr-File for this segmentation as a numpy array. Multiscale group and slices are supported.</p> <p>Parameters:</p> <ul> <li> <code>zarr_group</code>               (<code>str</code>, default:                   <code>'0'</code> )           \u2013            <p>Zarr group to access.</p> </li> <li> <code>x</code>               (<code>slice</code>, default:                   <code>slice(None, None)</code> )           \u2013            <p>Slice for the x-axis.</p> </li> <li> <code>y</code>               (<code>slice</code>, default:                   <code>slice(None, None)</code> )           \u2013            <p>Slice for the y-axis.</p> </li> <li> <code>z</code>               (<code>slice</code>, default:                   <code>slice(None, None)</code> )           \u2013            <p>Slice for the z-axis.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: The segmentation as a numpy array.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickSegmentation/#copick.models.CopickSegmentation.from_numpy","title":"from_numpy","text":"<pre><code>from_numpy(data: ndarray, levels: int = 1, dtype: Optional[dtype] = np.uint8) -&gt; None\n</code></pre> <p>Set the segmentation from a numpy array and compute multiscale pyramid. By default, no pyramid is computed for segmentations.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>ndarray</code>)           \u2013            <p>The segmentation as a numpy array.</p> </li> <li> <code>levels</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Number of levels in the multiscale pyramid.</p> </li> <li> <code>dtype</code>               (<code>Optional[dtype]</code>, default:                   <code>uint8</code> )           \u2013            <p>Data type of the segmentation. Default is <code>np.uint8</code>.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickSegmentation/#copick.models.CopickSegmentation.set_region","title":"set_region","text":"<pre><code>set_region(data: ndarray, zarr_group: str = '0', x: slice = slice(None, None), y: slice = slice(None, None), z: slice = slice(None, None)) -&gt; None\n</code></pre> <p>Set a region of the segmentation from a numpy array.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>ndarray</code>)           \u2013            <p>The segmentation's subregion as a numpy array.</p> </li> <li> <code>zarr_group</code>               (<code>str</code>, default:                   <code>'0'</code> )           \u2013            <p>Zarr group to access.</p> </li> <li> <code>x</code>               (<code>slice</code>, default:                   <code>slice(None, None)</code> )           \u2013            <p>Slice for the x-axis.</p> </li> <li> <code>y</code>               (<code>slice</code>, default:                   <code>slice(None, None)</code> )           \u2013            <p>Slice for the y-axis.</p> </li> <li> <code>z</code>               (<code>slice</code>, default:                   <code>slice(None, None)</code> )           \u2013            <p>Slice for the z-axis.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickTomogram/","title":"CopickTomogram","text":""},{"location":"api_reference/base_classes/data_entity_models/CopickTomogram/#copick.models.CopickTomogram","title":"copick.models.CopickTomogram","text":"<p>Encapsulates all data pertaining to a specific tomogram. This includes the features for this tomogram and the associated Zarr-store.</p> <p>Attributes:</p> <ul> <li> <code>voxel_spacing</code>               (<code>CopickVoxelSpacing</code>)           \u2013            <p>Reference to the voxel spacing this tomogram belongs to.</p> </li> <li> <code>meta</code>               (<code>CopickTomogramMeta</code>)           \u2013            <p>Metadata for this tomogram.</p> </li> <li> <code>features</code>               (<code>List[CopickFeatures]</code>)           \u2013            <p>Features for this tomogram. Either populated from config or lazily loaded when <code>CopickTomogram.features</code> is accessed for the first time.</p> </li> <li> <code>tomo_type</code>               (<code>str</code>)           \u2013            <p>Type of the tomogram.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickTomogram/#copick.models.CopickTomogram.get_features","title":"get_features","text":"<pre><code>get_features(feature_type: str) -&gt; Union[CopickFeatures, None]\n</code></pre> <p>Get feature maps by type.</p> <p>Parameters:</p> <ul> <li> <code>feature_type</code>               (<code>str</code>)           \u2013            <p>Type of the feature map to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CopickFeatures</code> (              <code>Union[CopickFeatures, None]</code> )          \u2013            <p>The feature map with the given type, or <code>None</code> if not found.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickTomogram/#copick.models.CopickTomogram.new_features","title":"new_features","text":"<pre><code>new_features(feature_type: str, exist_ok: bool = False, **kwargs) -&gt; CopickFeatures\n</code></pre> <p>Create a new feature map object. Also creates the Zarr-store for the map in the storage backend.</p> <p>Parameters:</p> <ul> <li> <code>feature_type</code>               (<code>str</code>)           \u2013            <p>Type of the feature map to create.</p> </li> <li> <code>exist_ok</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to raise an error if the feature map already exists.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional keyword arguments for the feature map metadata.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CopickFeatures</code> (              <code>CopickFeatures</code> )          \u2013            <p>The newly created feature map object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If a feature map with the given type already exists for this tomogram.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickTomogram/#copick.models.CopickTomogram.query_features","title":"query_features","text":"<pre><code>query_features() -&gt; List[CopickFeatures]\n</code></pre> <p>Override this method to query for features.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickTomogram/#copick.models.CopickTomogram.refresh_features","title":"refresh_features","text":"<pre><code>refresh_features() -&gt; None\n</code></pre> <p>Refresh <code>CopickTomogram.features</code> from storage.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickTomogram/#copick.models.CopickTomogram.refresh","title":"refresh","text":"<pre><code>refresh() -&gt; None\n</code></pre> <p>Refresh <code>CopickTomogram.features</code> from storage.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickTomogram/#copick.models.CopickTomogram.delete","title":"delete","text":"<pre><code>delete() -&gt; None\n</code></pre> <p>Delete the tomogram record.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickTomogram/#copick.models.CopickTomogram.delete_features","title":"delete_features","text":"<pre><code>delete_features() -&gt; None\n</code></pre> <p>Delete all features for this tomogram.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickTomogram/#copick.models.CopickTomogram.zarr","title":"zarr","text":"<pre><code>zarr() -&gt; MutableMapping\n</code></pre> <p>Override to return the Zarr store for this tomogram. Also needs to handle creating the store if it doesn't exist.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickTomogram/#copick.models.CopickTomogram.numpy","title":"numpy","text":"<pre><code>numpy(zarr_group: str = '0', x: slice = slice(None, None), y: slice = slice(None, None), z: slice = slice(None, None)) -&gt; np.ndarray\n</code></pre> <p>Returns the content of the Zarr-File for this tomogram as a numpy array. Multiscale group and slices are supported.</p> <p>Parameters:</p> <ul> <li> <code>zarr_group</code>               (<code>str</code>, default:                   <code>'0'</code> )           \u2013            <p>Zarr group to access.</p> </li> <li> <code>x</code>               (<code>slice</code>, default:                   <code>slice(None, None)</code> )           \u2013            <p>Slice for the x-axis.</p> </li> <li> <code>y</code>               (<code>slice</code>, default:                   <code>slice(None, None)</code> )           \u2013            <p>Slice for the y-axis.</p> </li> <li> <code>z</code>               (<code>slice</code>, default:                   <code>slice(None, None)</code> )           \u2013            <p>Slice for the z-axis.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: The tomogram as a numpy array.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickTomogram/#copick.models.CopickTomogram.from_numpy","title":"from_numpy","text":"<pre><code>from_numpy(data: ndarray, levels: int = 3, dtype: Optional[dtype] = np.float32) -&gt; None\n</code></pre> <p>Set the tomogram from a numpy array and compute multiscale pyramid. By default, three levels of the pyramid are computed.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>ndarray</code>)           \u2013            <p>The segmentation as a numpy array.</p> </li> <li> <code>levels</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            <p>Number of levels in the multiscale pyramid.</p> </li> <li> <code>dtype</code>               (<code>Optional[dtype]</code>, default:                   <code>float32</code> )           \u2013            <p>Data type of the segmentation. Default is <code>np.float32</code>.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickTomogram/#copick.models.CopickTomogram.set_region","title":"set_region","text":"<pre><code>set_region(data: ndarray, zarr_group: str = '0', x: slice = slice(None, None), y: slice = slice(None, None), z: slice = slice(None, None)) -&gt; None\n</code></pre> <p>Set a region of the tomogram from a numpy array.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>ndarray</code>)           \u2013            <p>The tomogram's subregion as a numpy array.</p> </li> <li> <code>zarr_group</code>               (<code>str</code>, default:                   <code>'0'</code> )           \u2013            <p>Zarr group to access.</p> </li> <li> <code>x</code>               (<code>slice</code>, default:                   <code>slice(None, None)</code> )           \u2013            <p>Slice for the x-axis.</p> </li> <li> <code>y</code>               (<code>slice</code>, default:                   <code>slice(None, None)</code> )           \u2013            <p>Slice for the y-axis.</p> </li> <li> <code>z</code>               (<code>slice</code>, default:                   <code>slice(None, None)</code> )           \u2013            <p>Slice for the z-axis.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickVoxelSpacing/","title":"CopickVoxelSpacing","text":""},{"location":"api_reference/base_classes/data_entity_models/CopickVoxelSpacing/#copick.models.CopickVoxelSpacing","title":"copick.models.CopickVoxelSpacing","text":"<p>Encapsulates all data pertaining to a specific voxel spacing. This includes the tomograms and feature maps at this voxel spacing.</p> <p>Attributes:</p> <ul> <li> <code>run</code>               (<code>CopickRun</code>)           \u2013            <p>Reference to the run this voxel spacing belongs to.</p> </li> <li> <code>meta</code>               (<code>CopickVoxelSpacingMeta</code>)           \u2013            <p>Metadata for this voxel spacing.</p> </li> <li> <code>tomograms</code>               (<code>List[CopickTomogram]</code>)           \u2013            <p>Tomograms for this voxel spacing. Either populated from config or lazily loaded when CopickVoxelSpacing.tomograms is accessed for the first time.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickVoxelSpacing/#copick.models.CopickVoxelSpacing.__init__","title":"__init__","text":"<pre><code>__init__(run: CopickRun, meta: CopickVoxelSpacingMeta, config: Optional[CopickConfig] = None)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>run</code>               (<code>CopickRun</code>)           \u2013            <p>Reference to the run this voxel spacing belongs to.</p> </li> <li> <code>meta</code>               (<code>CopickVoxelSpacingMeta</code>)           \u2013            <p>Metadata for this voxel spacing.</p> </li> <li> <code>config</code>               (<code>Optional[CopickConfig]</code>, default:                   <code>None</code> )           \u2013            <p>Configuration of the copick project.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickVoxelSpacing/#copick.models.CopickVoxelSpacing.query_tomograms","title":"query_tomograms","text":"<pre><code>query_tomograms() -&gt; List[CopickTomogram]\n</code></pre> <p>Override this method to query for tomograms.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickVoxelSpacing/#copick.models.CopickVoxelSpacing.get_tomogram","title":"get_tomogram","text":"<pre><code>get_tomogram(tomo_type: str) -&gt; Union[CopickTomogram, None]\n</code></pre> <p>Get tomogram by type.</p> <p>Parameters:</p> <ul> <li> <code>tomo_type</code>               (<code>str</code>)           \u2013            <p>Type of the tomogram to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CopickTomogram</code> (              <code>Union[CopickTomogram, None]</code> )          \u2013            <p>The tomogram with the given type, or <code>None</code> if not found.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickVoxelSpacing/#copick.models.CopickVoxelSpacing.get_tomograms","title":"get_tomograms","text":"<pre><code>get_tomograms(tomo_type: str) -&gt; List[CopickTomogram]\n</code></pre> <p>Get tomograms by type.</p> <p>Parameters:</p> <ul> <li> <code>tomo_type</code>               (<code>str</code>)           \u2013            <p>Type of the tomograms to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[CopickTomogram]</code>           \u2013            <p>List[CopickTomogram]: The tomograms with the given type.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickVoxelSpacing/#copick.models.CopickVoxelSpacing.refresh_tomograms","title":"refresh_tomograms","text":"<pre><code>refresh_tomograms() -&gt; None\n</code></pre> <p>Refresh <code>CopickVoxelSpacing.tomograms</code> from storage.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickVoxelSpacing/#copick.models.CopickVoxelSpacing.refresh","title":"refresh","text":"<pre><code>refresh() -&gt; None\n</code></pre> <p>Refresh <code>CopickVoxelSpacing.tomograms</code> from storage.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickVoxelSpacing/#copick.models.CopickVoxelSpacing.new_tomogram","title":"new_tomogram","text":"<pre><code>new_tomogram(tomo_type: str, exist_ok: bool = False, **kwargs) -&gt; CopickTomogram\n</code></pre> <p>Create a new tomogram object, also creates the Zarr-store in the storage backend.</p> <p>Parameters:</p> <ul> <li> <code>tomo_type</code>               (<code>str</code>)           \u2013            <p>Type of the tomogram to create.</p> </li> <li> <code>exist_ok</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to raise an error if the tomogram already exists.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional keyword arguments for the tomogram metadata.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CopickTomogram</code> (              <code>CopickTomogram</code> )          \u2013            <p>The newly created tomogram object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If a tomogram with the given type already exists for this voxel spacing.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickVoxelSpacing/#copick.models.CopickVoxelSpacing.ensure","title":"ensure","text":"<pre><code>ensure(create: bool = False) -&gt; bool\n</code></pre> <p>Override to check if the voxel spacing record exists, optionally create it if it does not.</p> <p>Parameters:</p> <ul> <li> <code>create</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to create the voxel spacing record if it does not exist.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the voxel spacing record exists, False otherwise.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickVoxelSpacing/#copick.models.CopickVoxelSpacing.delete","title":"delete","text":"<pre><code>delete() -&gt; None\n</code></pre> <p>Delete the voxel spacing record.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickVoxelSpacing/#copick.models.CopickVoxelSpacing.delete_tomograms","title":"delete_tomograms","text":"<pre><code>delete_tomograms(tomo_type: str = None) -&gt; None\n</code></pre> <p>Delete a tomogram by type.</p> <p>Parameters:</p> <ul> <li> <code>tomo_type</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Type of the tomogram to delete.</p> </li> </ul>"},{"location":"api_reference/base_classes/metadata_models/CopickConfig/","title":"CopickConfig","text":""},{"location":"api_reference/base_classes/metadata_models/CopickConfig/#copick.models.CopickConfig","title":"copick.models.CopickConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for a copick project. Defines the available objects, user_id and optionally an index for runs.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>Optional[str]</code>)           \u2013            <p>Name of the CoPick project.</p> </li> <li> <code>description</code>               (<code>Optional[str]</code>)           \u2013            <p>Description of the CoPick project.</p> </li> <li> <code>version</code>               (<code>Optional[str]</code>)           \u2013            <p>Version of the CoPick API.</p> </li> <li> <code>pickable_objects</code>               (<code>List[PickableObject]</code>)           \u2013            <p>Index for available pickable objects.</p> </li> <li> <code>user_id</code>               (<code>Optional[str]</code>)           \u2013            <p>Unique identifier for the user (e.g. when distributing the config file to users).</p> </li> <li> <code>session_id</code>               (<code>Optional[str]</code>)           \u2013            <p>Unique identifier for the session.</p> </li> <li> <code>voxel_spacings</code>               (<code>Optional[List[float]]</code>)           \u2013            <p>Index for available voxel spacings.</p> </li> <li> <code>runs</code>               (<code>Optional[List[str]]</code>)           \u2013            <p>Index for run names.</p> </li> <li> <code>tomograms</code>               (<code>Optional[Dict[float, List[str]]]</code>)           \u2013            <p>Index for available voxel spacings and tomogram types.</p> </li> </ul>"},{"location":"api_reference/base_classes/metadata_models/CopickConfig/#copick.models.CopickConfig.name","title":"name","text":"<pre><code>name: Optional[str] = 'CoPick'\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/CopickConfig/#copick.models.CopickConfig.description","title":"description","text":"<pre><code>description: Optional[str] = \"Let's CoPick!\"\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/CopickConfig/#copick.models.CopickConfig.version","title":"version","text":"<pre><code>version: Optional[str] = '0.2.0'\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/CopickConfig/#copick.models.CopickConfig.pickable_objects","title":"pickable_objects","text":"<pre><code>pickable_objects: List[PickableObject]\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/CopickConfig/#copick.models.CopickConfig.user_id","title":"user_id","text":"<pre><code>user_id: Optional[str] = None\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/CopickConfig/#copick.models.CopickConfig.session_id","title":"session_id","text":"<pre><code>session_id: Optional[str] = None\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/CopickConfig/#copick.models.CopickConfig.runs","title":"runs","text":"<pre><code>runs: Optional[List[str]] = None\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/CopickConfig/#copick.models.CopickConfig.voxel_spacings","title":"voxel_spacings","text":"<pre><code>voxel_spacings: Optional[List[float]] = None\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/CopickConfig/#copick.models.CopickConfig.tomograms","title":"tomograms","text":"<pre><code>tomograms: Optional[Dict[float, List[str]]] = {}\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/CopickConfig/#copick.models.CopickConfig.from_file","title":"from_file","text":"<pre><code>from_file(filename: str) -&gt; CopickConfig\n</code></pre> <p>Load a CopickConfig from a file and create a CopickConfig object.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>path to the file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CopickConfig</code> (              <code>CopickConfig</code> )          \u2013            <p>Initialized CopickConfig object</p> </li> </ul>"},{"location":"api_reference/base_classes/metadata_models/CopickConfig/#copick.models.CopickConfig.validate_user_id","title":"validate_user_id","text":"<pre><code>validate_user_id(v) -&gt; Optional[str]\n</code></pre> <p>Validate the user_id.</p>"},{"location":"api_reference/base_classes/metadata_models/CopickConfig/#copick.models.CopickConfig.validate_session_id","title":"validate_session_id","text":"<pre><code>validate_session_id(v) -&gt; Optional[str]\n</code></pre> <p>Validate the session_id.</p>"},{"location":"api_reference/base_classes/metadata_models/CopickFeaturesMeta/","title":"CopickFeaturesMeta","text":""},{"location":"api_reference/base_classes/metadata_models/CopickFeaturesMeta/#copick.models.CopickFeaturesMeta","title":"copick.models.CopickFeaturesMeta","text":"<p>               Bases: <code>BaseModel</code></p> <p>Data model for feature map metadata.</p> <p>Attributes:</p> <ul> <li> <code>tomo_type</code>               (<code>str</code>)           \u2013            <p>Type of the tomogram that the features were computed on.</p> </li> <li> <code>feature_type</code>               (<code>str</code>)           \u2013            <p>Type of the features contained.</p> </li> </ul>"},{"location":"api_reference/base_classes/metadata_models/CopickFeaturesMeta/#copick.models.CopickFeaturesMeta.tomo_type","title":"tomo_type","text":"<pre><code>tomo_type: str\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/CopickFeaturesMeta/#copick.models.CopickFeaturesMeta.feature_type","title":"feature_type","text":"<pre><code>feature_type: str\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/CopickMeshMeta/","title":"CopickMeshMeta","text":""},{"location":"api_reference/base_classes/metadata_models/CopickMeshMeta/#copick.models.CopickMeshMeta","title":"copick.models.CopickMeshMeta","text":"<p>               Bases: <code>BaseModel</code></p> <p>Data model for mesh metadata.</p> <p>Attributes:</p> <ul> <li> <code>pickable_object_name</code>               (<code>str</code>)           \u2013            <p>Pickable object name from <code>CopickConfig.pickable_objects[...].name</code></p> </li> <li> <code>user_id</code>               (<code>str</code>)           \u2013            <p>Unique identifier for the user or tool name.</p> </li> <li> <code>session_id</code>               (<code>Union[str, Literal['0']]</code>)           \u2013            <p>Unique identifier for the pick session. If it is 0, this pick was generated by a tool.</p> </li> </ul>"},{"location":"api_reference/base_classes/metadata_models/CopickMeshMeta/#copick.models.CopickMeshMeta.pickable_object_name","title":"pickable_object_name","text":"<pre><code>pickable_object_name: str\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/CopickMeshMeta/#copick.models.CopickMeshMeta.user_id","title":"user_id","text":"<pre><code>user_id: str\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/CopickMeshMeta/#copick.models.CopickMeshMeta.session_id","title":"session_id","text":"<pre><code>session_id: Union[str, Literal['0']]\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/","title":"CopickPicksFile","text":""},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickPicksFile","title":"copick.models.CopickPicksFile","text":"<p>               Bases: <code>BaseModel</code></p> <p>Datamodel for a collection of locations, orientations and other metadata for one pickable object.</p> <p>Attributes:</p> <ul> <li> <code>pickable_object_name</code>               (<code>str</code>)           \u2013            <p>Pickable object name from CopickConfig.pickable_objects[X].name</p> </li> <li> <code>user_id</code>               (<code>str</code>)           \u2013            <p>Unique identifier for the user or tool name.</p> </li> <li> <code>session_id</code>               (<code>Union[str, Literal['0']]</code>)           \u2013            <p>Unique identifier for the pick session (prevent race if they run multiple instances of napari, ChimeraX, etc.) If it is 0, this pick was generated by a tool.</p> </li> <li> <code>run_name</code>               (<code>Optional[str]</code>)           \u2013            <p>Name of the run this pick belongs to.</p> </li> <li> <code>voxel_spacing</code>               (<code>Optional[float]</code>)           \u2013            <p>Voxel spacing for the tomogram this pick belongs to.</p> </li> <li> <code>unit</code>               (<code>str</code>)           \u2013            <p>Unit for the location of the pick.</p> </li> <li> <code>points</code>               (<code>List[CopickPoint]</code>)           \u2013            <p>References to the points for this pick.</p> </li> <li> <code>trust_orientation</code>               (<code>Optional[bool]</code>)           \u2013            <p>Flag to indicate if the angles are known for this pick or should be ignored.</p> </li> </ul>"},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickPicksFile.pickable_object_name","title":"pickable_object_name","text":"<pre><code>pickable_object_name: str\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickPicksFile.user_id","title":"user_id","text":"<pre><code>user_id: str\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickPicksFile.session_id","title":"session_id","text":"<pre><code>session_id: Union[str, Literal['0']]\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickPicksFile.run_name","title":"run_name","text":"<pre><code>run_name: Optional[str] = None\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickPicksFile.voxel_spacing","title":"voxel_spacing","text":"<pre><code>voxel_spacing: Optional[float] = None\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickPicksFile.unit","title":"unit","text":"<pre><code>unit: str = 'angstrom'\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickPicksFile.points","title":"points","text":"<pre><code>points: Optional[List[CopickPoint]] = Field(default_factory=list)\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickPicksFile.trust_orientation","title":"trust_orientation","text":"<pre><code>trust_orientation: Optional[bool] = True\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickPoint","title":"copick.models.CopickPoint","text":"<p>               Bases: <code>BaseModel</code></p> <p>Point in 3D space with an associated orientation, score value and instance ID.</p> <p>Attributes:</p> <ul> <li> <code>location</code>               (<code>CopickLocation</code>)           \u2013            <p>Location in 3D space.</p> </li> <li> <code>transformation</code>               (<code>ndarray</code>)           \u2013            <p>Transformation matrix.</p> </li> <li> <code>instance_id</code>               (<code>Optional[int]</code>)           \u2013            <p>Instance ID.</p> </li> <li> <code>score</code>               (<code>Optional[float]</code>)           \u2013            <p>Score value.</p> </li> </ul>"},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickPoint.location","title":"location","text":"<pre><code>location: CopickLocation\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickPoint.transformation_","title":"transformation_","text":"<pre><code>transformation_: Optional[List[List[float]]] = [[1.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0], [0.0, 0.0, 0.0, 1.0]]\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickPoint.instance_id","title":"instance_id","text":"<pre><code>instance_id: Optional[int] = 0\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickPoint.score","title":"score","text":"<pre><code>score: Optional[float] = 1.0\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickPoint.model_config","title":"model_config","text":"<pre><code>model_config = {'arbitrary_types_allowed': True}\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickPoint.transformation","title":"transformation","text":"<pre><code>transformation: ndarray\n</code></pre> <p>The transformation necessary to transform coordinates from the object space to the tomogram space.</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: 4x4 transformation matrix.</p> </li> </ul>"},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickPoint.validate_transformation","title":"validate_transformation","text":"<pre><code>validate_transformation(v) -&gt; List[List[float]]\n</code></pre> <p>Validate the transformation matrix.</p>"},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickLocation","title":"copick.models.CopickLocation","text":"<p>               Bases: <code>BaseModel</code></p> <p>Location in 3D space.</p> <p>Attributes:</p> <ul> <li> <code>x</code>               (<code>float</code>)           \u2013            <p>x-coordinate.</p> </li> <li> <code>y</code>               (<code>float</code>)           \u2013            <p>y-coordinate.</p> </li> <li> <code>z</code>               (<code>float</code>)           \u2013            <p>z-coordinate.</p> </li> </ul>"},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickLocation.x","title":"x","text":"<pre><code>x: float\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickLocation.y","title":"y","text":"<pre><code>y: float\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickLocation.z","title":"z","text":"<pre><code>z: float\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/CopickRunMeta/","title":"CopickRunMeta","text":""},{"location":"api_reference/base_classes/metadata_models/CopickRunMeta/#copick.models.CopickRunMeta","title":"copick.models.CopickRunMeta","text":"<p>               Bases: <code>BaseModel</code></p> <p>Data model for run level metadata.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name of the run.</p> </li> </ul>"},{"location":"api_reference/base_classes/metadata_models/CopickRunMeta/#copick.models.CopickRunMeta.name","title":"name","text":"<pre><code>name: str\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/CopickSegmentationMeta/","title":"CopickSegmentationMeta","text":""},{"location":"api_reference/base_classes/metadata_models/CopickSegmentationMeta/#copick.models.CopickSegmentationMeta","title":"copick.models.CopickSegmentationMeta","text":"<p>               Bases: <code>BaseModel</code></p> <p>Datamodel for segmentation metadata.</p> <p>Attributes:</p> <ul> <li> <code>user_id</code>               (<code>str</code>)           \u2013            <p>Unique identifier for the user or tool name.</p> </li> <li> <code>session_id</code>               (<code>Union[str, Literal['0']]</code>)           \u2013            <p>Unique identifier for the segmentation session. If it is 0, this segmentation was generated by a tool.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Pickable Object name or multilabel name of the segmentation.</p> </li> <li> <code>is_multilabel</code>               (<code>bool</code>)           \u2013            <p>Flag to indicate if this is a multilabel segmentation. If False, it is a single label segmentation.</p> </li> <li> <code>voxel_size</code>               (<code>float</code>)           \u2013            <p>Voxel size in angstrom of the tomogram this segmentation belongs to. Rounded to the third decimal.</p> </li> </ul>"},{"location":"api_reference/base_classes/metadata_models/CopickSegmentationMeta/#copick.models.CopickSegmentationMeta.user_id","title":"user_id","text":"<pre><code>user_id: str\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/CopickSegmentationMeta/#copick.models.CopickSegmentationMeta.session_id","title":"session_id","text":"<pre><code>session_id: Union[str, Literal['0']]\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/CopickSegmentationMeta/#copick.models.CopickSegmentationMeta.name","title":"name","text":"<pre><code>name: str\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/CopickSegmentationMeta/#copick.models.CopickSegmentationMeta.is_multilabel","title":"is_multilabel","text":"<pre><code>is_multilabel: bool\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/CopickSegmentationMeta/#copick.models.CopickSegmentationMeta.voxel_size","title":"voxel_size","text":"<pre><code>voxel_size: float\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/CopickTomogramMeta/","title":"CopickTomogramMeta","text":""},{"location":"api_reference/base_classes/metadata_models/CopickTomogramMeta/#copick.models.CopickTomogramMeta","title":"copick.models.CopickTomogramMeta","text":"<p>               Bases: <code>BaseModel</code></p> <p>Data model for tomogram metadata.</p> <p>Attributes:</p> <ul> <li> <code>tomo_type</code>               (<code>str</code>)           \u2013            <p>Type of the tomogram.</p> </li> </ul>"},{"location":"api_reference/base_classes/metadata_models/CopickTomogramMeta/#copick.models.CopickTomogramMeta.tomo_type","title":"tomo_type","text":"<pre><code>tomo_type: str\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/CopickVoxelSpacingMeta/","title":"CopickVoxelSpacingMeta","text":""},{"location":"api_reference/base_classes/metadata_models/CopickVoxelSpacingMeta/#copick.models.CopickVoxelSpacingMeta","title":"copick.models.CopickVoxelSpacingMeta","text":"<p>               Bases: <code>BaseModel</code></p> <p>Data model for voxel spacing metadata.</p> <p>Attributes:</p> <ul> <li> <code>voxel_size</code>               (<code>float</code>)           \u2013            <p>Voxel size in angstrom, rounded to the third decimal.</p> </li> </ul>"},{"location":"api_reference/base_classes/metadata_models/CopickVoxelSpacingMeta/#copick.models.CopickVoxelSpacingMeta.voxel_size","title":"voxel_size","text":"<pre><code>voxel_size: float\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/PickableObject/","title":"PickableObject","text":""},{"location":"api_reference/base_classes/metadata_models/PickableObject/#copick.models.PickableObject","title":"copick.models.PickableObject","text":"<p>               Bases: <code>BaseModel</code></p> <p>Metadata for a pickable objects.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name of the object.</p> </li> <li> <code>is_particle</code>               (<code>bool</code>)           \u2013            <p>Whether this object should be represented by points (True) or segmentation masks (False).</p> </li> <li> <code>label</code>               (<code>Optional[int]</code>)           \u2013            <p>Numeric label/id for the object, as used in multilabel segmentation masks. Must be unique.</p> </li> <li> <code>color</code>               (<code>Optional[Tuple[int, int, int, int]]</code>)           \u2013            <p>RGBA color for the object.</p> </li> <li> <code>emdb_id</code>               (<code>Optional[str]</code>)           \u2013            <p>EMDB ID for the object.</p> </li> <li> <code>pdb_id</code>               (<code>Optional[str]</code>)           \u2013            <p>PDB ID for the object.</p> </li> <li> <code>identifier</code>               (<code>Optional[str]</code>)           \u2013            <p>Identifier for the object (e.g. Gene Ontology ID or UniProtKB accession).</p> </li> <li> <code>map_threshold</code>               (<code>Optional[float]</code>)           \u2013            <p>Threshold to apply to the map when rendering the isosurface.</p> </li> <li> <code>radius</code>               (<code>Optional[float]</code>)           \u2013            <p>Radius of the particle, when displaying as a sphere.</p> </li> <li> <code>metadata</code>               (<code>Optional[Dict[str, Any]]</code>)           \u2013            <p>Additional metadata for the object (user-defined contents).</p> </li> </ul>"},{"location":"api_reference/base_classes/metadata_models/PickableObject/#copick.models.PickableObject.name","title":"name","text":"<pre><code>name: str\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/PickableObject/#copick.models.PickableObject.is_particle","title":"is_particle","text":"<pre><code>is_particle: bool\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/PickableObject/#copick.models.PickableObject.label","title":"label","text":"<pre><code>label: Optional[int] = 1\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/PickableObject/#copick.models.PickableObject.color","title":"color","text":"<pre><code>color: Optional[Tuple[int, int, int, int]] = (100, 100, 100, 255)\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/PickableObject/#copick.models.PickableObject.emdb_id","title":"emdb_id","text":"<pre><code>emdb_id: Optional[str] = None\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/PickableObject/#copick.models.PickableObject.pdb_id","title":"pdb_id","text":"<pre><code>pdb_id: Optional[str] = None\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/PickableObject/#copick.models.PickableObject.identifier","title":"identifier","text":"<pre><code>identifier: Optional[str] = Field(None, alias=AliasChoices('go_id', 'identifier'))\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/PickableObject/#copick.models.PickableObject.map_threshold","title":"map_threshold","text":"<pre><code>map_threshold: Optional[float] = None\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/PickableObject/#copick.models.PickableObject.radius","title":"radius","text":"<pre><code>radius: Optional[float] = None\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/PickableObject/#copick.models.PickableObject.metadata","title":"metadata","text":"<pre><code>metadata: Optional[Dict[str, Any]] = Field(default_factory=dict)\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/PickableObject/#copick.models.PickableObject.go_id","title":"go_id","text":"<pre><code>go_id\n</code></pre>"},{"location":"api_reference/base_classes/metadata_models/PickableObject/#copick.models.PickableObject.validate_label","title":"validate_label","text":"<pre><code>validate_label(v) -&gt; int\n</code></pre> <p>Validate the label.</p>"},{"location":"api_reference/base_classes/metadata_models/PickableObject/#copick.models.PickableObject.validate_color","title":"validate_color","text":"<pre><code>validate_color(v) -&gt; Tuple[int, int, int, int]\n</code></pre> <p>Validate the color.</p>"},{"location":"api_reference/base_classes/metadata_models/PickableObject/#copick.models.PickableObject.validate_name","title":"validate_name","text":"<pre><code>validate_name(v) -&gt; Optional[str]\n</code></pre> <p>Validate the name.</p>"},{"location":"api_reference/base_classes/metadata_models/PickableObject/#copick.models.PickableObject.none_to_empty_dict","title":"none_to_empty_dict","text":"<pre><code>none_to_empty_dict(v)\n</code></pre>"},{"location":"api_reference/functional/add/","title":"Add Operations","text":"<p>The <code>copick.ops.add</code> module provides functions for adding data to Copick projects, including runs, voxel spacings, tomograms, and features. These functions handle the creation and storage of data entities with proper validation and metadata management.</p>"},{"location":"api_reference/functional/add/#functions","title":"Functions","text":""},{"location":"api_reference/functional/add/#copick.ops.add.add_run","title":"copick.ops.add.add_run","text":"<pre><code>add_run(root: CopickRoot, name: str, exist_ok: bool = False, log: bool = False) -&gt; CopickRun\n</code></pre> <p>Import a run into copick.</p> <p>Parameters:</p> <ul> <li> <code>root</code>               (<code>CopickRoot</code>)           \u2013            <p>The copick root object.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the run.</p> </li> <li> <code>exist_ok</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, do not raise an error if the run already exists. Defaults to False.</p> </li> <li> <code>log</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Log the operation. Defaults to False.</p> </li> </ul>"},{"location":"api_reference/functional/add/#copick.ops.add.get_or_create_run","title":"copick.ops.add.get_or_create_run","text":"<pre><code>get_or_create_run(root: CopickRoot, name: str, create: bool = True, log: bool = False) -&gt; CopickRun\n</code></pre>"},{"location":"api_reference/functional/add/#copick.ops.add.add_voxelspacing","title":"copick.ops.add.add_voxelspacing","text":"<pre><code>add_voxelspacing(root: CopickRoot, run: str, voxel_spacing: float, create: bool = True, exist_ok: bool = False, log: bool = False) -&gt; CopickVoxelSpacing\n</code></pre> <p>Import a voxel spacing into copick.</p> <p>Parameters:</p> <ul> <li> <code>root</code>               (<code>CopickRoot</code>)           \u2013            <p>The copick root object.</p> </li> <li> <code>run</code>               (<code>str</code>)           \u2013            <p>The name of the run.</p> </li> <li> <code>voxel_spacing</code>               (<code>float</code>)           \u2013            <p>The voxel spacing of the run.</p> </li> <li> <code>create</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Create the object if it does not exist. Defaults to True.</p> </li> <li> <code>exist_ok</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, do not raise an error if the voxel spacing already exists. Defaults to False.</p> </li> <li> <code>log</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Log the operation. Defaults to False.</p> </li> </ul>"},{"location":"api_reference/functional/add/#copick.ops.add.get_or_create_voxelspacing","title":"copick.ops.add.get_or_create_voxelspacing","text":"<pre><code>get_or_create_voxelspacing(run: CopickRun, voxel_size: float, create: bool = True, log: bool = False) -&gt; CopickVoxelSpacing\n</code></pre> <p>Get or create a voxel spacing object.</p> <p>Parameters:</p> <ul> <li> <code>run</code>               (<code>CopickRun</code>)           \u2013            <p>The run object.</p> </li> <li> <code>voxel_size</code>               (<code>float</code>)           \u2013            <p>The voxel size.</p> </li> <li> <code>create</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Create the object if it does not exist. Defaults to True.</p> </li> <li> <code>log</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Log the operation. Defaults to False.</p> </li> </ul>"},{"location":"api_reference/functional/add/#copick.ops.add.add_tomogram","title":"copick.ops.add.add_tomogram","text":"<pre><code>add_tomogram(root: CopickRoot, run: str, tomo_type: str, volume: Union[ndarray, Dict[float, ndarray]], voxel_spacing: float = None, create: bool = True, exist_ok: bool = False, overwrite: bool = False, create_pyramid: bool = False, pyramid_levels: int = 3, chunks: Tuple[int, ...] = (256, 256, 256), meta: Dict[str, Any] = None, log: bool = False) -&gt; CopickTomogram\n</code></pre> <p>Add a tomogram to a copick run.</p> <p>Parameters:</p> <ul> <li> <code>root</code>               (<code>CopickRoot</code>)           \u2013            <p>The copick root object.</p> </li> <li> <code>volume</code>               (<code>Dict[float, ndarray]</code>)           \u2013            <p>Multi-scale pyramid of the tomogram. Keys are the voxel size in Angstroms.</p> </li> <li> <code>create</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Create the object if it does not exist. Defaults to True.</p> </li> <li> <code>exist_ok</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, do not raise an error if the volume already exists. Defaults to False.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Overwrite the object if it exists. Defaults to False.</p> </li> <li> <code>run</code>               (<code>str</code>)           \u2013            <p>The run the tomogram is part of. Default: Name of the input file.</p> </li> </ul>"},{"location":"api_reference/functional/add/#copick.ops.add.add_features","title":"copick.ops.add.add_features","text":"<pre><code>add_features(root: CopickRoot, run: str, voxel_spacing: float, tomo_type: str, feature_type: str, features_vol: ndarray, exist_ok: bool = False, overwrite: bool = False, chunks: Tuple[int, int, int] = (256, 256, 256), meta: Dict[str, Any] = None, log: bool = False) -&gt; CopickFeatures\n</code></pre> <p>Add features to a copick run.</p> <p>Parameters:</p> <ul> <li> <code>root</code>               (<code>CopickRoot</code>)           \u2013            <p>The copick root object.</p> </li> <li> <code>features</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>The features to add.</p> </li> <li> <code>run</code>               (<code>str</code>)           \u2013            <p>The run the features are part of.</p> </li> <li> <code>exist_ok</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, do not raise an error if the features already exist. Defaults to False.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Overwrite the object if it exists. Defaults to False.</p> </li> <li> <code>log</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Log the operation. Defaults to False.</p> </li> </ul>"},{"location":"api_reference/functional/add/#usage-examples","title":"Usage Examples","text":""},{"location":"api_reference/functional/add/#adding-a-run","title":"Adding a Run","text":"<pre><code>from copick.ops.add import add_run\nfrom copick.impl.filesystem import CopickRootFSSpec\n\n# Open a project\nroot = CopickRootFSSpec.from_file(\"config.json\")\n\n# Add a new run\nrun = add_run(root, \"experiment_001\", exist_ok=True, log=True)\n</code></pre>"},{"location":"api_reference/functional/add/#adding-a-tomogram","title":"Adding a Tomogram","text":"<pre><code>import numpy as np\nfrom copick.ops.add import add_tomogram\n\n# Create sample volume data\nvolume = np.random.rand(512, 512, 512).astype(np.float32)\n\n# Add tomogram with pyramid generation\ntomogram = add_tomogram(\n    root=root,\n    run=\"experiment_001\",\n    tomo_type=\"wbp\",\n    volume=volume,\n    voxel_spacing=10.0,\n    create_pyramid=True,\n    pyramid_levels=4,\n    log=True\n)\n</code></pre>"},{"location":"api_reference/functional/add/#adding-features","title":"Adding Features","text":"<pre><code># Add computed features to a tomogram\nfeatures = add_features(\n    root=root,\n    run=\"experiment_001\",\n    voxel_spacing=10.0,\n    tomo_type=\"wbp\",\n    feature_type=\"membrane_segmentation\",\n    features_vol=segmentation_volume,\n    log=True\n)\n</code></pre>"},{"location":"api_reference/functional/get/","title":"Get Operations","text":"<p>The <code>copick.ops.get</code> module provides query functions for retrieving data from Copick projects. These functions offer convenient ways to search, filter, and access runs, tomograms, picks, segmentations, and other data entities.</p>"},{"location":"api_reference/functional/get/#functions","title":"Functions","text":""},{"location":"api_reference/functional/get/#copick.ops.get.get_segmentations","title":"copick.ops.get.get_segmentations","text":"<pre><code>get_segmentations(root: Union[str, CopickRoot], runs: Union[str, CopickRun, Iterable[str], Iterable[CopickRun], None] = None, user_id: Union[str, Iterable[str], None] = None, session_id: Union[str, Iterable[str], None] = None, is_multilabel: bool = None, name: Union[str, Iterable[str], None] = None, voxel_size: Union[float, Iterable[float], None] = None, parallel: bool = False, workers: Optional[int] = 8, show_progress: bool = True) -&gt; Union[List[CopickSegmentation], None]\n</code></pre> <p>Query segmentations from a Copick project.</p> <p>Parameters:</p> <ul> <li> <code>root</code>               (<code>Union[str, CopickRoot]</code>)           \u2013            <p>The Copick project root.</p> </li> <li> <code>runs</code>               (<code>Union[str, CopickRun, Iterable[str], Iterable[CopickRun], None]</code>, default:                   <code>None</code> )           \u2013            <p>The runs to query segmentations from. If <code>None</code>, query all runs.</p> </li> <li> <code>user_id</code>               (<code>Union[str, Iterable[str], None]</code>, default:                   <code>None</code> )           \u2013            <p>The user ID of the segmentations. If <code>None</code>, query all users.</p> </li> <li> <code>session_id</code>               (<code>Union[str, Iterable[str], None]</code>, default:                   <code>None</code> )           \u2013            <p>The session ID of the segmentations. If <code>None</code>, query all sessions.</p> </li> <li> <code>is_multilabel</code>               (<code>bool</code>, default:                   <code>None</code> )           \u2013            <p>Whether the segmentations are multilabel. If <code>None</code>, query all segmentations.</p> </li> <li> <code>name</code>               (<code>Union[str, Iterable[str], None]</code>, default:                   <code>None</code> )           \u2013            <p>The name of the segmentation. If <code>None</code>, query all segmentations.</p> </li> <li> <code>voxel_size</code>               (<code>Union[float, Iterable[float], None]</code>, default:                   <code>None</code> )           \u2013            <p>The voxel size of the segmentation. If <code>None</code>, query all segmentations.</p> </li> <li> <code>parallel</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to query segmentations in parallel. Default is <code>False</code>.</p> </li> <li> <code>workers</code>               (<code>Optional[int]</code>, default:                   <code>8</code> )           \u2013            <p>The number of workers to use. Default is <code>8</code>.</p> </li> <li> <code>show_progress</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to show progress. Default is <code>True</code>.</p> </li> </ul>"},{"location":"api_reference/functional/get/#copick.ops.get.get_meshes","title":"copick.ops.get.get_meshes","text":"<pre><code>get_meshes(root: Union[str, CopickRoot], runs: Union[str, CopickRun, Iterable[str], Iterable[CopickRun], None] = None, user_id: Union[str, Iterable[str], None] = None, session_id: Union[str, Iterable[str], None] = None, object_name: Union[str, Iterable[str], None] = None, parallel: bool = False, workers: Optional[int] = 8, show_progress: bool = True) -&gt; Union[List[CopickMesh], None]\n</code></pre> <p>Query meshes from a Copick project.</p> <p>Parameters:</p> <ul> <li> <code>root</code>               (<code>Union[str, CopickRoot]</code>)           \u2013            <p>The Copick project root.</p> </li> <li> <code>runs</code>               (<code>Union[str, CopickRun, Iterable[str], Iterable[CopickRun], None]</code>, default:                   <code>None</code> )           \u2013            <p>The runs to query meshes from. If <code>None</code>, query all runs.</p> </li> <li> <code>user_id</code>               (<code>Union[str, Iterable[str], None]</code>, default:                   <code>None</code> )           \u2013            <p>The user ID of the meshes. If <code>None</code>, query all users.</p> </li> <li> <code>session_id</code>               (<code>Union[str, Iterable[str], None]</code>, default:                   <code>None</code> )           \u2013            <p>The session ID of the meshes. If <code>None</code>, query all sessions.</p> </li> <li> <code>object_name</code>               (<code>Union[str, Iterable[str], None]</code>, default:                   <code>None</code> )           \u2013            <p>The pickable object of the meshes. If <code>None</code>, query all meshes.</p> </li> <li> <code>parallel</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to query meshes in parallel. Default is <code>False</code>.</p> </li> <li> <code>workers</code>               (<code>Optional[int]</code>, default:                   <code>8</code> )           \u2013            <p>The number of workers to use. Default is <code>8</code>.</p> </li> <li> <code>show_progress</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to show progress. Default is <code>True</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Union[List[CopickMesh], None]</code>           \u2013            <p>A list of meshes.</p> </li> </ul>"},{"location":"api_reference/functional/get/#copick.ops.get.get_picks","title":"copick.ops.get.get_picks","text":"<pre><code>get_picks(root: Union[str, CopickRoot], runs: Union[str, CopickRun, Iterable[str], Iterable[CopickRun], None] = None, user_id: Union[str, Iterable[str], None] = None, session_id: Union[str, Iterable[str], None] = None, object_name: Union[str, Iterable[str], None] = None, parallel: bool = False, workers: Optional[int] = 8, show_progress: bool = True) -&gt; Union[List[CopickPicks], None]\n</code></pre> <p>Query picks from a Copick project.</p> <p>Parameters:</p> <ul> <li> <code>root</code>               (<code>Union[str, CopickRoot]</code>)           \u2013            <p>The Copick project root.</p> </li> <li> <code>runs</code>               (<code>Union[str, CopickRun, Iterable[str], Iterable[CopickRun], None]</code>, default:                   <code>None</code> )           \u2013            <p>The runs to query picks from. If <code>None</code>, query all runs.</p> </li> <li> <code>user_id</code>               (<code>Union[str, Iterable[str], None]</code>, default:                   <code>None</code> )           \u2013            <p>The user ID of the picks. If <code>None</code>, query all users.</p> </li> <li> <code>session_id</code>               (<code>Union[str, Iterable[str], None]</code>, default:                   <code>None</code> )           \u2013            <p>The session ID of the picks. If <code>None</code>, query all sessions.</p> </li> <li> <code>object_name</code>               (<code>Union[str, Iterable[str], None]</code>, default:                   <code>None</code> )           \u2013            <p>The pickable object of the picks. If <code>None</code>, query all picks.</p> </li> <li> <code>parallel</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to query picks in parallel. Default is <code>False</code>.</p> </li> <li> <code>workers</code>               (<code>Optional[int]</code>, default:                   <code>8</code> )           \u2013            <p>The number of workers to use. Default is <code>8</code>.</p> </li> <li> <code>show_progress</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to show progress. Default is <code>True</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Union[List[CopickPicks], None]</code>           \u2013            <p>A list of picks.</p> </li> </ul>"},{"location":"api_reference/functional/get/#copick.ops.get.get_voxelspacings","title":"copick.ops.get.get_voxelspacings","text":"<pre><code>get_voxelspacings(root: Union[str, CopickRoot], runs: Union[str, CopickRun, Iterable[str], Iterable[CopickRun], None] = None, voxel_size: Union[float, Iterable[float], None] = None, parallel: bool = False, workers: Optional[int] = 8, show_progress: bool = True) -&gt; Union[List[CopickVoxelSpacing], None]\n</code></pre> <p>Query voxel spacings from a Copick project.</p> <p>Parameters:</p> <ul> <li> <code>root</code>               (<code>Union[str, CopickRoot]</code>)           \u2013            <p>The Copick project root.</p> </li> <li> <code>runs</code>               (<code>Union[str, CopickRun, Iterable[str], Iterable[CopickRun], None]</code>, default:                   <code>None</code> )           \u2013            <p>The runs to query voxel spacings from. If <code>None</code>, query all runs.</p> </li> <li> <code>voxel_size</code>               (<code>Union[float, Iterable[float], None]</code>, default:                   <code>None</code> )           \u2013            <p>The voxel size of the voxel spacings. If <code>None</code>, query all voxel spacings.</p> </li> <li> <code>parallel</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to query voxel spacings in parallel. Default is <code>False</code>.</p> </li> <li> <code>workers</code>               (<code>Optional[int]</code>, default:                   <code>8</code> )           \u2013            <p>The number of workers to use. Default is <code>8</code>.</p> </li> <li> <code>show_progress</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to show progress. Default is <code>True</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Union[List[CopickVoxelSpacing], None]</code>           \u2013            <p>A list of voxel spacings.</p> </li> </ul>"},{"location":"api_reference/functional/get/#copick.ops.get.get_tomograms","title":"copick.ops.get.get_tomograms","text":"<pre><code>get_tomograms(root: Union[str, CopickRoot], runs: Union[str, CopickRun, Iterable[str], Iterable[CopickRun], None] = None, voxel_size: Union[float, Iterable[float], None] = None, tomo_type: Union[str, Iterable[str], None] = None, parallel: bool = False, workers: Optional[int] = 8, show_progress: bool = True) -&gt; List[CopickTomogram]\n</code></pre> <p>Query tomograms from a Copick project.</p> <p>Parameters:</p> <ul> <li> <code>root</code>               (<code>Union[str, CopickRoot]</code>)           \u2013            <p>The Copick project root.</p> </li> <li> <code>runs</code>               (<code>Union[str, CopickRun, Iterable[str], Iterable[CopickRun], None]</code>, default:                   <code>None</code> )           \u2013            <p>The runs to query tomograms from. If <code>None</code>, query all runs.</p> </li> <li> <code>voxel_size</code>               (<code>Union[float, Iterable[float], None]</code>, default:                   <code>None</code> )           \u2013            <p>The voxel size of the tomograms. If <code>None</code>, query all tomograms.</p> </li> <li> <code>tomo_type</code>               (<code>Union[str, Iterable[str], None]</code>, default:                   <code>None</code> )           \u2013            <p>The type of the tomograms. If <code>None</code>, query all tomograms.</p> </li> <li> <code>parallel</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to query tomograms in parallel. Default is <code>False</code>.</p> </li> <li> <code>workers</code>               (<code>Optional[int]</code>, default:                   <code>8</code> )           \u2013            <p>The number of workers to use. Default is <code>8</code>.</p> </li> <li> <code>show_progress</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to show progress. Default is <code>True</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[CopickTomogram]</code>           \u2013            <p>A list of tomograms.</p> </li> </ul>"},{"location":"api_reference/functional/get/#copick.ops.get.get_features","title":"copick.ops.get.get_features","text":"<pre><code>get_features(root: Union[str, CopickRoot], runs: Union[str, CopickRun, Iterable[str], Iterable[CopickRun], None] = None, voxel_size: Union[float, Iterable[float], None] = None, tomo_type: Union[str, Iterable[str], None] = None, feature_type: Union[str, Iterable[str], None] = None, parallel: bool = False, workers: Optional[int] = 8, show_progress: bool = True) -&gt; List[CopickFeatures]\n</code></pre> <p>Query features from a Copick project.</p> <p>Parameters:</p> <ul> <li> <code>root</code>               (<code>Union[str, CopickRoot]</code>)           \u2013            <p>The Copick project root.</p> </li> <li> <code>runs</code>               (<code>Union[str, CopickRun, Iterable[str], Iterable[CopickRun], None]</code>, default:                   <code>None</code> )           \u2013            <p>The runs to query features from. If <code>None</code>, query all runs.</p> </li> <li> <code>voxel_size</code>               (<code>Union[float, Iterable[float], None]</code>, default:                   <code>None</code> )           \u2013            <p>The voxel size of the features. If <code>None</code>, query all features.</p> </li> <li> <code>tomo_type</code>               (<code>Union[str, Iterable[str], None]</code>, default:                   <code>None</code> )           \u2013            <p>The type of the tomograms. If <code>None</code>, query all features.</p> </li> <li> <code>feature_type</code>               (<code>Union[str, Iterable[str], None]</code>, default:                   <code>None</code> )           \u2013            <p>The type of the features. If <code>None</code>, query all features.</p> </li> <li> <code>parallel</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to query features in parallel. Default is <code>False</code>.</p> </li> <li> <code>workers</code>               (<code>Optional[int]</code>, default:                   <code>8</code> )           \u2013            <p>The number of workers to use. Default is <code>8</code>.</p> </li> <li> <code>show_progress</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to show progress. Default is <code>True</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[CopickFeatures]</code>           \u2013            <p>A list of features.</p> </li> </ul>"},{"location":"api_reference/functional/get/#copick.ops.get.get_runs","title":"copick.ops.get.get_runs","text":"<pre><code>get_runs(root: Union[str, CopickRoot], names: Union[str, Iterable[str], None] = None) -&gt; List[CopickRun]\n</code></pre> <p>Query runs from a Copick project.</p> <p>Parameters:</p> <ul> <li> <code>root</code>               (<code>Union[str, CopickRoot]</code>)           \u2013            <p>The Copick project root.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[CopickRun]</code>           \u2013            <p>A list of runs.</p> </li> </ul>"},{"location":"api_reference/functional/get/#usage-examples","title":"Usage Examples","text":""},{"location":"api_reference/functional/get/#getting-runs","title":"Getting Runs","text":"<pre><code>from copick.ops.get import get_runs\nfrom copick.impl.filesystem import CopickRootFSSpec\n\n# Open a project\nroot = CopickRootFSSpec.from_file(\"config.json\")\n\n# Get all runs\nall_runs = get_runs(root)\n\n# Get runs with specific names\nselected_runs = get_runs(root, run_names=[\"experiment_001\", \"experiment_002\"])\n\n# Get runs with query filtering\nfiltered_runs = get_runs(root, query={\"tilt_series_id\": \"12345\"})\n</code></pre>"},{"location":"api_reference/functional/get/#getting-tomograms","title":"Getting Tomograms","text":"<pre><code>from copick.ops.get import get_tomograms\n\n# Get all tomograms from specific runs\ntomograms = get_tomograms(\n    root=root,\n    run_names=[\"experiment_001\"],\n    voxel_spacings=[10.0, 20.0],\n    tomo_types=[\"wbp\", \"ctf_corrected\"]\n)\n\n# Get tomograms with user filtering\nuser_tomograms = get_tomograms(\n    root=root,\n    user_id=\"researcher_001\",\n    session_id=\"session_123\"\n)\n</code></pre>"},{"location":"api_reference/functional/get/#getting-picks","title":"Getting Picks","text":"<pre><code>from copick.ops.get import get_picks\n\n# Get picks for specific objects\nribosome_picks = get_picks(\n    root=root,\n    object_names=[\"ribosome\"],\n    user_id=\"annotation_tool\",\n    run_names=[\"experiment_001\"]\n)\n\n# Get picks with confidence filtering\nhigh_confidence_picks = get_picks(\n    root=root,\n    query={\"confidence\": {\"$gt\": 0.8}}\n)\n</code></pre>"},{"location":"api_reference/functional/get/#getting-segmentations","title":"Getting Segmentations","text":"<pre><code>from copick.ops.get import get_segmentations\n\n# Get segmentations by type\nmembrane_segmentations = get_segmentations(\n    root=root,\n    segmentation_types=[\"membrane\", \"organelle\"],\n    voxel_spacings=[10.0]\n)\n\n# Get multilabel segmentations\nmultilabel_segs = get_segmentations(\n    root=root,\n    is_multilabel=True,\n    user_id=\"segmentation_model\"\n)\n</code></pre>"},{"location":"api_reference/functional/open/","title":"Open Operations","text":"<p>The <code>copick.ops.open</code> module provides functions for opening and creating Copick projects from various sources, including configuration files and CryoET Data Portal datasets.</p>"},{"location":"api_reference/functional/open/#functions","title":"Functions","text":""},{"location":"api_reference/functional/open/#copick.ops.open.from_string","title":"copick.ops.open.from_string","text":"<pre><code>from_string(data: str) -&gt; Union[CopickRootFSSpec, CopickRootCDP]\n</code></pre> <p>Create a Copick project from a JSON string.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>str</code>)           \u2013            <p>JSON string containing the project configuration.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Union[CopickRootFSSpec, CopickRootCDP]</code>           \u2013            <p>CopickRootFSSpec or CopickRootCDP: The initialized Copick project.</p> </li> </ul>"},{"location":"api_reference/functional/open/#copick.ops.open.from_file","title":"copick.ops.open.from_file","text":"<pre><code>from_file(path: str) -&gt; Union[CopickRootFSSpec, CopickRootCDP]\n</code></pre> <p>Create a Copick project from a JSON file. Args:     path (str): Path to the JSON file containing the project configuration.</p> <p>Returns:</p> <ul> <li> <code>Union[CopickRootFSSpec, CopickRootCDP]</code>           \u2013            <p>CopickRootFSSpec or CopickRootCDP: The initialized Copick project.</p> </li> </ul>"},{"location":"api_reference/functional/open/#copick.ops.open.from_czcdp_datasets","title":"copick.ops.open.from_czcdp_datasets","text":"<pre><code>from_czcdp_datasets(dataset_ids: List[int], overlay_root: str, overlay_fs_args: Union[Dict[str, Any], None] = None, user_id: Union[str, None] = None, session_id: Union[str, None] = None, output_path: Union[str, None] = None) -&gt; CopickRootCDP\n</code></pre> <p>Create a Copick project from datasets in the CZ cryoET Data Portal.</p> <p>Parameters:</p> <ul> <li> <code>dataset_ids</code>               (<code>List[int]</code>)           \u2013            <p>List of dataset IDs to include in the project.</p> </li> <li> <code>overlay_root</code>               (<code>str</code>)           \u2013            <p>The root path to the overlay directory.</p> </li> <li> <code>overlay_fs_args</code>               (<code>Union[Dict[str, Any], None]</code>, default:                   <code>None</code> )           \u2013            <p>Arguments to pass to the overlay filesystem.</p> </li> <li> <code>user_id</code>               (<code>Union[str, None]</code>, default:                   <code>None</code> )           \u2013            <p>The user ID to use for the project.</p> </li> <li> <code>session_id</code>               (<code>Union[str, None]</code>, default:                   <code>None</code> )           \u2013            <p>The session ID to use for the project.</p> </li> <li> <code>output_path</code>               (<code>Union[str, None]</code>, default:                   <code>None</code> )           \u2013            <p>The path to write the project configuration to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CopickRootCDP</code> (              <code>CopickRootCDP</code> )          \u2013            <p>The initialized Copick project.</p> </li> </ul>"},{"location":"api_reference/functional/open/#usage-examples","title":"Usage Examples","text":""},{"location":"api_reference/functional/open/#opening-from-configuration-file","title":"Opening from Configuration File","text":"<pre><code>from copick.ops.open import from_file\n\n# Open project from configuration file\nroot = from_file(\"path/to/config.json\")\n\n# Access project data\nruns = root.runs\ntomograms = root.runs[0].voxel_spacings[0].tomograms\n</code></pre>"},{"location":"api_reference/functional/open/#opening-from-string-configuration","title":"Opening from String Configuration","text":"<pre><code>from copick.ops.open import from_string\nimport json\n\n# Create configuration as string\nconfig = {\n    \"name\": \"My Project\",\n    \"description\": \"Example project\",\n    \"version\": \"1.0.0\",\n    \"config_type\": \"filesystem\",\n    \"static_root\": \"/path/to/static\",\n    \"overlay_root\": \"/path/to/overlay\",\n    \"pickable_objects\": []\n}\n\n# Open project from string\nroot = from_string(json.dumps(config))\n</code></pre>"},{"location":"api_reference/functional/open/#opening-from-cryoet-data-portal","title":"Opening from CryoET Data Portal","text":"<pre><code>from copick.ops.open import from_czcdp_datasets\n\n# Create project from Data Portal dataset\nroot = from_czcdp_datasets(\n    dataset_ids=[10001, 10002],\n    overlay_root=\"/path/to/local/storage\",\n    config_name=\"My CryoET Project\"\n)\n\n# Access portal data with local overlay\nruns = root.runs\ntomograms = root.runs[0].voxel_spacings[0].tomograms\n</code></pre>"},{"location":"api_reference/functional/run/","title":"Run Operations","text":"<p>The <code>copick.ops.run</code> module provides utilities for parallel processing across multiple runs in Copick projects. The main function <code>map_runs</code> enables efficient execution of operations on multiple runs using thread or process-based parallelism.</p>"},{"location":"api_reference/functional/run/#functions","title":"Functions","text":""},{"location":"api_reference/functional/run/#copick.ops.run.map_runs","title":"copick.ops.run.map_runs","text":"<pre><code>map_runs(callback: Callable, root: CopickRoot, runs: Union[Iterable[str], Iterable[CopickRun]], workers: int = 8, parallelism: Literal['thread', 'process'] = 'thread', run_args: Iterable[Dict[str, Any]] = None, show_progress: bool = True, task_desc: str = None, **kwargs) -&gt; Dict[str, Any]\n</code></pre> <p>Execute a callback function on a list of runs in parallel.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>Callable</code>)           \u2013            <p>The callback function to execute. Must have the signature</p> </li> <li> <code>`callback(run</code>           \u2013            <p>CopickRun, run_args, kwargs) -&gt; Any`.</p> </li> <li> <code>root</code>               (<code>CopickRoot</code>)           \u2013            <p>The copick project root.</p> </li> <li> <code>runs</code>               (<code>Union[Iterable[str], Iterable[CopickRun]]</code>)           \u2013            <p>The list of run names or CopickRun objects to parallelize over.</p> </li> <li> <code>workers</code>               (<code>int</code>, default:                   <code>8</code> )           \u2013            <p>The number of workers (threads) to use.</p> </li> <li> <code>run_args</code>               (<code>Iterable[Dict[str, Any]]</code>, default:                   <code>None</code> )           \u2013            <p>List of run-specific arguments, must have same length as runs.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional keyword arguments to pass to the callback function.</p> </li> </ul>"},{"location":"api_reference/functional/run/#usage-examples","title":"Usage Examples","text":""},{"location":"api_reference/functional/run/#basic-parallel-processing","title":"Basic Parallel Processing","text":"<pre><code>from copick.ops.run import map_runs\nfrom copick.impl.filesystem import CopickRootFSSpec\n\n# Open a project\nroot = CopickRootFSSpec.from_file(\"config.json\")\n\n# Define a callback function\ndef process_run(run, **kwargs):\n    \"\"\"Process a single run - count picks.\"\"\"\n    pick_count = 0\n    for picks in run.picks:\n        if picks.points:\n            pick_count += len(picks.points)\n    return pick_count\n\n# Execute on multiple runs\nrun_names = [\"experiment_001\", \"experiment_002\", \"experiment_003\"]\nresults = map_runs(\n    callback=process_run,\n    root=root,\n    runs=run_names,\n    workers=4,\n    parallelism=\"thread\",\n    show_progress=True,\n    task_desc=\"Counting picks\"\n)\n\n# Results is a dictionary: {\"experiment_001\": 150, \"experiment_002\": 203, ...}\n</code></pre>"},{"location":"api_reference/functional/run/#processing-with-run-specific-arguments","title":"Processing with Run-Specific Arguments","text":"<pre><code>def segment_tomogram(run, threshold=0.5, model_path=None, **kwargs):\n    \"\"\"Segment tomograms in a run.\"\"\"\n    results = []\n    for vs in run.voxel_spacings:\n        for tomo in vs.tomograms:\n            # Perform segmentation with threshold and model\n            segmentation = perform_segmentation(tomo, threshold, model_path)\n            results.append(segmentation)\n    return results\n\n# Different parameters for each run\nrun_args = [\n    {\"threshold\": 0.3, \"model_path\": \"model_v1.pth\"},\n    {\"threshold\": 0.5, \"model_path\": \"model_v2.pth\"},\n    {\"threshold\": 0.7, \"model_path\": \"model_v1.pth\"}\n]\n\nresults = map_runs(\n    callback=segment_tomogram,\n    root=root,\n    runs=run_names,\n    run_args=run_args,\n    workers=2,\n    parallelism=\"process\",  # Use process parallelism for CPU-intensive tasks\n    show_progress=True,\n    task_desc=\"Segmenting tomograms\"\n)\n</code></pre>"},{"location":"api_reference/functional/run/#working-with-copickrun-objects","title":"Working with CopickRun Objects","text":"<pre><code># You can pass CopickRun objects directly instead of names\nruns = [root.get_run(name) for name in run_names]\n\ndef analyze_run(run, analysis_type=\"basic\", **kwargs):\n    \"\"\"Analyze various aspects of a run.\"\"\"\n    stats = {\n        \"name\": run.name,\n        \"voxel_spacings\": len(run.voxel_spacings),\n        \"tomograms\": sum(len(vs.tomograms) for vs in run.voxel_spacings),\n        \"picks\": len(run.picks),\n        \"segmentations\": len(run.segmentations)\n    }\n    return stats\n\nresults = map_runs(\n    callback=analyze_run,\n    root=root,\n    runs=runs,  # Pass CopickRun objects\n    workers=8,\n    analysis_type=\"detailed\"  # Additional kwargs\n)\n</code></pre>"},{"location":"api_reference/functional/run/#error-handling-and-logging","title":"Error Handling and Logging","text":"<pre><code>def robust_processing(run, **kwargs):\n    \"\"\"Process with error handling.\"\"\"\n    try:\n        # Simulate some processing that might fail\n        if run.name == \"problematic_run\":\n            raise ValueError(\"Simulated error\")\n\n        # Normal processing\n        return {\"status\": \"success\", \"data\": len(run.picks)}\n\n    except Exception as e:\n        # Errors are logged automatically by map_runs\n        return {\"status\": \"error\", \"error\": str(e)}\n\nresults = map_runs(\n    callback=robust_processing,\n    root=root,\n    runs=run_names,\n    workers=4,\n    show_progress=True,\n    task_desc=\"Processing with error handling\"\n)\n\n# Check results\nfor run_name, result in results.items():\n    if result is None:\n        print(f\"Run {run_name} failed completely\")\n    elif result.get(\"status\") == \"error\":\n        print(f\"Run {run_name} had error: {result['error']}\")\n    else:\n        print(f\"Run {run_name} succeeded: {result}\")\n</code></pre>"},{"location":"api_reference/functional/run/#callback-function-requirements","title":"Callback Function Requirements","text":"<p>Your callback function must follow this signature:</p> <pre><code>def callback(run: CopickRun, **run_args, **kwargs) -&gt; Any:\n    \"\"\"\n    Process a single run.\n\n    Args:\n        run: The CopickRun object to process\n        **run_args: Run-specific arguments from run_args list\n        **kwargs: Global arguments passed to map_runs\n\n    Returns:\n        Any: Result data (will be stored in results dict)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api_reference/functional/sync/","title":"Sync Operations","text":"<p>The <code>copick.ops.sync</code> module provides functions for synchronizing data between Copick projects, including picks, meshes, segmentations, and tomograms. These functions enable efficient copying and migration of annotations and volume data between different Copick projects with support for parallel processing, name mapping, and user filtering.</p>"},{"location":"api_reference/functional/sync/#core-features","title":"Core Features","text":"<ul> <li>Parallel Processing: Multi-threaded synchronization for improved performance</li> <li>Name Mapping: Flexible mapping of source names to target names for runs, objects, and users</li> <li>User Filtering: Selective synchronization based on user IDs</li> <li>Object Validation: Automatic creation of missing pickable objects in target projects</li> <li>Progress Tracking: Optional logging and progress reporting</li> <li>Error Handling: Comprehensive error reporting with detailed failure information</li> </ul>"},{"location":"api_reference/functional/sync/#functions","title":"Functions","text":""},{"location":"api_reference/functional/sync/#copick.ops.sync.sync_picks","title":"copick.ops.sync.sync_picks","text":"<pre><code>sync_picks(source_root: CopickRoot, target_root: CopickRoot, source_runs: Optional[List[str]] = None, target_runs: Optional[Dict[str, str]] = None, source_objects: Optional[List[str]] = None, target_objects: Optional[Dict[str, str]] = None, source_users: Optional[List[str]] = None, target_users: Optional[Dict[str, str]] = None, exist_ok: bool = False, max_workers: int = 4, log: bool = False) -&gt; None\n</code></pre> <p>Synchronize picks between two Copick projects.</p> <p>Parameters:</p> <ul> <li> <code>source_root</code>               (<code>CopickRoot</code>)           \u2013            <p>The source Copick project root.</p> </li> <li> <code>target_root</code>               (<code>CopickRoot</code>)           \u2013            <p>The target Copick project root.</p> </li> <li> <code>source_runs</code>               (<code>Optional[List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>The list of source run names to synchronize.</p> </li> <li> <code>target_runs</code>               (<code>Optional[Dict[str, str]]</code>, default:                   <code>None</code> )           \u2013            <p>A dictionary mapping source run names to target run names.</p> </li> <li> <code>source_objects</code>               (<code>Optional[List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>The list of source object types to synchronize.</p> </li> <li> <code>target_objects</code>               (<code>Optional[Dict[str, str]]</code>, default:                   <code>None</code> )           \u2013            <p>The dictionary mapping source object types to target types.</p> </li> <li> <code>source_users</code>               (<code>Optional[List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>The list of source user IDs to synchronize. If None, all users are synced.</p> </li> <li> <code>target_users</code>               (<code>Optional[Dict[str, str]]</code>, default:                   <code>None</code> )           \u2013            <p>The dictionary mapping source user IDs to target user IDs.</p> </li> <li> <code>exist_ok</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite existing picks in the target project.</p> </li> <li> <code>max_workers</code>               (<code>int</code>, default:                   <code>4</code> )           \u2013            <p>The maximum number of worker threads to use for synchronization.</p> </li> <li> <code>log</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to log the synchronization process.</p> </li> </ul>"},{"location":"api_reference/functional/sync/#copick.ops.sync.sync_meshes","title":"copick.ops.sync.sync_meshes","text":"<pre><code>sync_meshes(source_root: CopickRoot, target_root: CopickRoot, source_runs: Optional[List[str]] = None, target_runs: Optional[Dict[str, str]] = None, source_objects: Optional[List[str]] = None, target_objects: Optional[Dict[str, str]] = None, source_users: Optional[List[str]] = None, target_users: Optional[Dict[str, str]] = None, exist_ok: bool = False, max_workers: int = 4, log: bool = False) -&gt; None\n</code></pre> <p>Synchronize meshes between two Copick projects.</p> <p>Parameters:</p> <ul> <li> <code>source_root</code>               (<code>CopickRoot</code>)           \u2013            <p>The source Copick project root.</p> </li> <li> <code>target_root</code>               (<code>CopickRoot</code>)           \u2013            <p>The target Copick project root.</p> </li> <li> <code>source_runs</code>               (<code>Optional[List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>The list of source run names to synchronize.</p> </li> <li> <code>target_runs</code>               (<code>Optional[Dict[str, str]]</code>, default:                   <code>None</code> )           \u2013            <p>A dictionary mapping source run names to target run names.</p> </li> <li> <code>source_objects</code>               (<code>Optional[List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>The list of source object types to synchronize.</p> </li> <li> <code>target_objects</code>               (<code>Optional[Dict[str, str]]</code>, default:                   <code>None</code> )           \u2013            <p>The dictionary mapping source object types to target types.</p> </li> <li> <code>source_users</code>               (<code>Optional[List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>The list of source user IDs to synchronize. If None, all users are synced.</p> </li> <li> <code>target_users</code>               (<code>Optional[Dict[str, str]]</code>, default:                   <code>None</code> )           \u2013            <p>The dictionary mapping source user IDs to target user IDs.</p> </li> <li> <code>exist_ok</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite existing meshes in the target project.</p> </li> <li> <code>max_workers</code>               (<code>int</code>, default:                   <code>4</code> )           \u2013            <p>The maximum number of worker threads to use for synchronization.</p> </li> <li> <code>log</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to log the synchronization process.</p> </li> </ul>"},{"location":"api_reference/functional/sync/#copick.ops.sync.sync_segmentations","title":"copick.ops.sync.sync_segmentations","text":"<pre><code>sync_segmentations(source_root: CopickRoot, target_root: CopickRoot, source_runs: Optional[List[str]] = None, target_runs: Optional[Dict[str, str]] = None, voxel_spacings: Optional[List[float]] = None, source_names: Optional[List[str]] = None, target_names: Optional[Dict[str, str]] = None, source_users: Optional[List[str]] = None, target_users: Optional[Dict[str, str]] = None, exist_ok: bool = False, max_workers: int = 4, log: bool = False) -&gt; None\n</code></pre> <p>Synchronize segmentations between two Copick projects.</p> <p>Parameters:</p> <ul> <li> <code>source_root</code>               (<code>CopickRoot</code>)           \u2013            <p>The source Copick project root.</p> </li> <li> <code>target_root</code>               (<code>CopickRoot</code>)           \u2013            <p>The target Copick project root.</p> </li> <li> <code>source_runs</code>               (<code>Optional[List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>The list of source run names to synchronize.</p> </li> <li> <code>target_runs</code>               (<code>Optional[Dict[str, str]]</code>, default:                   <code>None</code> )           \u2013            <p>A dictionary mapping source run names to target run names.</p> </li> <li> <code>voxel_spacings</code>               (<code>Optional[List[float]]</code>, default:                   <code>None</code> )           \u2013            <p>The voxel spacings to consider for synchronization.</p> </li> <li> <code>source_names</code>               (<code>Optional[List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>The list of source segmentation names to synchronize. If None, all segmentations are synced.</p> </li> <li> <code>target_names</code>               (<code>Optional[Dict[str, str]]</code>, default:                   <code>None</code> )           \u2013            <p>The dictionary mapping source segmentation names to target names.</p> </li> <li> <code>source_users</code>               (<code>Optional[List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>The list of source user IDs to synchronize. If None, all users are synced.</p> </li> <li> <code>target_users</code>               (<code>Optional[Dict[str, str]]</code>, default:                   <code>None</code> )           \u2013            <p>The dictionary mapping source user IDs to target user IDs.</p> </li> <li> <code>exist_ok</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite existing segmentations in the target project.</p> </li> <li> <code>max_workers</code>               (<code>int</code>, default:                   <code>4</code> )           \u2013            <p>The maximum number of worker threads to use for synchronization.</p> </li> <li> <code>log</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to log the synchronization process.</p> </li> </ul>"},{"location":"api_reference/functional/sync/#copick.ops.sync.sync_tomograms","title":"copick.ops.sync.sync_tomograms","text":"<pre><code>sync_tomograms(source_root: CopickRoot, target_root: CopickRoot, source_runs: Optional[List[str]] = None, target_runs: Optional[Dict[str, str]] = None, voxel_spacings: Optional[List[float]] = None, source_tomo_types: Optional[List[str]] = None, target_tomo_types: Optional[Dict[str, str]] = None, exist_ok: bool = False, max_workers: int = 4, log: bool = False) -&gt; None\n</code></pre> <p>Synchronize tomograms between two Copick projects.</p> <p>Parameters:</p> <ul> <li> <code>source_root</code>               (<code>CopickRoot</code>)           \u2013            <p>The source Copick project root.</p> </li> <li> <code>target_root</code>               (<code>CopickRoot</code>)           \u2013            <p>The target Copick project root.</p> </li> <li> <code>source_runs</code>               (<code>Optional[List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>The list of source run names to synchronize.</p> </li> <li> <code>target_runs</code>               (<code>Optional[Dict[str, str]]</code>, default:                   <code>None</code> )           \u2013            <p>A dictionary mapping source run names to target run names.</p> </li> <li> <code>voxel_spacings</code>               (<code>Optional[List[float]]</code>, default:                   <code>None</code> )           \u2013            <p>The voxel spacings to consider for synchronization.</p> </li> <li> <code>source_tomo_types</code>               (<code>Optional[List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>The list of source tomogram types to synchronize.</p> </li> <li> <code>target_tomo_types</code>               (<code>Optional[Dict[str, str]]</code>, default:                   <code>None</code> )           \u2013            <p>The dictionary mapping source tomogram types to target types.</p> </li> <li> <code>exist_ok</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite existing tomograms in the target project.</p> </li> <li> <code>max_workers</code>               (<code>int</code>, default:                   <code>4</code> )           \u2013            <p>The maximum number of worker threads to use for synchronization.</p> </li> <li> <code>log</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to log the synchronization process.</p> </li> </ul>"},{"location":"api_reference/functional/sync/#usage-examples","title":"Usage Examples","text":""},{"location":"api_reference/functional/sync/#basic-synchronization","title":"Basic Synchronization","text":"<pre><code>import copick\nfrom copick.ops.sync import sync_picks\n\n# Load source and target projects\nsource_root = copick.from_file(\"source_config.json\")\ntarget_root = copick.from_file(\"target_config.json\")\n\n# Sync all picks from all runs\nsync_picks(\n    source_root=source_root,\n    target_root=target_root,\n    log=True\n)\n</code></pre>"},{"location":"api_reference/functional/sync/#selective-synchronization-with-name-mapping","title":"Selective Synchronization with Name Mapping","text":"<pre><code># Sync specific runs with name mapping\nsync_picks(\n    source_root=source_root,\n    target_root=target_root,\n    source_runs=[\"run1\", \"run2\"],\n    target_runs={\"run1\": \"experiment_A\", \"run2\": \"experiment_B\"},\n    source_objects=[\"ribosome\", \"membrane\"],\n    target_objects={\"ribosome\": \"ribo\", \"membrane\": \"mem\"},\n    log=True\n)\n</code></pre>"},{"location":"api_reference/functional/sync/#user-specific-synchronization","title":"User-Specific Synchronization","text":"<pre><code># Sync picks from specific users with user ID mapping\nsync_picks(\n    source_root=source_root,\n    target_root=target_root,\n    source_users=[\"user123\", \"user456\"],\n    target_users={\"user123\": \"analyst1\", \"user456\": \"analyst2\"},\n    exist_ok=True,  # Allow overwriting existing picks\n    max_workers=8,  # Use more threads for faster processing\n    log=True\n)\n</code></pre>"},{"location":"api_reference/functional/sync/#synchronizing-segmentations-with-voxel-spacing-filtering","title":"Synchronizing Segmentations with Voxel Spacing Filtering","text":"<pre><code>from copick.ops.sync import sync_segmentations\n\n# Sync segmentations for specific voxel spacings\nsync_segmentations(\n    source_root=source_root,\n    target_root=target_root,\n    voxel_spacings=[10.0, 20.0],  # Only sync these voxel spacings\n    source_names=[\"membrane\", \"organelle\"],\n    target_names={\"membrane\": \"cell_membrane\", \"organelle\": \"mitochondria\"},\n    log=True\n)\n</code></pre>"},{"location":"api_reference/functional/sync/#synchronizing-tomograms-with-type-mapping","title":"Synchronizing Tomograms with Type Mapping","text":"<pre><code>from copick.ops.sync import sync_tomograms\n\n# Sync tomograms with type mapping\nsync_tomograms(\n    source_root=source_root,\n    target_root=target_root,\n    voxel_spacings=[10.0],\n    source_tomo_types=[\"wbp\", \"raw\"],\n    target_tomo_types={\"wbp\": \"filtered\", \"raw\": \"original\"},\n    exist_ok=True,\n    log=True\n)\n</code></pre>"},{"location":"api_reference/functional/sync/#complete-multi-data-type-synchronization","title":"Complete Multi-Data Type Synchronization","text":"<pre><code>from copick.ops.sync import sync_picks, sync_meshes, sync_segmentations\n\n# Sync multiple data types in sequence\ndata_types = [\n    (sync_picks, {}),\n    (sync_meshes, {}),\n    (sync_segmentations, {\"voxel_spacings\": [10.0, 20.0]})\n]\n\ncommon_args = {\n    \"source_root\": source_root,\n    \"target_root\": target_root,\n    \"source_runs\": [\"run1\", \"run2\"],\n    \"target_runs\": {\"run1\": \"exp1\", \"run2\": \"exp2\"},\n    \"max_workers\": 6,\n    \"log\": True\n}\n\nfor sync_func, extra_args in data_types:\n    print(f\"Synchronizing {sync_func.__name__}...\")\n    sync_func(**common_args, **extra_args)\n    print(f\"Completed {sync_func.__name__}\")\n</code></pre>"},{"location":"api_reference/functional/sync/#common-patterns","title":"Common Patterns","text":""},{"location":"api_reference/functional/sync/#name-mapping-syntax","title":"Name Mapping Syntax","text":"<p>All synchronization functions support flexible name mapping using dictionaries:</p> <pre><code># Run name mapping\ntarget_runs = {\n    \"source_run1\": \"target_run1\",\n    \"source_run2\": \"target_run2\"\n}\n\n# Object name mapping\ntarget_objects = {\n    \"ribosome\": \"large_ribosomal_subunit\",\n    \"membrane\": \"plasma_membrane\",\n    \"vesicle\": \"transport_vesicle\"\n}\n\n# User ID mapping\ntarget_users = {\n    \"original_user\": \"new_user_id\",\n    \"temp_user\": \"permanent_user\"\n}\n</code></pre>"},{"location":"api_reference/functional/sync/#error-handling-and-logging","title":"Error Handling and Logging","text":"<pre><code>import logging\n\n# Configure logging for detailed output\nlogging.basicConfig(level=logging.INFO)\n\ntry:\n    sync_picks(\n        source_root=source_root,\n        target_root=target_root,\n        log=True  # Enable verbose logging\n    )\nexcept Exception as e:\n    print(f\"Synchronization failed: {e}\")\n    # Check logs for detailed error information\n</code></pre>"},{"location":"api_reference/functional/sync/#performance-optimization","title":"Performance Optimization","text":"<pre><code># Optimize for large datasets\nsync_picks(\n    source_root=source_root,\n    target_root=target_root,\n    max_workers=12,  # Increase parallelism\n    exist_ok=True,   # Skip duplicate checks\n    log=False        # Reduce logging overhead\n)\n</code></pre>"},{"location":"api_reference/functional/sync/#integration-with-cli","title":"Integration with CLI","text":"<p>The sync operations are also available through the CLI interface:</p> <pre><code># Basic synchronization\ncopick sync picks -c source_config.json --target-config target_config.json\n\n# With name mapping and user filtering\ncopick sync picks -c source_config.json --target-config target_config.json \\\n    --source-runs \"run1,run2\" \\\n    --target-runs \"run1:exp1,run2:exp2\" \\\n    --source-users \"user1,user2\" \\\n    --target-users \"user1:analyst1,user2:analyst2\" \\\n    --log\n\n# From CryoET Data Portal\ncopick sync picks \\\n    --source-dataset-ids \"12345,67890\" \\\n    --target-config target_config.json \\\n    --log\n</code></pre>"},{"location":"api_reference/implementations/Dataportal/","title":"Data Portal","text":"<p>The filesystem implementation is a concrete implementation of the abstract copick API that reads data from the cryoET Data Portal and reads/writes data to/from any storage supported by <code>fsspec</code>. The filesystem implementation is defined in the <code>copick.impl.cryoet_data_portal</code> module.</p>"},{"location":"api_reference/implementations/Dataportal/#metadata-models","title":"Metadata Models","text":""},{"location":"api_reference/implementations/Dataportal/#copick.impl.cryoet_data_portal.CopickConfigCDP","title":"copick.impl.cryoet_data_portal.CopickConfigCDP","text":"<p>               Bases: <code>CopickConfig</code></p>"},{"location":"api_reference/implementations/Dataportal/#data-entities","title":"Data Entities","text":""},{"location":"api_reference/implementations/Dataportal/#copick.impl.cryoet_data_portal.CopickRootCDP","title":"copick.impl.cryoet_data_portal.CopickRootCDP","text":"<p>               Bases: <code>CopickRoot</code></p>"},{"location":"api_reference/implementations/Dataportal/#copick.impl.cryoet_data_portal.CopickObjectCDP","title":"copick.impl.cryoet_data_portal.CopickObjectCDP","text":"<p>               Bases: <code>CopickObjectOverlay</code></p>"},{"location":"api_reference/implementations/Dataportal/#copick.impl.cryoet_data_portal.CopickRunCDP","title":"copick.impl.cryoet_data_portal.CopickRunCDP","text":"<p>               Bases: <code>CopickRunOverlay</code></p>"},{"location":"api_reference/implementations/Dataportal/#copick.impl.cryoet_data_portal.CopickRunCDP.get_picks","title":"get_picks","text":"<pre><code>get_picks(object_name: str = None, user_id: str = None, session_id: str = None, portal_meta_query: Dict[str, Any] = None, portal_author_query: List[str] = None) -&gt; List[CopickPicksCDP]\n</code></pre> <p>Get picks by name, user_id or session_id (or combinations). Portal metadata are compared for equality. Portal authors are checked for inclusion in the full author list.</p> <p>Parameters:</p> <ul> <li> <code>object_name</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Name of the object to search for.</p> </li> <li> <code>user_id</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>User ID to search for.</p> </li> <li> <code>session_id</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Session ID to search for.</p> </li> <li> <code>portal_meta_query</code>               (<code>Dict[str, Any]</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of values to compare against portal metadata of this annotation. Allowed keys are the scalar fields of cryoet_data_portal.Annotation</p> </li> <li> <code>portal_author_query</code>               (<code>List[str]</code>, default:                   <code>None</code> )           \u2013            <p>List of author names. Segmentations are included if this author is in the portal annotation's author list.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[CopickPicksCDP]</code>           \u2013            <p>List[CopickPicks]: List of picks that match the search criteria.</p> </li> </ul>"},{"location":"api_reference/implementations/Dataportal/#copick.impl.cryoet_data_portal.CopickRunCDP.get_segmentations","title":"get_segmentations","text":"<pre><code>get_segmentations(user_id: str = None, session_id: str = None, is_multilabel: bool = None, name: str = None, voxel_size: float = None, portal_meta_query: Dict[str, Any] = None, portal_author_query: List[str] = None) -&gt; List[CopickSegmentationCDP]\n</code></pre> <p>Get segmentations by user_id, session_id, name, type or voxel_size (or combinations) and portal metadata and authors. Portal metadata are compared for equality. Portal authors are checked for inclusion in the full author list.</p> <p>Parameters:</p> <ul> <li> <code>user_id</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>User ID to search for.</p> </li> <li> <code>session_id</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Session ID to search for.</p> </li> <li> <code>is_multilabel</code>               (<code>bool</code>, default:                   <code>None</code> )           \u2013            <p>Whether the segmentation is multilabel or not.</p> </li> <li> <code>name</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Name of the segmentation to search for.</p> </li> <li> <code>voxel_size</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>Voxel size to search for.</p> </li> <li> <code>portal_meta_query</code>               (<code>Dict[str, Any]</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of values to compare against portal metadata of this annotation. Allowed keys are the scalar fields of cryoet_data_portal.Annotation</p> </li> <li> <code>portal_author_query</code>               (<code>List[str]</code>, default:                   <code>None</code> )           \u2013            <p>List of author names. Segmentations are included if this author is in the portal annotation's author list.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[CopickSegmentationCDP]</code>           \u2013            <p>List[CopickSegmentation]: List of segmentations that match the search criteria.</p> </li> </ul>"},{"location":"api_reference/implementations/Dataportal/#copick.impl.cryoet_data_portal.CopickRunCDP.ensure","title":"ensure","text":"<pre><code>ensure(create: bool = False) -&gt; bool\n</code></pre> <p>Checks if the run record exists in the static or overlay directory, optionally creating it in the overlay filesystem if it does not.</p> <p>Parameters:</p> <ul> <li> <code>create</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to create the run record if it does not exist.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the run record exists, False otherwise.</p> </li> </ul>"},{"location":"api_reference/implementations/Dataportal/#copick.impl.cryoet_data_portal.CopickPicksCDP","title":"copick.impl.cryoet_data_portal.CopickPicksCDP","text":"<p>               Bases: <code>CopickPicksOverlay</code></p>"},{"location":"api_reference/implementations/Dataportal/#copick.impl.cryoet_data_portal.CopickMeshCDP","title":"copick.impl.cryoet_data_portal.CopickMeshCDP","text":"<p>               Bases: <code>CopickMeshOverlay</code></p>"},{"location":"api_reference/implementations/Dataportal/#copick.impl.cryoet_data_portal.CopickSegmentationCDP","title":"copick.impl.cryoet_data_portal.CopickSegmentationCDP","text":"<p>               Bases: <code>CopickSegmentationOverlay</code></p>"},{"location":"api_reference/implementations/Dataportal/#copick.impl.cryoet_data_portal.CopickVoxelSpacingCDP","title":"copick.impl.cryoet_data_portal.CopickVoxelSpacingCDP","text":"<p>               Bases: <code>CopickVoxelSpacingOverlay</code></p>"},{"location":"api_reference/implementations/Dataportal/#copick.impl.cryoet_data_portal.CopickVoxelSpacingCDP.ensure","title":"ensure","text":"<pre><code>ensure(create: bool = False) -&gt; bool\n</code></pre> <p>Checks if the voxel spacing record exists in the static or overlay directory, optionally creating it in the overlay filesystem if it does not.</p> <p>Parameters:</p> <ul> <li> <code>create</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to create the voxel spacing record if it does not exist.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the voxel spacing record exists, False otherwise.</p> </li> </ul>"},{"location":"api_reference/implementations/Dataportal/#copick.impl.cryoet_data_portal.CopickVoxelSpacingCDP.get_tomograms","title":"get_tomograms","text":"<pre><code>get_tomograms(tomo_type: str, portal_meta_query: Dict[str, Any] = None, portal_author_query: List[str] = None) -&gt; List[CopickTomogramCDP]\n</code></pre> <p>Get a tomogram by type. Portal metadata are compared for equality. Authors are compared for inclusion.</p> <p>Parameters:</p> <ul> <li> <code>tomo_type</code>               (<code>str</code>)           \u2013            <p>The type of tomogram to get. For portal tomograms, this is <code>cryoet_data_portal.Tomogram.reconstruction_method.</code></p> </li> <li> <code>portal_meta_query</code>               (<code>Dict[str, Any]</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of values to compare against portal metadata of this tomogram. Allowed keys are the scalar fields of cryoet_data_portal.Tomogram</p> </li> <li> <code>portal_author_query</code>               (<code>List[str]</code>, default:                   <code>None</code> )           \u2013            <p>List of author names. Tomograms are included if this author is in the portal annotation's author list.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[CopickTomogramCDP]</code>           \u2013            <p>List[CopickTomogram]: The list of tomograms that match the query.</p> </li> </ul>"},{"location":"api_reference/implementations/Dataportal/#copick.impl.cryoet_data_portal.CopickTomogramCDP","title":"copick.impl.cryoet_data_portal.CopickTomogramCDP","text":"<p>               Bases: <code>CopickTomogramOverlay</code></p>"},{"location":"api_reference/implementations/Dataportal/#copick.impl.cryoet_data_portal.CopickTomogramCDP.tomo_type","title":"tomo_type","text":"<pre><code>tomo_type: str\n</code></pre> <p>The type of tomogram. For data portal tomograms, this is derived as <code>cryoet_data_portal.Tomogram.reconstruction_method + \"-\" + cryoet_data_portal.Tomogram.processing + [\"-\" + cryoet_data_portal.Tomogram.processing_software + \"-\" + cryoet_data_portal.Tomogram.ctf_corrected</code>], where <code>cryoet_data_portal.Tomogram.processing_software</code> and <code>cryoet_data_portal.Tomogram.ctf_corrected</code> are discarded if null in the database.</p>"},{"location":"api_reference/implementations/Dataportal/#copick.impl.cryoet_data_portal.CopickTomogramCDP.portal_tomo","title":"portal_tomo","text":"<pre><code>portal_tomo: bool\n</code></pre> <p>Whether this tomogram is from the portal or not.</p>"},{"location":"api_reference/implementations/Dataportal/#copick.impl.cryoet_data_portal.CopickFeaturesCDP","title":"copick.impl.cryoet_data_portal.CopickFeaturesCDP","text":"<p>               Bases: <code>CopickFeaturesOverlay</code></p>"},{"location":"api_reference/implementations/Filesystem/","title":"File System","text":"<p>The filesystem implementation is a concrete implementation of the abstract copick API that reads and writes data to/from any storage supported by <code>fsspec</code>. The filesystem implementation is defined in the <code>copick.impl.filesystem</code> module.</p>"},{"location":"api_reference/implementations/Filesystem/#metadata-models","title":"Metadata Models","text":""},{"location":"api_reference/implementations/Filesystem/#copick.impl.filesystem.CopickConfigFSSpec","title":"copick.impl.filesystem.CopickConfigFSSpec","text":"<p>               Bases: <code>CopickConfig</code></p> <p>Copick configuration for fsspec-based storage.</p> <p>Attributes:</p> <ul> <li> <code>overlay_root</code>               (<code>str</code>)           \u2013            <p>The root URL for the overlay storage.</p> </li> <li> <code>static_root</code>               (<code>Optional[str]</code>)           \u2013            <p>The root URL for the static storage.</p> </li> <li> <code>overlay_fs_args</code>               (<code>Optional[Dict[str, Any]]</code>)           \u2013            <p>Additional arguments for the overlay filesystem.</p> </li> <li> <code>static_fs_args</code>               (<code>Optional[Dict[str, Any]]</code>)           \u2013            <p>Additional arguments for the static filesystem.</p> </li> </ul>"},{"location":"api_reference/implementations/Filesystem/#data-entities","title":"Data Entities","text":""},{"location":"api_reference/implementations/Filesystem/#copick.impl.filesystem.CopickRootFSSpec","title":"copick.impl.filesystem.CopickRootFSSpec","text":"<p>               Bases: <code>CopickRoot</code></p> <p>CopickRoot class backed by fspec storage.</p> <p>Attributes:</p> <ul> <li> <code>fs_overlay</code>               (<code>AbstractFileSystem</code>)           \u2013            <p>The filesystem for the overlay storage.</p> </li> <li> <code>fs_static</code>               (<code>Optional[AbstractFileSystem]</code>)           \u2013            <p>The filesystem for the static storage.</p> </li> <li> <code>root_overlay</code>               (<code>str</code>)           \u2013            <p>The root path for the overlay storage.</p> </li> <li> <code>root_static</code>               (<code>Optional[str]</code>)           \u2013            <p>The root path for the static storage.</p> </li> </ul>"},{"location":"api_reference/implementations/Filesystem/#copick.impl.filesystem.CopickRootFSSpec.__init__","title":"__init__","text":"<pre><code>__init__(config: CopickConfigFSSpec)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>CopickConfigFSSpec</code>)           \u2013            <p>Copick configuration for fsspec-based storage.</p> </li> </ul>"},{"location":"api_reference/implementations/Filesystem/#copick.impl.filesystem.CopickRootFSSpec.from_file","title":"from_file","text":"<pre><code>from_file(path: str) -&gt; CopickRootFSSpec\n</code></pre> <p>Initialize a CopickRootFSSpec from a configuration file on disk.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>Path to the configuration file on disk.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CopickRootFSSpec</code> (              <code>CopickRootFSSpec</code> )          \u2013            <p>The initialized CopickRootFSSpec object.</p> </li> </ul>"},{"location":"api_reference/implementations/Filesystem/#copick.impl.filesystem.CopickObjectFSSpec","title":"copick.impl.filesystem.CopickObjectFSSpec","text":"<p>               Bases: <code>CopickObjectOverlay</code></p> <p>CopickObject class backed by fsspec storage.</p> <p>Attributes:</p> <ul> <li> <code>static_path</code>               (<code>str</code>)           \u2013            <p>The path to the object on the static source.</p> </li> <li> <code>overlay_path</code>               (<code>str</code>)           \u2013            <p>The path to the object on the overlay source.</p> </li> <li> <code>fs_static</code>               (<code>AbstractFileSystem</code>)           \u2013            <p>The filesystem for the static source.</p> </li> <li> <code>fs_overlay</code>               (<code>AbstractFileSystem</code>)           \u2013            <p>The filesystem for the overlay source.</p> </li> </ul>"},{"location":"api_reference/implementations/Filesystem/#copick.impl.filesystem.CopickObjectFSSpec.zarr","title":"zarr","text":"<pre><code>zarr() -&gt; Union[None, zarr.storage.FSStore]\n</code></pre> <p>Get the zarr store for the object.</p> <p>Returns:</p> <ul> <li> <code>Union[None, FSStore]</code>           \u2013            <p>Union[None, zarr.storage.FSStore]: The zarr store for the object, or None if the object is not a particle.</p> </li> </ul>"},{"location":"api_reference/implementations/Filesystem/#copick.impl.filesystem.CopickRunFSSpec","title":"copick.impl.filesystem.CopickRunFSSpec","text":"<p>               Bases: <code>CopickRunOverlay</code></p> <p>CopickRun class backed by fsspec storage.</p> <p>Attributes:</p> <ul> <li> <code>static_path</code>               (<code>str</code>)           \u2013            <p>The path to the run on the static source.</p> </li> <li> <code>overlay_path</code>               (<code>str</code>)           \u2013            <p>The path to the run on the overlay source.</p> </li> <li> <code>fs_static</code>               (<code>AbstractFileSystem</code>)           \u2013            <p>The filesystem containing the run on the static source.</p> </li> <li> <code>fs_overlay</code>               (<code>AbstractFileSystem</code>)           \u2013            <p>The filesystem containing the run on the overlay source.</p> </li> <li> <code>static_is_overlay</code>               (<code>bool</code>)           \u2013            <p>Whether the static and overlay sources are the same.</p> </li> </ul>"},{"location":"api_reference/implementations/Filesystem/#copick.impl.filesystem.CopickRunFSSpec.ensure","title":"ensure","text":"<pre><code>ensure(create: bool = False) -&gt; bool\n</code></pre> <p>Checks if the run record exists in the static or overlay directory, optionally creating it in the overlay filesystem if it does not.</p> <p>Parameters:</p> <ul> <li> <code>create</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to create the run record if it does not exist.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the run record exists, False otherwise.</p> </li> </ul>"},{"location":"api_reference/implementations/Filesystem/#copick.impl.filesystem.CopickPicksFSSpec","title":"copick.impl.filesystem.CopickPicksFSSpec","text":"<p>               Bases: <code>CopickPicksOverlay</code></p> <p>CopickPicks class backed by fsspec storage.</p> <p>Attributes:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path to the picks file.</p> </li> <li> <code>directory</code>               (<code>str</code>)           \u2013            <p>The directory containing the picks file.</p> </li> <li> <code>fs</code>               (<code>AbstractFileSystem</code>)           \u2013            <p>The filesystem containing the picks file.</p> </li> </ul>"},{"location":"api_reference/implementations/Filesystem/#copick.impl.filesystem.CopickMeshFSSpec","title":"copick.impl.filesystem.CopickMeshFSSpec","text":"<p>               Bases: <code>CopickMeshOverlay</code></p> <p>CopickMesh class backed by fspec storage.</p> <p>Attributes:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path to the mesh file.</p> </li> <li> <code>directory</code>               (<code>str</code>)           \u2013            <p>The directory containing the mesh file.</p> </li> <li> <code>fs</code>               (<code>AbstractFileSystem</code>)           \u2013            <p>The filesystem containing the mesh file.</p> </li> </ul>"},{"location":"api_reference/implementations/Filesystem/#copick.impl.filesystem.CopickSegmentationFSSpec","title":"copick.impl.filesystem.CopickSegmentationFSSpec","text":"<p>               Bases: <code>CopickSegmentationOverlay</code></p> <p>CopickSegmentation class backed by fsspec storage.</p> <p>Attributes:</p> <ul> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>The filename of the segmentation file.</p> </li> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path to the segmentation file.</p> </li> <li> <code>fs</code>               (<code>AbstractFileSystem</code>)           \u2013            <p>The filesystem containing the segmentation file.</p> </li> </ul>"},{"location":"api_reference/implementations/Filesystem/#copick.impl.filesystem.CopickSegmentationFSSpec.zarr","title":"zarr","text":"<pre><code>zarr() -&gt; zarr.storage.FSStore\n</code></pre> <p>Get the zarr store for the segmentation object.</p> <p>Returns:</p> <ul> <li> <code>FSStore</code>           \u2013            <p>zarr.storage.FSStore: The zarr store for the segmentation object.</p> </li> </ul>"},{"location":"api_reference/implementations/Filesystem/#copick.impl.filesystem.CopickVoxelSpacingFSSpec","title":"copick.impl.filesystem.CopickVoxelSpacingFSSpec","text":"<p>               Bases: <code>CopickVoxelSpacingOverlay</code></p> <p>CopickVoxelSpacing class backed by fsspec storage.</p> <p>Attributes:</p> <ul> <li> <code>static_path</code>               (<code>str</code>)           \u2013            <p>The path to the voxel spacing on the static source.</p> </li> <li> <code>overlay_path</code>               (<code>str</code>)           \u2013            <p>The path to the voxel spacing on the overlay source.</p> </li> <li> <code>fs_static</code>               (<code>AbstractFileSystem</code>)           \u2013            <p>The filesystem containing the voxel spacing on the static source.</p> </li> <li> <code>fs_overlay</code>               (<code>AbstractFileSystem</code>)           \u2013            <p>The filesystem containing the voxel spacing on the overlay source.</p> </li> <li> <code>static_is_overlay</code>               (<code>bool</code>)           \u2013            <p>Whether the static and overlay sources are the same.</p> </li> </ul>"},{"location":"api_reference/implementations/Filesystem/#copick.impl.filesystem.CopickVoxelSpacingFSSpec.ensure","title":"ensure","text":"<pre><code>ensure(create: bool = False) -&gt; bool\n</code></pre> <p>Checks if the voxel spacing record exists in the static or overlay directory, optionally creating it in the overlay filesystem if it does not.</p> <p>Parameters:</p> <ul> <li> <code>create</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to create the voxel spacing record if it does not exist.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the voxel spacing record exists, False otherwise.</p> </li> </ul>"},{"location":"api_reference/implementations/Filesystem/#copick.impl.filesystem.CopickTomogramFSSpec","title":"copick.impl.filesystem.CopickTomogramFSSpec","text":"<p>               Bases: <code>CopickTomogramOverlay</code></p> <p>CopickTomogram class backed by fsspec storage.</p> <p>Attributes:</p> <ul> <li> <code>static_path</code>               (<code>str</code>)           \u2013            <p>The path to the tomogram on the static source.</p> </li> <li> <code>overlay_path</code>               (<code>str</code>)           \u2013            <p>The path to the tomogram on the overlay source.</p> </li> <li> <code>static_stem</code>               (<code>str</code>)           \u2013            <p>The stem of the tomogram on the static source.</p> </li> <li> <code>overlay_stem</code>               (<code>str</code>)           \u2013            <p>The stem of the tomogram on the overlay source.</p> </li> <li> <code>fs_static</code>               (<code>AbstractFileSystem</code>)           \u2013            <p>The filesystem containing the tomogram on the static source.</p> </li> <li> <code>fs_overlay</code>               (<code>AbstractFileSystem</code>)           \u2013            <p>The filesystem containing the tomogram on the overlay source.</p> </li> <li> <code>static_is_overlay</code>               (<code>bool</code>)           \u2013            <p>Whether the static and overlay sources are the same.</p> </li> </ul>"},{"location":"api_reference/implementations/Filesystem/#copick.impl.filesystem.CopickTomogramFSSpec.zarr","title":"zarr","text":"<pre><code>zarr() -&gt; zarr.storage.FSStore\n</code></pre> <p>Get the zarr store for the tomogram object.</p> <p>Returns:</p> <ul> <li> <code>FSStore</code>           \u2013            <p>zarr.storage.FSStore: The zarr store for the tomogram object.</p> </li> </ul>"},{"location":"api_reference/implementations/Filesystem/#copick.impl.filesystem.CopickFeaturesFSSpec","title":"copick.impl.filesystem.CopickFeaturesFSSpec","text":"<p>               Bases: <code>CopickFeaturesOverlay</code></p> <p>CopickFeatures class backed by fsspec storage.</p> <p>Attributes:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path to the features file.</p> </li> <li> <code>fs</code>               (<code>AbstractFileSystem</code>)           \u2013            <p>The filesystem containing the features file.</p> </li> </ul>"},{"location":"api_reference/implementations/Filesystem/#copick.impl.filesystem.CopickFeaturesFSSpec.zarr","title":"zarr","text":"<pre><code>zarr() -&gt; zarr.storage.FSStore\n</code></pre> <p>Get the zarr store for the features object.</p> <p>Returns:</p> <ul> <li> <code>FSStore</code>           \u2013            <p>zarr.storage.FSStore: The zarr store for the features object.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/","title":"Overlay","text":"<p>The overlay implementation is an extension of the abstract copick API implementation that adds methods to seamlessly overlay data from two different sources. Each overlay implementation is a subclass of the corresponding abstract data entity and implements methods to overlay data from two sources. The overlay implementations are defined in the <code>copick.impl.overlay</code> module.</p> <p>One source is considered read-only ('static'), while the other source is considered read-write ('overlay').</p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickRunOverlay","title":"copick.impl.overlay.CopickRunOverlay","text":"<p>               Bases: <code>CopickRun</code></p> <p>CopickRun class that queries two different storage locations for runs. The first location is read-only (static) and the second location is writable (overlay).</p>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickRunOverlay._query_static_voxel_spacings","title":"_query_static_voxel_spacings","text":"<pre><code>_query_static_voxel_spacings() -&gt; List[CopickVoxelSpacingOverlay]\n</code></pre> <p>Override to query the static source for the voxel spacings. All returned voxel spacings must be read-only.</p> <p>Returns:</p> <ul> <li> <code>List[CopickVoxelSpacingOverlay]</code>           \u2013            <p>List[CopickVoxelSpacingOverlay]: List of read-only voxel spacings.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickRunOverlay._query_overlay_voxel_spacings","title":"_query_overlay_voxel_spacings","text":"<pre><code>_query_overlay_voxel_spacings() -&gt; List[CopickVoxelSpacingOverlay]\n</code></pre> <p>Override to query the overlay source for the voxel spacings.</p> <p>Returns:</p> <ul> <li> <code>List[CopickVoxelSpacingOverlay]</code>           \u2013            <p>List[CopickVoxelSpacingOverlay]: List of writable voxel spacings.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickRunOverlay.query_voxelspacings","title":"query_voxelspacings","text":"<pre><code>query_voxelspacings() -&gt; List[CopickVoxelSpacingOverlay]\n</code></pre> <p>Query all voxel spacings.</p> <p>Returns:</p> <ul> <li> <code>List[CopickVoxelSpacingOverlay]</code>           \u2013            <p>List[CopickVoxelSpacingOverlay]: List of voxel spacings from both sources.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickRunOverlay._query_static_picks","title":"_query_static_picks","text":"<pre><code>_query_static_picks() -&gt; List[CopickPicksOverlay]\n</code></pre> <p>Override to query the static source for the picks. All returned picks must be read-only.</p> <p>Returns:</p> <ul> <li> <code>List[CopickPicksOverlay]</code>           \u2013            <p>List[CopickPicksOverlay]: List of read-only picks.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickRunOverlay._query_overlay_picks","title":"_query_overlay_picks","text":"<pre><code>_query_overlay_picks() -&gt; List[CopickPicksOverlay]\n</code></pre> <p>Override to query the overlay source for the picks.</p> <p>Returns:</p> <ul> <li> <code>List[CopickPicksOverlay]</code>           \u2013            <p>List[CopickPicksOverlay]: List of writable picks.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickRunOverlay.query_picks","title":"query_picks","text":"<pre><code>query_picks() -&gt; List[CopickPicksOverlay]\n</code></pre> <p>Query all picks.</p> <p>Returns:</p> <ul> <li> <code>List[CopickPicksOverlay]</code>           \u2013            <p>List[CopickPicksOverlay]: List of picks from both sources.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickRunOverlay._query_static_meshes","title":"_query_static_meshes","text":"<pre><code>_query_static_meshes() -&gt; List[CopickMeshOverlay]\n</code></pre> <p>Override to query the static source for the meshes. All returned meshes must be read-only.</p> <p>Returns:</p> <ul> <li> <code>List[CopickMeshOverlay]</code>           \u2013            <p>List[CopickMeshOverlay]: List of read-only meshes.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickRunOverlay._query_overlay_meshes","title":"_query_overlay_meshes","text":"<pre><code>_query_overlay_meshes() -&gt; List[CopickMeshOverlay]\n</code></pre> <p>Override to query the overlay source for the meshes.</p> <p>Returns:</p> <ul> <li> <code>List[CopickMeshOverlay]</code>           \u2013            <p>List[CopickMeshOverlay]: List of writable meshes.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickRunOverlay.query_meshes","title":"query_meshes","text":"<pre><code>query_meshes() -&gt; List[CopickMeshOverlay]\n</code></pre> <p>Query all meshes.</p> <p>Returns:</p> <ul> <li> <code>List[CopickMeshOverlay]</code>           \u2013            <p>List[CopickMeshOverlay]: List of meshes from both sources.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickRunOverlay._query_static_segmentations","title":"_query_static_segmentations","text":"<pre><code>_query_static_segmentations() -&gt; List[CopickSegmentationOverlay]\n</code></pre> <p>Override to query the static source for the segmentations. All returned segmentations must be read-only.</p> <p>Returns:</p> <ul> <li> <code>List[CopickSegmentationOverlay]</code>           \u2013            <p>List[CopickSegmentationOverlay]: List of read-only segmentations.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickRunOverlay._query_overlay_segmentations","title":"_query_overlay_segmentations","text":"<pre><code>_query_overlay_segmentations() -&gt; List[CopickSegmentationOverlay]\n</code></pre> <p>Override to query the overlay source for the segmentations.</p> <p>Returns:</p> <ul> <li> <code>List[CopickSegmentationOverlay]</code>           \u2013            <p>List[CopickSegmentationOverlay]: List of writable segmentations.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickRunOverlay.query_segmentations","title":"query_segmentations","text":"<pre><code>query_segmentations() -&gt; List[CopickSegmentationOverlay]\n</code></pre> <p>Query all segmentations.</p> <p>Returns:</p> <ul> <li> <code>List[CopickSegmentationOverlay]</code>           \u2013            <p>List[CopickSegmentationOverlay]: List of segmentations from both sources.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickObjectOverlay","title":"copick.impl.overlay.CopickObjectOverlay","text":"<p>               Bases: <code>CopickObject</code></p> <p>CopickObject class that keeps track of whether the object is read-only.</p> <p>Attributes:</p> <ul> <li> <code>read_only</code>               (<code>bool</code>)           \u2013            <p>Whether the object is read-only.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickObjectOverlay.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the object, making sure the source is writable.</p>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickPicksOverlay","title":"copick.impl.overlay.CopickPicksOverlay","text":"<p>               Bases: <code>CopickPicks</code></p> <p>CopickPicks class that keeps track of whether the picks are read-only.</p> <p>Attributes:</p> <ul> <li> <code>read_only</code>               (<code>bool</code>)           \u2013            <p>Whether the picks are read-only.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickPicksOverlay.store","title":"store","text":"<pre><code>store()\n</code></pre> <p>Store the picks, making sure the source is writable.</p>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickPicksOverlay.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the picks, making sure the source is writable.</p>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickMeshOverlay","title":"copick.impl.overlay.CopickMeshOverlay","text":"<p>               Bases: <code>CopickMesh</code></p> <p>CopickMesh class that keeps track of whether the mesh is read-only.</p> <p>Attributes:</p> <ul> <li> <code>read_only</code>               (<code>bool</code>)           \u2013            <p>Whether the mesh is read-only.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickMeshOverlay.store","title":"store","text":"<pre><code>store()\n</code></pre> <p>Store the mesh, making sure the source is writable.</p>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickMeshOverlay.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the mesh, making sure the source is writable.</p>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickSegmentationOverlay","title":"copick.impl.overlay.CopickSegmentationOverlay","text":"<p>               Bases: <code>CopickSegmentation</code></p> <p>CopickSegmentation class that keeps track of whether the segmentation is read-only.</p> <p>Attributes:</p> <ul> <li> <code>read_only</code>               (<code>bool</code>)           \u2013            <p>Whether the segmentation is read-only.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickSegmentationOverlay.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the segmentation, making sure the source is writable.</p>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickVoxelSpacingOverlay","title":"copick.impl.overlay.CopickVoxelSpacingOverlay","text":"<p>               Bases: <code>CopickVoxelSpacing</code></p> <p>CopickVoxelSpacing class that queries two different storage locations for voxel spacings. The first location is read-only (static) and the second location is writable (overlay).</p>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickVoxelSpacingOverlay._query_static_tomograms","title":"_query_static_tomograms","text":"<pre><code>_query_static_tomograms() -&gt; List[CopickTomogramOverlay]\n</code></pre> <p>Override to query the static source for the tomograms. All returned tomograms must be read-only.</p> <p>Returns:</p> <ul> <li> <code>List[CopickTomogramOverlay]</code>           \u2013            <p>List[CopickTomogramOverlay]: List of read-only tomograms.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickVoxelSpacingOverlay._query_overlay_tomograms","title":"_query_overlay_tomograms","text":"<pre><code>_query_overlay_tomograms() -&gt; List[CopickTomogramOverlay]\n</code></pre> <p>Override to query the overlay source for the tomograms.</p> <p>Returns:</p> <ul> <li> <code>List[CopickTomogramOverlay]</code>           \u2013            <p>List[CopickTomogramOverlay]: List of writable tomograms.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickVoxelSpacingOverlay.query_tomograms","title":"query_tomograms","text":"<pre><code>query_tomograms() -&gt; List[CopickTomogramOverlay]\n</code></pre> <p>Query all tomograms.</p> <p>Returns:</p> <ul> <li> <code>List[CopickTomogramOverlay]</code>           \u2013            <p>List[CopickTomogramOverlay]: List of tomograms from both sources.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickTomogramOverlay","title":"copick.impl.overlay.CopickTomogramOverlay","text":"<p>               Bases: <code>CopickTomogram</code></p> <p>CopickTomogram class that keeps track of whether the tomogram is read-only and queries two different storage locations for tomograms. The first location is read-only (static) and the second location is writable (overlay).</p> <p>Attributes:</p> <ul> <li> <code>read_only</code>               (<code>bool</code>)           \u2013            <p>Whether the tomogram is read-only.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickTomogramOverlay._query_static_features","title":"_query_static_features","text":"<pre><code>_query_static_features() -&gt; List[CopickFeaturesOverlay]\n</code></pre> <p>Override to query the static source for the features. All returned features must be read-only.</p> <p>Returns:</p> <ul> <li> <code>List[CopickFeaturesOverlay]</code>           \u2013            <p>List[CopickFeaturesOverlay]: List of read-only features.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickTomogramOverlay._query_overlay_features","title":"_query_overlay_features","text":"<pre><code>_query_overlay_features() -&gt; List[CopickFeaturesOverlay]\n</code></pre> <p>Override to query the overlay source for the features.</p> <p>Returns:</p> <ul> <li> <code>List[CopickFeaturesOverlay]</code>           \u2013            <p>List[CopickFeaturesOverlay]: List of writable features.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickTomogramOverlay.query_features","title":"query_features","text":"<pre><code>query_features() -&gt; List[CopickFeaturesOverlay]\n</code></pre> <p>Query all features.</p> <p>Returns:</p> <ul> <li> <code>List[CopickFeaturesOverlay]</code>           \u2013            <p>List[CopickFeaturesOverlay]: List of features from both sources.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickTomogramOverlay.delete","title":"delete","text":"<pre><code>delete() -&gt; None\n</code></pre> <p>Delete the tomogram, making sure the source is writable.</p>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickFeaturesOverlay","title":"copick.impl.overlay.CopickFeaturesOverlay","text":"<p>               Bases: <code>CopickFeatures</code></p> <p>CopickFeatures class that keeps track of whether the features are read-only.</p> <p>Attributes:</p> <ul> <li> <code>read_only</code>               (<code>bool</code>)           \u2013            <p>Whether the features are read-only.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickFeaturesOverlay.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the features, making sure the source is writable.</p>"},{"location":"examples/overview/","title":"Overview","text":""},{"location":"examples/overview/#setup","title":"Setup","text":"<p>copick projects can be distributed across multiple storage backends. The following short tutorials outline the most common setups, and provide template configuration files for each case.</p> <ul> <li> <p> Local Project</p> <p>All data is accessible on the local filesystem.</p> <p> Learn more</p> </li> <li> <p> cryoET Data Portal Project</p> <p>Static data is accessed via the CZ cryoET Data Portal.</p> <p> Learn more</p> </li> <li> <p> Shared Project</p> <p>Some or all data is stored on a shared filesystem.</p> <p> Learn more</p> </li> <li> <p> S3 Project</p> <p>Some or all data is stored on AWS or local S3.</p> <p> Learn more</p> </li> <li> <p> SSH Project</p> <p>Some or all data is stored on a filesystem accessible via SSH.</p> <p> Learn more</p> </li> </ul>"},{"location":"examples/overview/#tutorials","title":"Tutorials","text":"<p>The following tutorials provide step-by-step instructions for using copick to perform specific curation or analysis tasks.</p> <ul> <li> <p> Quickstart</p> <p>Install copick and set up a simple project.</p> <p> Learn more</p> </li> <li> <p> Data Portal</p> <p>Accessing data from the CZ cryoET Data Portal and creating new annotations for data portal tomograms.</p> <p> Learn more</p> </li> <li> <p> ChimeraX-copick</p> <p>Using the ChimeraX-copick interface to visualize data from a copick project.</p> <p> Learn more</p> </li> <li> <p> Album</p> <p>Creating album-based solutions to process copick data.</p> <p> Learn more</p> </li> <li> <p> Sample Boundaries</p> <p>An end-to-end tutorial on how to train a neural network to predict sample boundaries.</p> <p> Learn more</p> </li> <li> <p> membrain-seg</p> <p>Running the Membrain-seg segmentation pipeline on a copick project.</p> <p> Learn more</p> </li> </ul>"},{"location":"examples/snippets/","title":"Snippets","text":""},{"location":"examples/snippets/#print-all-runs-and-objects-in-a-copick-project","title":"Print all runs and objects in a copick project","text":"<pre><code>\"\"\"Print all objects and runs in a copick project.\"\"\"\n\nimport copick\n\n# Initialize the root object from a configuration file\nroot = copick.from_file(\"path/to/config.json\")\n\n# List all available objects\nobj_info = [(o.name, o.label) for o in root.pickable_objects]\n\nprint(\"Pickable objects in this project:\")\nfor name, label in obj_info:\n    print(f\"  {name}: {label}\")\n\n# Execute a function on each run in the project\nruns = root.runs\n\nprint(\"Runs in this project:\")\nfor run in runs:\n    print(f\"Run: {run.name}\")\n    # Do something with the run\n</code></pre>"},{"location":"examples/snippets/#read-an-objects-density-map-into-a-numpy-array","title":"Read an object's density map into a numpy array","text":"<pre><code>\"\"\"Read a density map from an object's zarr-store into a numpy array.\"\"\"\n\nimport copick\nimport numpy as np\nimport zarr\n\n# Initialize the root object from a configuration file\nroot = copick.from_file(\"path/to/config.json\")\n\n# Get the object named 'proteasome'\nproteasome = root.get_object(\"proteasome\")\n\n# Read the density map for the object from its zarr-store\nzarr_array = zarr.open(proteasome.zarr())[\"0\"]\ndensity_map = np.array(zarr_array)\n</code></pre>"},{"location":"examples/snippets/#print-all-tomograms-in-a-copick-voxel-spacing","title":"Print all tomograms in a copick voxel spacing","text":"<pre><code>\"\"\"Print the list of tomograms for a given voxel spacing.\"\"\"\n\nimport copick\n\n# Initialize the root object from a configuration file\nroot = copick.from_file(\"path/to/config.json\")\n\n# Get the run named 'TS_001'\nrun = root.get_run(\"TS_001\")\n\n# Get the voxel spacing with a resolution of 10 angstroms\nvoxel_spacing = run.get_voxel_spacing(10.000)\n\n# List all available tomograms for the voxel spacing\ntomograms = voxel_spacing.tomograms\nfor tomogram in tomograms:\n    print(f\"Tomogram: {tomogram.name}\")\n</code></pre>"},{"location":"examples/snippets/#read-a-tomogram-into-a-numpy-array","title":"Read a tomogram into a numpy array","text":"<pre><code>\"\"\"Read a tomogram from a zarr-store into a numpy array.\"\"\"\n\nimport copick\nimport numpy as np\nimport zarr\n\n# Initialize the root object from a configuration file\nroot = copick.from_file(\"path/to/config.json\")\n\n# Get the run named 'TS_001'\nrun = root.get_run(\"TS_001\")\n\n# Get the voxel spacing with a resolution of 10 angstroms\nvoxel_spacing = run.get_voxel_spacing(10.000)\n\n# Get the tomogram named 'wbp'\ntomogram = voxel_spacing.get_tomogram(\"wbp\")\n\n# Read the tomogram from its zarr-store\n# Scale \"0\" is the unbinned tomogram\nzarr_array = zarr.open(tomogram.zarr())[\"0\"]\ntomogram_data = np.array(zarr_array)\n\n# Scale \"1\" is the tomogram binned by 2\nzarr_array_bin2 = zarr.open(tomogram.zarr())[\"1\"]\ntomogram_data_bin2 = np.array(zarr_array_bin2)\n</code></pre>"},{"location":"examples/snippets/#read-a-feature-array-into-a-numpy-array","title":"Read a feature array into a numpy array","text":"<pre><code>\"\"\"Read a feature map from a zarr-store into a numpy array.\"\"\"\n\nimport copick\nimport numpy as np\nimport zarr\n\n# Initialize the root object from a configuration file\nroot = copick.from_file(\"path/to/config.json\")\n\n# Get the run named 'TS_001'\nrun = root.get_run(\"TS_001\")\n\n# Get the voxel spacing with a resolution of 10 angstroms\nvoxel_spacing = run.get_voxel_spacing(10.000)\n\n# Get the tomogram named 'wbp'\ntomogram = voxel_spacing.get_tomogram(\"wbp\")\n\n# Get the feature map named 'sobel'\nfeature_map = tomogram.get_features(\"sobel\")\n\n# Read the feature map from its zarr-store\nzarr_array = zarr.open(feature_map.zarr())[\"0\"]\nfeature_map_data = np.array(zarr_array)\n</code></pre>"},{"location":"examples/snippets/#read-copick-picks-into-a-numpy-array","title":"Read copick picks into a numpy array","text":"<pre><code>\"\"\"Read points from a CopickPicks object.\"\"\"\n\nimport copick\nimport numpy as np\n\n# Initialize the root object from a configuration file\nroot = copick.from_file(\"path/to/config.json\")\n\n# Get the first run in the project\nrun = root.runs[0]\n\n# Get 'proteasome' picks of user 'alice'\npicks = run.get_picks(object_name=\"proteasome\", user_id=\"alice\")[0]\n\n# Get the points from the picks\npoint_arr = np.ndarray((len(picks.points), 3))\nfor idx, pt in enumerate(picks.points):\n    point_arr[idx, :] = [pt.location.x, pt.location.y, pt.location.z]\n</code></pre>"},{"location":"examples/snippets/#print-all-segmentations-in-a-copick-run","title":"Print all segmentations in a copick run","text":"<pre><code>\"\"\"Print all segmentations for a run in a copick project.\"\"\"\n\nimport copick\n\n# Initialize the root object from a configuration file\nroot = copick.from_file(\"path/to/config.json\")\n\n# Get the run named 'TS_001'\nrun = root.get_run(\"TS_001\")\n\n# List all available segmentations for the run\nsegmentations = run.segmentations\nfor segmentation in segmentations:\n    print(f\"Segmentation: {segmentation.name}\")\n</code></pre>"},{"location":"examples/snippets/#read-a-segmentation-into-a-numpy-array","title":"Read a segmentation into a numpy array","text":"<pre><code>\"\"\"Read a segmentation from a CopickSegmentation object.\"\"\"\n\nimport copick\nimport numpy as np\nimport zarr\n\n# Initialize the root object from a configuration file\nroot = copick.from_file(\"path/to/config.json\")\n\n# Get the first run in the project\nrun = root.runs[0]\n\n# Get 'proteasome' segmentation of user 'alice'\nsegmentation = run.get_segmentations(object_name=\"proteasome\", user_id=\"alice\")[0]\n\n# Get the segmentation array from the segmentation\nseg_zarr = zarr.open(segmentation.zarr())[\"0\"]\nseg = np.array(seg_zarr)\n</code></pre>"},{"location":"examples/snippets/#read-a-mesh-from-a-copick-run","title":"Read a mesh from a copick run","text":"<pre><code>\"\"\"Read a mesh from a CopickMesh object and display it.\"\"\"\n\nimport copick\n\n# Initialize the root object from a configuration file\nroot = copick.from_file(\"path/to/config.json\")\n\n# Get the first run in the project\nrun = root.runs[0]\n\n# Get a membrane mesh from user 'bob'\nmesh = run.get_meshes(object_name=\"membrane\", user_id=\"bob\")[0]\n\n# Show the mesh\nmesh.mesh.show()\n</code></pre>"},{"location":"examples/setup/aws_s3/","title":"AWS S3 Project","text":"copick project setup with an S3 bucket. <p>In copick, a project has an overlay and (optionally) a static part. The overlay is where all user-created entities are stored and is writable. The static part is read-only and contains the input data. There are four ways of setting up local copick projects via AWS or local S3 buckets (e.g. MinIO):</p> <ul> <li> <p> Option 1: S3 overlay-only</p> <p>Using this method, there will be a single, shared project S3-prefix, all entities in the copick project will be writable.</p> <p> Get config template</p> </li> <li> <p> Option 2: S3 static, S3 overlay</p> <p>Using this method there will be two S3-prefixes, static and overlay, respectively. Files with the \"static\"-project prefixes will be read-only within copick, while files with the \"overlay\"-prefixes will be writeable. This is a good choice if you want to maintain the input data.</p> <p> Get config template</p> </li> <li> <p> Option 3: S3 overlay, other static</p> <p>Using this method, any user-created copick entities will be stored in a shared overlay, while static data (e.g. tomograms and baseline annotations) are stored in a different storage backend. This will be useful when multiple users are curating a dataset and have access to local copies of the static data.</p> <p> Get config templates</p> </li> <li> <p> Option 4: other overlay, S3 static</p> <p>Using this method, the static part of the project will be stored in a shared directory, while new copick entities are written to another storage backend. This could be useful when curating a large set of data with a group.</p> <p> Get config templates</p> </li> </ul>"},{"location":"examples/setup/aws_s3/#option-1-a-s3-overlay-only-copick-project","title":"Option 1: A S3 overlay-only copick project","text":""},{"location":"examples/setup/aws_s3/#set-up-your-project-root-prefix","title":"Set up your project root prefix","text":"<p>The following example assumes that you have a shared bucket on AWS S3 or a local S3 instance that you can access. To test access:</p> <pre><code>```bash\necho \"Hello, World!\" &gt; test.txt\naws s3 cp test.txt s3://your-bucket-name/copick_project/test.txt\naws s3 ls s3://your-bucket-name/copick_project/\naws s3 rm s3://your-bucket-name/copick_project/test.txt\n# Replace s3://your-bucket-name/copick_project/ with your S3 URI\n</code></pre> <p>AWS authentication</p> <p>Make sure you have the necessary AWS credentials set up and available in the shell you're running the above commands in. Refer to the AWS CLI documentation for more information.</p>"},{"location":"examples/setup/aws_s3/#create-the-config-file","title":"Create the config file","text":"<p>All information necessary to use the copick API is stored in a config file in <code>json</code>-Format. This has to be created before accessing the data is possible.</p> <p>Create a json file with your favorite editor and paste the below template. Fill in the S3 URI of the copick root prefix as indicated below.</p> <pre><code>vi copick_config.json\n</code></pre> Cofiguration Template <pre><code>{\n    \"name\": \"Example Project\",\n    \"description\": \"This is an example project, demonstrating an overlay-only s3-backend project.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"label\": 1,\n            \"color\": [\n                0,\n                117,\n                220,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"label\": 2,\n            \"color\": [\n                251,\n                192,\n                147,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"label\": 3,\n            \"color\": [\n                200,\n                200,\n                200,\n                255\n            ],\n            \"radius\": 10.0\n        }\n    ],\n    \"user_id\": \"example.user\",\n    \"config_type\": \"filesystem\",\n    \"overlay_root\": \"s3://bucket/copick_project/\",\n    \"overlay_fs_args\": {\n        \"profile\": \"your_profile\"\n    }\n}\n</code></pre> <p>The project is now set up, you can now add objects, add tomograms or store annotations.</p> More about <code>overlay_fs_args</code> ... <p>Specifying <code>profile</code> is one possible way of setting up AWS credentials. Refer to the S3FS documentation for detailed information.</p> <p>For local MinIO buckets, the following config may be appropriate:</p> <pre><code>{\n    \"overlay_fs_args\": {\n        \"key\":\"bucketkey\",\n        \"secret\":\"bucketsecret\",\n        \"endpoint_url\":\"http://10.30.121.49:7070\",\n        \"client_kwargs\":{\n            \"region_name\":\"us-east-1\"\n        }\n}\n</code></pre>"},{"location":"examples/setup/aws_s3/#option-2-a-s3-overlay-s3-static-copick-project","title":"Option 2: A S3 overlay, S3 static copick project","text":""},{"location":"examples/setup/aws_s3/#set-up-your-project-root-prefix_1","title":"Set up your project root prefix","text":"<p>The following example assumes that you have a shared bucket on AWS S3 or a local S3 instance that you can access. Test access as above.</p>"},{"location":"examples/setup/aws_s3/#create-the-config-file_1","title":"Create the config file","text":"<p>All information necessary to use the copick API is stored in a config file in <code>json</code>-Format. This has to be created before accessing the data is possible.</p> <p>Create a json file with your favorite editor and paste the below template. Fill in the S3 URI of the copick root as indicated below.</p> <pre><code>vi copick_config.json\n</code></pre> Cofiguration Template <pre><code>{\n    \"name\": \"Example Project\",\n    \"description\": \"This is an example project, demonstrating overlaying a s3-backend ona project in a s3-backend.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"label\": 1,\n            \"color\": [\n                0,\n                117,\n                220,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"label\": 2,\n            \"color\": [\n                251,\n                192,\n                147,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"label\": 3,\n            \"color\": [\n                200,\n                200,\n                200,\n                255\n            ],\n            \"radius\": 10.0\n        }\n    ],\n    \"user_id\": \"example.user\",\n    \"config_type\": \"filesystem\",\n    \"overlay_root\": \"s3://bucket/copick_project/\",\n    \"static_root\": \"s3://bucket/copick_project_static/\",\n    \"overlay_fs_args\": {\n        \"profile\": \"your_profile\"\n    },\n    \"static_fs_args\": {\n        \"profile\": \"your_profile\"\n    }\n}\n</code></pre>"},{"location":"examples/setup/aws_s3/#option-3-a-s3-overlay-other-static-copick-project","title":"Option 3: A S3 overlay, other static copick project","text":"<p>Choose your other static backend:</p> CZ cryoET Data PortalSMB ShareLocalSSH Cofiguration Template <pre><code>{\n    \"name\": \"Example Project\",\n    \"description\": \"This is an example project, demonstrating overlaying a s3-backend on a CZ cryoET Data Portal dataset.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"label\": 1,\n            \"color\": [\n                0,\n                117,\n                220,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"label\": 2,\n            \"color\": [\n                251,\n                192,\n                147,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"label\": 3,\n            \"color\": [\n                200,\n                200,\n                200,\n                255\n            ],\n            \"radius\": 10.0\n        }\n    ],\n    \"user_id\": \"example.user\",\n    \"config_type\": \"cryoet_data_portal\",\n    \"overlay_root\": \"s3://bucket/copick_project/\",\n    \"dataset_ids\": [\n        10301,\n        10302\n    ],\n    \"overlay_fs_args\": {\n        \"profile\": \"your_profile\"\n    }\n}\n</code></pre> <p>Set up your overlay project</p> <p>This S3 URI will contain all newly created data for your project.</p> <p>Make sure the intended S3 bucket is writable: <pre><code>echo \"Hello, World!\" &gt; test.txt\naws s3 cp test.txt s3://your-bucket-name/copick_project/test.txt\naws s3 ls s3://your-bucket-name/copick_project/\naws s3 rm s3://your-bucket-name/copick_project/test.txt\n# Replace s3://your-bucket-name/copick_project/ with your S3 URI\n</code></pre></p> <p>AWS authentication</p> <p>Make sure you have the necessary AWS credentials set up and available in the shell you're running the above commands in. Refer to the AWS CLI documentation for more information.</p> <p>In the config file, the location should be passed to the <code>overlay_root</code>-field. Any arguments specified to the <code>overlay_fs_args</code>-field will be passed to S3FileSystem. <code>profile</code> should be one of the profiles set up in your <code>~/.aws/credentials</code> file.</p> <pre><code>{\n  \"overlay_root\": \"s3://bucket-name/copick_project/\",\n  \"overlay_fs_args\": {\n        \"profile\": \"example_profile\"\n    }\n}\n</code></pre> More about <code>overlay_fs_args</code> ... <p>Specifying <code>profile</code> is one possible way of setting up AWS credentials. Refer to the S3FS documentation for detailed information.</p> <p>For local MinIO buckets, the following config may be appropriate:</p> <pre><code>{\n    \"overlay_fs_args\": {\n        \"key\":\"bucketkey\",\n        \"secret\":\"bucketsecret\",\n        \"endpoint_url\":\"http://10.30.121.49:7070\",\n        \"client_kwargs\":{\n            \"region_name\":\"us-east-1\"\n        }\n}\n</code></pre> <p>Set up your static project</p> <p>In the case of CZ cryoET data portal datasets, setting up the static project is as easy as specifying one or multiple dataset IDs. The below example selects runs from datasets 10301 and 10302.</p> <pre><code>{\n  \"dataset_ids\": [\n    10301,\n    10302\n  ]\n}\n</code></pre> <p>Configuration Type</p> <p>When using the CZ cryoET data portal, the <code>config_type</code>-field should be set to <code>cryoet-data-portal</code>.</p> Cofiguration Template <pre><code>{\n    \"name\": \"Example Project\",\n    \"description\": \"This is an example project, demonstrating overlaying a s3-backend ona project in a smb-backend.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"label\": 1,\n            \"color\": [\n                0,\n                117,\n                220,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"label\": 2,\n            \"color\": [\n                251,\n                192,\n                147,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"label\": 3,\n            \"color\": [\n                200,\n                200,\n                200,\n                255\n            ],\n            \"radius\": 10.0\n        }\n    ],\n    \"user_id\": \"example.user\",\n    \"config_type\": \"filesystem\",\n    \"overlay_root\": \"s3://bucket/copick_project/\",\n    \"static_root\": \"smb:///shared_drive/copick_project_static/\",\n    \"overlay_fs_args\": {\n        \"profile\": \"your_profile\"\n    },\n    \"static_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"temppath\": \"/shared_drive\",\n        \"auto_mkdir\": true\n    }\n}\n</code></pre> <p>Set up your overlay project</p> <p>This S3 URI will contain all newly created data for your project.</p> <p>Make sure the intended S3 bucket is writable: <pre><code>echo \"Hello, World!\" &gt; test.txt\naws s3 cp test.txt s3://your-bucket-name/copick_project/test.txt\naws s3 ls s3://your-bucket-name/copick_project/\naws s3 rm s3://your-bucket-name/copick_project/test.txt\n# Replace s3://your-bucket-name/copick_project/ with your S3 URI\n</code></pre></p> <p>AWS authentication</p> <p>Make sure you have the necessary AWS credentials set up and available in the shell you're running the above commands in. Refer to the AWS CLI documentation for more information.</p> <p>In the config file, the location should be passed to the <code>overlay_root</code>-field. Any arguments specified to the <code>overlay_fs_args</code>-field will be passed to S3FileSystem. <code>profile</code> should be one of the profiles set up in your <code>~/.aws/credentials</code> file.</p> <pre><code>{\n  \"overlay_root\": \"s3://bucket-name/copick_project/\",\n  \"overlay_fs_args\": {\n        \"profile\": \"example_profile\"\n    }\n}\n</code></pre> More about <code>overlay_fs_args</code> ... <p>Specifying <code>profile</code> is one possible way of setting up AWS credentials. Refer to the S3FS documentation for detailed information.</p> <p>For local MinIO buckets, the following config may be appropriate:</p> <pre><code>{\n    \"overlay_fs_args\": {\n        \"key\":\"bucketkey\",\n        \"secret\":\"bucketsecret\",\n        \"endpoint_url\":\"http://10.30.121.49:7070\",\n        \"client_kwargs\":{\n            \"region_name\":\"us-east-1\"\n        }\n}\n</code></pre> <p>Set up your static project</p> <p>This SMB-share will contain all static data for your project.</p> <p>In the config file, the location should be passed to the <code>static_root</code>-field. Any arguments specified to the <code>static_fs_args</code>-field will be passed to SMBFileSystem.</p> <pre><code>{\n    \"static_root\": \"smb:///shared_drive/copick_project/\",\n    \"static_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"temppath\": \"/shared_drive\",\n        \"auto_mkdir\": true,\n    }\n}\n</code></pre> More about <code>static_fs_args</code> ... <p>The <code>auto_mkdir</code>-flag is necessary to create copick-directories if they do not yet exist. The <code>tmpath</code>-flag is not strictly necessary, this depends on your SMB setup (e.g. if only a specific directory is shared).</p> <pre><code>{\n    \"static_root\": \"smb:///shared_drive/copick_project/\",\n    \"static_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"auto_mkdir\": true,\n    }\n}\n</code></pre> Cofiguration Template <pre><code>{\n    \"name\": \"Example Project\",\n    \"description\": \"This is an example project, demonstrating overlaying a s3-backend ona project in a local-backend.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"label\": 1,\n            \"color\": [\n                0,\n                117,\n                220,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"label\": 2,\n            \"color\": [\n                251,\n                192,\n                147,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"label\": 3,\n            \"color\": [\n                200,\n                200,\n                200,\n                255\n            ],\n            \"radius\": 10.0\n        }\n    ],\n    \"user_id\": \"example.user\",\n    \"config_type\": \"filesystem\",\n    \"overlay_root\": \"s3://bucket/copick_project/\",\n    \"static_root\": \"local:///path/to/copick_project_static/\",\n    \"overlay_fs_args\": {\n        \"profile\": \"your_profile\"\n    },\n    \"static_fs_args\": {\n        \"auto_mkdir\": true\n    }\n}\n</code></pre> <p>Set up your overlay project</p> <p>This S3 URI will contain all newly created data for your project.</p> <p>Make sure the intended S3 bucket is writable: <pre><code>echo \"Hello, World!\" &gt; test.txt\naws s3 cp test.txt s3://your-bucket-name/copick_project/test.txt\naws s3 ls s3://your-bucket-name/copick_project/\naws s3 rm s3://your-bucket-name/copick_project/test.txt\n# Replace s3://your-bucket-name/copick_project/ with your S3 URI\n</code></pre></p> <p>AWS authentication</p> <p>Make sure you have the necessary AWS credentials set up and available in the shell you're running the above commands in. Refer to the AWS CLI documentation for more information.</p> <p>In the config file, the location should be passed to the <code>overlay_root</code>-field. Any arguments specified to the <code>overlay_fs_args</code>-field will be passed to S3FileSystem. <code>profile</code> should be one of the profiles set up in your <code>~/.aws/credentials</code> file.</p> <pre><code>{\n  \"overlay_root\": \"s3://bucket-name/copick_project/\",\n  \"overlay_fs_args\": {\n        \"profile\": \"example_profile\"\n    }\n}\n</code></pre> More about <code>overlay_fs_args</code> ... <p>Specifying <code>profile</code> is one possible way of setting up AWS credentials. Refer to the S3FS documentation for detailed information.</p> <p>For local MinIO buckets, the following config may be appropriate:</p> <pre><code>{\n    \"overlay_fs_args\": {\n        \"key\":\"bucketkey\",\n        \"secret\":\"bucketsecret\",\n        \"endpoint_url\":\"http://10.30.121.49:7070\",\n        \"client_kwargs\":{\n            \"region_name\":\"us-east-1\"\n        }\n}\n</code></pre> <p>Set up your static project</p> <p>This directory will contain all static data for your project.</p> <p>Make sure it exists on the filesystem and is writable: <pre><code>touch /path/to/copick_project_static\n# Replace /path/to/copick_project with the path to your static project\n</code></pre></p> <p>If it does not yet exist, create it with the following command: <pre><code>mkdir /path/to/copick_project_static\n# Replace /path/to/copick_project with the path to your static project\n</code></pre></p> <p>In the config file, the location should be passed to the <code>static_root</code>-field. Any arguments specified to the <code>static_fs_args</code>-field will be passed to LocalFileSystem.</p> <pre><code>{\n  \"static_root\": \"local:///path/to/copick_project\",\n  \"static_fs_args\": {\n    \"auto_mkdir\": true\n  }\n}\n</code></pre> More about <code>static_fs_args</code> ... <p>The <code>auto_mkdir</code>-flag is necessary to create copick-directories if they do not yet exist.</p> Cofiguration Template <pre><code>{\n    \"name\": \"Example Project\",\n    \"description\": \"This is an example project, demonstrating overlaying a s3-backend ona project in a ssh-backend.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"label\": 1,\n            \"color\": [\n                0,\n                117,\n                220,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"label\": 2,\n            \"color\": [\n                251,\n                192,\n                147,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"label\": 3,\n            \"color\": [\n                200,\n                200,\n                200,\n                255\n            ],\n            \"radius\": 10.0\n        }\n    ],\n    \"user_id\": \"example.user\",\n    \"config_type\": \"filesystem\",\n    \"overlay_root\": \"s3://bucket/copick_project/\",\n    \"static_root\": \"ssh:///hpc/storage/copick_project_static/\",\n    \"overlay_fs_args\": {\n        \"profile\": \"your_profile\"\n    },\n    \"static_fs_args\": {\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"host\": \"hpc.example.com\",\n        \"port\": 22\n    }\n}\n</code></pre> <p>Set up your overlay project</p> <p>This S3 URI will contain all newly created data for your project.</p> <p>Make sure the intended S3 bucket is writable: <pre><code>echo \"Hello, World!\" &gt; test.txt\naws s3 cp test.txt s3://your-bucket-name/copick_project/test.txt\naws s3 ls s3://your-bucket-name/copick_project/\naws s3 rm s3://your-bucket-name/copick_project/test.txt\n# Replace s3://your-bucket-name/copick_project/ with your S3 URI\n</code></pre></p> <p>AWS authentication</p> <p>Make sure you have the necessary AWS credentials set up and available in the shell you're running the above commands in. Refer to the AWS CLI documentation for more information.</p> <p>In the config file, the location should be passed to the <code>overlay_root</code>-field. Any arguments specified to the <code>overlay_fs_args</code>-field will be passed to S3FileSystem. <code>profile</code> should be one of the profiles set up in your <code>~/.aws/credentials</code> file.</p> <pre><code>{\n  \"overlay_root\": \"s3://bucket-name/copick_project/\",\n  \"overlay_fs_args\": {\n        \"profile\": \"example_profile\"\n    }\n}\n</code></pre> More about <code>overlay_fs_args</code> ... <p>Specifying <code>profile</code> is one possible way of setting up AWS credentials. Refer to the S3FS documentation for detailed information.</p> <p>For local MinIO buckets, the following config may be appropriate:</p> <pre><code>{\n    \"overlay_fs_args\": {\n        \"key\":\"bucketkey\",\n        \"secret\":\"bucketsecret\",\n        \"endpoint_url\":\"http://10.30.121.49:7070\",\n        \"client_kwargs\":{\n            \"region_name\":\"us-east-1\"\n        }\n}\n</code></pre> <p>Set up your static project</p> <p>This directory will contain all static data for your project.</p> <p>SSH authentication</p> <p>Copick will work best via SSH if you have set up passwordless SSH authentication. Refer to the SSH documentation for more information. In general, adding plain text passwords into copick configuration files is strongly discouraged.</p> <p>In cases of mandatory 2-FA authentication, you may need to set up an SSH tunnel to the remote filesystem, e.g.</p> <p><pre><code>ssh -L 2222:localhost:22 user.name@hpc.example.com\n</code></pre> and then use <code>localhost:2222</code> as the host in the config and commands below.</p> <p>Make sure it exists on the remote filesystem and is writable: <pre><code>ssh -p 22 user.name@hpc.example.com \"touch /path/to/copick_project_static\"\n# Replace port, user name and path to the static project with the correct values\n</code></pre></p> <p>If it does not yet exist, create it with the following command: <pre><code>ssh -p 22 user.name@hpc.example.com \"mkdir /path/to/copick_project_static\"\n# Replace port, user name and path to the static project with the correct values\n</code></pre></p> <p>In the config file, the location should be passed to the <code>static_root</code>-field. Any arguments specified to the <code>static_fs_args</code>-field will be passed to sshfs.SSHFileSystem.</p> <pre><code>{\n  \"static_root\": \"ssh:///path/to/copick_project_static/\",\n\n    \"static_fs_args\": {\n        \"username\": \"user.name\",\n        \"host\": \"hpc.example.com\",\n        \"port\": 22\n    }\n}\n</code></pre> More about <code>static_fs_args</code> ... <p>The <code>username</code>, <code>host</code> and <code>port</code>-fields are necessary to set up the SSH connection. Refer to the SSHFS documentation for detailed information.</p> <p>An easy way to use the SSH filesystem is to tunnel to the remote filesystem via SSH, e.g.</p> <pre><code>ssh -L 2222:localhost:22 user.name@hpc.example.com\n</code></pre> <p>and then use <code>localhost:2222</code> as the host in the config and commands above.</p> <pre><code>{\n  \"static_fs_args\": {\n      \"username\": \"user.name\",\n      \"host\": \"localhost\",\n      \"port\": 2222\n  }\n}\n</code></pre>"},{"location":"examples/setup/aws_s3/#option-4-an-other-overlay-s3-static-copick-project","title":"Option 4: An other overlay, S3 static copick project","text":"<p>Choose your otheroverlay backend:</p> LocalSMB ShareSSH Cofiguration Template <pre><code>{\n    \"name\": \"Example Project\",\n    \"description\": \"This is an example project, demonstrating overlaying a local-backend ona project in a s3-backend.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"label\": 1,\n            \"color\": [\n                0,\n                117,\n                220,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"label\": 2,\n            \"color\": [\n                251,\n                192,\n                147,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"label\": 3,\n            \"color\": [\n                200,\n                200,\n                200,\n                255\n            ],\n            \"radius\": 10.0\n        }\n    ],\n    \"user_id\": \"example.user\",\n    \"config_type\": \"filesystem\",\n    \"overlay_root\": \"local:///path/to/copick_project/\",\n    \"static_root\": \"s3://bucket/copick_project_static/\",\n    \"overlay_fs_args\": {\n        \"auto_mkdir\": true\n    },\n    \"static_fs_args\": {\n        \"profile\": \"your_profile\"\n    }\n}\n</code></pre> <p>Set up your overlay project</p> <p>This directory will contain all newly created data for your project.</p> <p>Make sure it exists on the filesystem and is writable: <pre><code>touch /path/to/copick_project\n# Replace /path/to/copick_project with the path to your project overlay\n</code></pre></p> <p>If it does not yet exist, create it with the following command: <pre><code>mkdir /path/to/copick_project\n# Replace /path/to/copick_project with the path to your project overlay\n</code></pre></p> <p>In the config file, the location should be passed to the <code>overlay_root</code>-field. Any arguments specified to the <code>overlay_fs_args</code>-field will be passed to LocalFileSystem.</p> <pre><code>{\n  \"overlay_root\": \"local:///path/to/copick_project\",\n  \"overlay_fs_args\": {\n    \"auto_mkdir\": true\n  }\n}\n</code></pre> More about <code>overlay_fs_args</code> ... <p>The <code>auto_mkdir</code>-flag is necessary to create copick-directories if they do not yet exist.</p> <p>Set up your static project</p> <p>This S3 URI will contain all static data for your project.</p> <p>Make sure the intended S3 bucket is writable: <pre><code>echo \"Hello, World!\" &gt; test.txt\naws s3 cp test.txt s3://your-bucket-name/copick_project_static/test.txt\naws s3 ls s3://your-bucket-name/copick_project_static/\naws s3 rm s3://your-bucket-name/copick_project_static/test.txt\n# Replace s3://your-bucket-name/copick_project/ with your S3 URI\n</code></pre></p> <p>AWS authentication</p> <p>Make sure you have the necessary AWS credentials set up and available in the shell you're running the above commands in. Refer to the AWS CLI documentation for more information.</p> <p>In the config file, the location should be passed to the <code>static_root</code>-field. Any arguments specified to the <code>static_fs_args</code>-field will be passed to S3FileSystem. <code>profile</code> should be one of the profiles set up in your <code>~/.aws/credentials</code> file.</p> <pre><code>{\n  \"static_root\": \"s3://bucket-name/copick_project_static/\",\n  \"static_fs_args\": {\n        \"profile\": \"example_profile\"\n    }\n}\n</code></pre> More about <code>static_fs_args</code> ... <p>Specifying <code>profile</code> is one possible way of setting up AWS credentials. Refer to the S3FS documentation for detailed information.</p> <p>For local MinIO buckets, the following config may be appropriate:</p> <pre><code>{\n    \"static_fs_args\": {\n        \"key\":\"bucketkey\",\n        \"secret\":\"bucketsecret\",\n        \"endpoint_url\":\"http://10.30.121.49:7070\",\n        \"client_kwargs\":{\n            \"region_name\":\"us-east-1\"\n        }\n}\n</code></pre> Cofiguration Template <pre><code>{\n    \"name\": \"Example Project\",\n    \"description\": \"This is an example project, demonstrating overlaying a smb-backend ona project in a s3-backend.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"label\": 1,\n            \"color\": [\n                0,\n                117,\n                220,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"label\": 2,\n            \"color\": [\n                251,\n                192,\n                147,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"label\": 3,\n            \"color\": [\n                200,\n                200,\n                200,\n                255\n            ],\n            \"radius\": 10.0\n        }\n    ],\n    \"user_id\": \"example.user\",\n    \"config_type\": \"filesystem\",\n    \"overlay_root\": \"smb:///shared_drive/copick_project/\",\n    \"static_root\": \"s3://bucket/copick_project_static/\",\n    \"overlay_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"temppath\": \"/shared_drive\",\n        \"auto_mkdir\": true\n    },\n    \"static_fs_args\": {\n        \"profile\": \"your_profile\"\n    }\n}\n</code></pre> <p>Set up your overlay project</p> <p>This SMB-share will contain all newly created data for your project.</p> <p>In the config file, the location should be passed to the <code>overlay_root</code>-field. Any arguments specified to the <code>overlay_fs_args</code>-field will be passed to SMBFileSystem.</p> <pre><code>{\n    \"overlay_root\": \"smb:///shared_drive/copick_project/\",\n    \"overlay_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"temppath\": \"/shared_drive\",\n        \"auto_mkdir\": true,\n    }\n}\n</code></pre> More about <code>overlay_fs_args</code> ... <p>The <code>auto_mkdir</code>-flag is necessary to create copick-directories if they do not yet exist. The <code>tmpath</code>-flag is not strictly necessary, this depends on your SMB setup (e.g. if only a specific directory is shared).</p> <pre><code>{\n    \"overlay_root\": \"smb:///shared_drive/copick_project/\",\n    \"overlay_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"auto_mkdir\": true,\n    }\n}\n</code></pre> <p>Set up your static project</p> <p>This S3 URI will contain all static data for your project.</p> <p>Make sure the intended S3 bucket is writable: <pre><code>echo \"Hello, World!\" &gt; test.txt\naws s3 cp test.txt s3://your-bucket-name/copick_project_static/test.txt\naws s3 ls s3://your-bucket-name/copick_project_static/\naws s3 rm s3://your-bucket-name/copick_project_static/test.txt\n# Replace s3://your-bucket-name/copick_project/ with your S3 URI\n</code></pre></p> <p>AWS authentication</p> <p>Make sure you have the necessary AWS credentials set up and available in the shell you're running the above commands in. Refer to the AWS CLI documentation for more information.</p> <p>In the config file, the location should be passed to the <code>static_root</code>-field. Any arguments specified to the <code>static_fs_args</code>-field will be passed to S3FileSystem. <code>profile</code> should be one of the profiles set up in your <code>~/.aws/credentials</code> file.</p> <pre><code>{\n  \"static_root\": \"s3://bucket-name/copick_project_static/\",\n  \"static_fs_args\": {\n        \"profile\": \"example_profile\"\n    }\n}\n</code></pre> More about <code>static_fs_args</code> ... <p>Specifying <code>profile</code> is one possible way of setting up AWS credentials. Refer to the S3FS documentation for detailed information.</p> <p>For local MinIO buckets, the following config may be appropriate:</p> <pre><code>{\n    \"static_fs_args\": {\n        \"key\":\"bucketkey\",\n        \"secret\":\"bucketsecret\",\n        \"endpoint_url\":\"http://10.30.121.49:7070\",\n        \"client_kwargs\":{\n            \"region_name\":\"us-east-1\"\n        }\n}\n</code></pre> Cofiguration Template <pre><code>{\n    \"name\": \"Example Project\",\n    \"description\": \"This is an example project, demonstrating overlaying a ssh-backend ona project in a s3-backend.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"label\": 1,\n            \"color\": [\n                0,\n                117,\n                220,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"label\": 2,\n            \"color\": [\n                251,\n                192,\n                147,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"label\": 3,\n            \"color\": [\n                200,\n                200,\n                200,\n                255\n            ],\n            \"radius\": 10.0\n        }\n    ],\n    \"user_id\": \"example.user\",\n    \"config_type\": \"filesystem\",\n    \"overlay_root\": \"ssh:///hpc/storage/copick_project/\",\n    \"static_root\": \"s3://bucket/copick_project_static/\",\n    \"overlay_fs_args\": {\n        \"username\": \"user.name\",\n        \"host\": \"hpc.example.com\",\n        \"port\": 22\n    },\n    \"static_fs_args\": {\n        \"profile\": \"your_profile\"\n    }\n}\n</code></pre> <p>Set up your overlay project</p> <p>This directory will contain all newly created data for your project.</p> <p>SSH authentication</p> <p>Copick will work best via SSH if you have set up passwordless SSH authentication. Refer to the SSH documentation for more information. In general, adding plain text passwords into copick configuration files is strongly discouraged.</p> <p>In cases of mandatory 2-FA authentication, you may need to set up an SSH tunnel to the remote filesystem, e.g.</p> <p><pre><code>ssh -L 2222:localhost:22 user.name@hpc.example.com\n</code></pre> and then use <code>localhost:2222</code> as the host in the config and commands below.</p> <p>Make sure it exists on the remote filesystem and is writable: <pre><code>ssh -p 22 user.name@hpc.example.com \"touch /path/to/copick_project\"\n# Replace port, user name and path to the project overlay with the correct values\n</code></pre></p> <p>If it does not yet exist, create it with the following command: <pre><code>ssh -p 22 user.name@hpc.example.com \"mkdir /path/to/copick_project\"\n# Replace port, user name and path to the project overlay with the correct values\n</code></pre></p> <p>In the config file, the location should be passed to the <code>overlay_root</code>-field. Any arguments specified to the <code>overlay_fs_args</code>-field will be passed to sshfs.SSHFileSystem.</p> <pre><code>{\n  \"overlay_root\": \"ssh:///path/to/copick_project/\",\n\n    \"overlay_fs_args\": {\n        \"username\": \"user.name\",\n        \"host\": \"hpc.example.com\",\n        \"port\": 22\n    }\n}\n</code></pre> More about <code>overlay_fs_args</code> ... <p>The <code>username</code>, <code>host</code> and <code>port</code>-fields are necessary to set up the SSH connection. Refer to the SSHFS documentation for detailed information.</p> <p>An easy way to use the SSH filesystem is to tunnel to the remote filesystem via SSH, e.g.</p> <pre><code>ssh -L 2222:localhost:22 user.name@hpc.example.com\n</code></pre> <p>and then use <code>localhost:2222</code> as the host in the config and commands above.</p> <pre><code>{\n  \"overlay_fs_args\": {\n      \"username\": \"user.name\",\n      \"host\": \"localhost\",\n      \"port\": 2222\n  }\n}\n</code></pre> <p>Set up your static project</p> <p>This S3 URI will contain all static data for your project.</p> <p>Make sure the intended S3 bucket is writable: <pre><code>echo \"Hello, World!\" &gt; test.txt\naws s3 cp test.txt s3://your-bucket-name/copick_project_static/test.txt\naws s3 ls s3://your-bucket-name/copick_project_static/\naws s3 rm s3://your-bucket-name/copick_project_static/test.txt\n# Replace s3://your-bucket-name/copick_project/ with your S3 URI\n</code></pre></p> <p>AWS authentication</p> <p>Make sure you have the necessary AWS credentials set up and available in the shell you're running the above commands in. Refer to the AWS CLI documentation for more information.</p> <p>In the config file, the location should be passed to the <code>static_root</code>-field. Any arguments specified to the <code>static_fs_args</code>-field will be passed to S3FileSystem. <code>profile</code> should be one of the profiles set up in your <code>~/.aws/credentials</code> file.</p> <pre><code>{\n  \"static_root\": \"s3://bucket-name/copick_project_static/\",\n  \"static_fs_args\": {\n        \"profile\": \"example_profile\"\n    }\n}\n</code></pre> More about <code>static_fs_args</code> ... <p>Specifying <code>profile</code> is one possible way of setting up AWS credentials. Refer to the S3FS documentation for detailed information.</p> <p>For local MinIO buckets, the following config may be appropriate:</p> <pre><code>{\n    \"static_fs_args\": {\n        \"key\":\"bucketkey\",\n        \"secret\":\"bucketsecret\",\n        \"endpoint_url\":\"http://10.30.121.49:7070\",\n        \"client_kwargs\":{\n            \"region_name\":\"us-east-1\"\n        }\n}\n</code></pre>"},{"location":"examples/setup/data_portal/","title":"CZ cryoET Data Portal","text":"copick project setup static data from the CZ cryoET data portal. <p>copick has direct integration with the CZ cryoET Data Portal python API. This allows users to access data from the portal and create new annotations for data portal tomograms. Datasets to be curated can be selected by dataset ID.</p> <p>The data portal project is a special project type that is created by setting the <code>cryoet-data-portal</code> configuration type. This project type is can be used with any other overlay-backend. Choose one below for more information on how to set up your project.</p> <p>Choose your overlay backend:</p> LocalS3SMB ShareSSH Cofiguration Template <pre><code>{\n    \"name\": \"Example Project\",\n    \"description\": \"This is an example project, demonstrating overlaying a local-backend on a CZ cryoET Data Portal dataset.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"label\": 1,\n            \"color\": [\n                0,\n                117,\n                220,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"label\": 2,\n            \"color\": [\n                251,\n                192,\n                147,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"label\": 3,\n            \"color\": [\n                200,\n                200,\n                200,\n                255\n            ],\n            \"radius\": 10.0\n        }\n    ],\n    \"user_id\": \"example.user\",\n    \"config_type\": \"cryoet_data_portal\",\n    \"overlay_root\": \"local:///path/to/copick_project/\",\n    \"dataset_ids\": [\n        10301,\n        10302\n    ],\n    \"overlay_fs_args\": {\n        \"auto_mkdir\": true\n    }\n}\n</code></pre> <p>Set up your overlay project</p> <p>This directory will contain all newly created data for your project.</p> <p>Make sure it exists on the filesystem and is writable: <pre><code>touch /path/to/copick_project\n# Replace /path/to/copick_project with the path to your project overlay\n</code></pre></p> <p>If it does not yet exist, create it with the following command: <pre><code>mkdir /path/to/copick_project\n# Replace /path/to/copick_project with the path to your project overlay\n</code></pre></p> <p>In the config file, the location should be passed to the <code>overlay_root</code>-field. Any arguments specified to the <code>overlay_fs_args</code>-field will be passed to LocalFileSystem.</p> <pre><code>{\n  \"overlay_root\": \"local:///path/to/copick_project\",\n  \"overlay_fs_args\": {\n    \"auto_mkdir\": true\n  }\n}\n</code></pre> More about <code>overlay_fs_args</code> ... <p>The <code>auto_mkdir</code>-flag is necessary to create copick-directories if they do not yet exist.</p> <p>Set up your static project</p> <p>In the case of CZ cryoET data portal datasets, setting up the static project is as easy as specifying one or multiple dataset IDs. The below example selects runs from datasets 10301 and 10302.</p> <pre><code>{\n  \"dataset_ids\": [\n    10301,\n    10302\n  ]\n}\n</code></pre> <p>Configuration Type</p> <p>When using the CZ cryoET data portal, the <code>config_type</code>-field should be set to <code>cryoet-data-portal</code>.</p> Cofiguration Template <pre><code>{\n    \"name\": \"Example Project\",\n    \"description\": \"This is an example project, demonstrating overlaying a s3-backend on a CZ cryoET Data Portal dataset.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"label\": 1,\n            \"color\": [\n                0,\n                117,\n                220,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"label\": 2,\n            \"color\": [\n                251,\n                192,\n                147,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"label\": 3,\n            \"color\": [\n                200,\n                200,\n                200,\n                255\n            ],\n            \"radius\": 10.0\n        }\n    ],\n    \"user_id\": \"example.user\",\n    \"config_type\": \"cryoet_data_portal\",\n    \"overlay_root\": \"s3://bucket/copick_project/\",\n    \"dataset_ids\": [\n        10301,\n        10302\n    ],\n    \"overlay_fs_args\": {\n        \"profile\": \"your_profile\"\n    }\n}\n</code></pre> <p>Set up your overlay project</p> <p>This S3 URI will contain all newly created data for your project.</p> <p>Make sure the intended S3 bucket is writable: <pre><code>echo \"Hello, World!\" &gt; test.txt\naws s3 cp test.txt s3://your-bucket-name/copick_project/test.txt\naws s3 ls s3://your-bucket-name/copick_project/\naws s3 rm s3://your-bucket-name/copick_project/test.txt\n# Replace s3://your-bucket-name/copick_project/ with your S3 URI\n</code></pre></p> <p>AWS authentication</p> <p>Make sure you have the necessary AWS credentials set up and available in the shell you're running the above commands in. Refer to the AWS CLI documentation for more information.</p> <p>In the config file, the location should be passed to the <code>overlay_root</code>-field. Any arguments specified to the <code>overlay_fs_args</code>-field will be passed to S3FileSystem. <code>profile</code> should be one of the profiles set up in your <code>~/.aws/credentials</code> file.</p> <pre><code>{\n  \"overlay_root\": \"s3://bucket-name/copick_project/\",\n  \"overlay_fs_args\": {\n        \"profile\": \"example_profile\"\n    }\n}\n</code></pre> More about <code>overlay_fs_args</code> ... <p>Specifying <code>profile</code> is one possible way of setting up AWS credentials. Refer to the S3FS documentation for detailed information.</p> <p>For local MinIO buckets, the following config may be appropriate:</p> <pre><code>{\n    \"overlay_fs_args\": {\n        \"key\":\"bucketkey\",\n        \"secret\":\"bucketsecret\",\n        \"endpoint_url\":\"http://10.30.121.49:7070\",\n        \"client_kwargs\":{\n            \"region_name\":\"us-east-1\"\n        }\n}\n</code></pre> <p>Set up your static project</p> <p>In the case of CZ cryoET data portal datasets, setting up the static project is as easy as specifying one or multiple dataset IDs. The below example selects runs from datasets 10301 and 10302.</p> <pre><code>{\n  \"dataset_ids\": [\n    10301,\n    10302\n  ]\n}\n</code></pre> <p>Configuration Type</p> <p>When using the CZ cryoET data portal, the <code>config_type</code>-field should be set to <code>cryoet-data-portal</code>.</p> Cofiguration Template <pre><code>{\n    \"name\": \"Example Project\",\n    \"description\": \"This is an example project, demonstrating overlaying a smb-backend on a CZ cryoET Data Portal dataset.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"label\": 1,\n            \"color\": [\n                0,\n                117,\n                220,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"label\": 2,\n            \"color\": [\n                251,\n                192,\n                147,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"label\": 3,\n            \"color\": [\n                200,\n                200,\n                200,\n                255\n            ],\n            \"radius\": 10.0\n        }\n    ],\n    \"user_id\": \"example.user\",\n    \"config_type\": \"cryoet_data_portal\",\n    \"overlay_root\": \"smb:///shared_drive/copick_project/\",\n    \"dataset_ids\": [\n        10301,\n        10302\n    ],\n    \"overlay_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"temppath\": \"/shared_drive\",\n        \"auto_mkdir\": true\n    }\n}\n</code></pre> <p>Set up your overlay project</p> <p>This SMB-share will contain all newly created data for your project.</p> <p>In the config file, the location should be passed to the <code>overlay_root</code>-field. Any arguments specified to the <code>overlay_fs_args</code>-field will be passed to SMBFileSystem.</p> <pre><code>{\n    \"overlay_root\": \"smb:///shared_drive/copick_project/\",\n    \"overlay_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"temppath\": \"/shared_drive\",\n        \"auto_mkdir\": true,\n    }\n}\n</code></pre> More about <code>overlay_fs_args</code> ... <p>The <code>auto_mkdir</code>-flag is necessary to create copick-directories if they do not yet exist. The <code>tmpath</code>-flag is not strictly necessary, this depends on your SMB setup (e.g. if only a specific directory is shared).</p> <pre><code>{\n    \"overlay_root\": \"smb:///shared_drive/copick_project/\",\n    \"overlay_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"auto_mkdir\": true,\n    }\n}\n</code></pre> <p>Set up your static project</p> <p>In the case of CZ cryoET data portal datasets, setting up the static project is as easy as specifying one or multiple dataset IDs. The below example selects runs from datasets 10301 and 10302.</p> <pre><code>{\n  \"dataset_ids\": [\n    10301,\n    10302\n  ]\n}\n</code></pre> <p>Configuration Type</p> <p>When using the CZ cryoET data portal, the <code>config_type</code>-field should be set to <code>cryoet-data-portal</code>.</p> Cofiguration Template <pre><code>{\n    \"name\": \"Example Project\",\n    \"description\": \"This is an example project, demonstrating overlaying a ssh-backend on a CZ cryoET Data Portal dataset.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"label\": 1,\n            \"color\": [\n                0,\n                117,\n                220,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"label\": 2,\n            \"color\": [\n                251,\n                192,\n                147,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"label\": 3,\n            \"color\": [\n                200,\n                200,\n                200,\n                255\n            ],\n            \"radius\": 10.0\n        }\n    ],\n    \"user_id\": \"example.user\",\n    \"config_type\": \"cryoet_data_portal\",\n    \"overlay_root\": \"ssh:///hpc/storage/copick_project/\",\n    \"dataset_ids\": [\n        10301,\n        10302\n    ],\n    \"overlay_fs_args\": {\n        \"username\": \"user.name\",\n        \"host\": \"hpc.example.com\",\n        \"port\": 22\n    }\n}\n</code></pre> <p>Set up your overlay project</p> <p>This directory will contain all newly created data for your project.</p> <p>SSH authentication</p> <p>Copick will work best via SSH if you have set up passwordless SSH authentication. Refer to the SSH documentation for more information. In general, adding plain text passwords into copick configuration files is strongly discouraged.</p> <p>In cases of mandatory 2-FA authentication, you may need to set up an SSH tunnel to the remote filesystem, e.g.</p> <p><pre><code>ssh -L 2222:localhost:22 user.name@hpc.example.com\n</code></pre> and then use <code>localhost:2222</code> as the host in the config and commands below.</p> <p>Make sure it exists on the remote filesystem and is writable: <pre><code>ssh -p 22 user.name@hpc.example.com \"touch /path/to/copick_project\"\n# Replace port, user name and path to the project overlay with the correct values\n</code></pre></p> <p>If it does not yet exist, create it with the following command: <pre><code>ssh -p 22 user.name@hpc.example.com \"mkdir /path/to/copick_project\"\n# Replace port, user name and path to the project overlay with the correct values\n</code></pre></p> <p>In the config file, the location should be passed to the <code>overlay_root</code>-field. Any arguments specified to the <code>overlay_fs_args</code>-field will be passed to sshfs.SSHFileSystem.</p> <pre><code>{\n  \"overlay_root\": \"ssh:///path/to/copick_project/\",\n\n    \"overlay_fs_args\": {\n        \"username\": \"user.name\",\n        \"host\": \"hpc.example.com\",\n        \"port\": 22\n    }\n}\n</code></pre> More about <code>overlay_fs_args</code> ... <p>The <code>username</code>, <code>host</code> and <code>port</code>-fields are necessary to set up the SSH connection. Refer to the SSHFS documentation for detailed information.</p> <p>An easy way to use the SSH filesystem is to tunnel to the remote filesystem via SSH, e.g.</p> <pre><code>ssh -L 2222:localhost:22 user.name@hpc.example.com\n</code></pre> <p>and then use <code>localhost:2222</code> as the host in the config and commands above.</p> <pre><code>{\n  \"overlay_fs_args\": {\n      \"username\": \"user.name\",\n      \"host\": \"localhost\",\n      \"port\": 2222\n  }\n}\n</code></pre> <p>Set up your static project</p> <p>In the case of CZ cryoET data portal datasets, setting up the static project is as easy as specifying one or multiple dataset IDs. The below example selects runs from datasets 10301 and 10302.</p> <pre><code>{\n  \"dataset_ids\": [\n    10301,\n    10302\n  ]\n}\n</code></pre> <p>Configuration Type</p> <p>When using the CZ cryoET data portal, the <code>config_type</code>-field should be set to <code>cryoet-data-portal</code>.</p>"},{"location":"examples/setup/local/","title":"Local Project","text":"copick project setup with local storage. <p>In copick, a project has an overlay and (optionally) a static part. The overlay is where all user-created entities are stored and is writable. The static part is read-only and contains the input data. There are four ways of setting up local copick projects:</p> <ul> <li> <p> Option 1: local overlay-only</p> <p>Using this method, there will be a single, local project directory, all entities in the copick project will be writable. This is a good choice for test environments or projects you're working on alone on your own machine.</p> <p> Get config template</p> </li> <li> <p> Option 2: local overlay, local static</p> <p>Using this method there will be two project directories, static and overlay, respectively. Files in the \"static\"-project directory will be read-only within copick, while files in the \"overlay\"-directory will be writeable. This is a good choice if you want to maintain the input data.</p> <p> Get config template</p> </li> <li> <p> Option 3: local overlay, other static</p> <p>Using this method, any user-created copick entities will be stored in a local overlay, while static data (e.g. tomograms and baseline annotations) are stored in a different storage backend. This will be useful when multiple users are curating a dataset that is available on a shared drive, in the cloud, via ssh or on the data portal.</p> <p> Get config templates</p> </li> <li> <p> Option 4: other overlay, local static</p> <p>Using this method, the static part of the project will be stored locally, while new copick entities are written to another storage backend. This could be useful when results should be uploaded to a common storage server, but a local copy of the data exists.</p> <p> Get config templates</p> </li> </ul>"},{"location":"examples/setup/local/#option-1-a-local-overlay-only-copick-project","title":"Option 1: A local overlay-only copick project","text":""},{"location":"examples/setup/local/#set-up-your-project-root-directory","title":"Set up your project root directory","text":"<p>In order to create an <code>overlay-only</code>-project we first need to set up one project directory.</p> <pre><code>mkdir copick_project\n</code></pre>"},{"location":"examples/setup/local/#create-the-config-file","title":"Create the config file","text":"<p>All information necessary to use the copick API is stored in a config file in <code>json</code>-Format. This has to be created before accessing the data is possible.</p> <p>Create a json file with your favorite editor and paste the below template. Fill in the abolute path of the copick root directory as indicated below.</p> <pre><code>vi copick_config.json\n</code></pre> Cofiguration Template <pre><code>{\n    \"name\": \"Example Project\",\n    \"description\": \"This is an example project, demonstrating an overlay-only local-backend project.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"label\": 1,\n            \"color\": [\n                0,\n                117,\n                220,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"label\": 2,\n            \"color\": [\n                251,\n                192,\n                147,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"label\": 3,\n            \"color\": [\n                200,\n                200,\n                200,\n                255\n            ],\n            \"radius\": 10.0\n        }\n    ],\n    \"user_id\": \"example.user\",\n    \"config_type\": \"filesystem\",\n    \"overlay_root\": \"local:///path/to/copick_project/\",\n    \"overlay_fs_args\": {\n        \"auto_mkdir\": true\n    }\n}\n</code></pre> <p>The project is now set up, you can now add objects, add tomograms or store annotations.</p>"},{"location":"examples/setup/local/#option-2-a-local-overlay-local-static-copick-project","title":"Option 2: A local overlay, local static copick project","text":""},{"location":"examples/setup/local/#set-up-your-project-root-directory_1","title":"Set up your project root directory","text":"<p>In order to create an <code>static/overlay</code>-project we first need to set up two project directories, one to store the static data, and another to store any new or curated annotations.</p> <pre><code>mkdir copick_project_static\nmkdir copick_project\n</code></pre>"},{"location":"examples/setup/local/#create-the-config-file_1","title":"Create the config file","text":"<p>All information necessary to use the copick API is stored in a config file in <code>json</code>-Format. This has to be created before accessing the data is possible.</p> <p>Create a json file with your favorite editor and paste the below template. Fill in the abolute path of the copick root directory as indicated below.</p> <pre><code>vi copick_config.json\n</code></pre> Cofiguration Template <pre><code>{\n    \"name\": \"Example Project\",\n    \"description\": \"This is an example project, demonstrating overlaying a local-backend ona project in a local-backend.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"label\": 1,\n            \"color\": [\n                0,\n                117,\n                220,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"label\": 2,\n            \"color\": [\n                251,\n                192,\n                147,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"label\": 3,\n            \"color\": [\n                200,\n                200,\n                200,\n                255\n            ],\n            \"radius\": 10.0\n        }\n    ],\n    \"user_id\": \"example.user\",\n    \"config_type\": \"filesystem\",\n    \"overlay_root\": \"local:///path/to/copick_project/\",\n    \"static_root\": \"local:///path/to/copick_project_static/\",\n    \"overlay_fs_args\": {\n        \"auto_mkdir\": true\n    },\n    \"static_fs_args\": {\n        \"auto_mkdir\": true\n    }\n}\n</code></pre>"},{"location":"examples/setup/local/#option-3-a-local-overlay-other-static-copick-project","title":"Option 3: A local overlay, other static copick project","text":"<p>Choose your other static backend:</p> CZ cryoET Data PortalSMB ShareAWS S3SSH Cofiguration Template <pre><code>{\n    \"name\": \"Example Project\",\n    \"description\": \"This is an example project, demonstrating overlaying a local-backend on a CZ cryoET Data Portal dataset.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"label\": 1,\n            \"color\": [\n                0,\n                117,\n                220,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"label\": 2,\n            \"color\": [\n                251,\n                192,\n                147,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"label\": 3,\n            \"color\": [\n                200,\n                200,\n                200,\n                255\n            ],\n            \"radius\": 10.0\n        }\n    ],\n    \"user_id\": \"example.user\",\n    \"config_type\": \"cryoet_data_portal\",\n    \"overlay_root\": \"local:///path/to/copick_project/\",\n    \"dataset_ids\": [\n        10301,\n        10302\n    ],\n    \"overlay_fs_args\": {\n        \"auto_mkdir\": true\n    }\n}\n</code></pre> <p>Set up your overlay project</p> <p>This directory will contain all newly created data for your project.</p> <p>Make sure it exists on the filesystem and is writable: <pre><code>touch /path/to/copick_project\n# Replace /path/to/copick_project with the path to your project overlay\n</code></pre></p> <p>If it does not yet exist, create it with the following command: <pre><code>mkdir /path/to/copick_project\n# Replace /path/to/copick_project with the path to your project overlay\n</code></pre></p> <p>In the config file, the location should be passed to the <code>overlay_root</code>-field. Any arguments specified to the <code>overlay_fs_args</code>-field will be passed to LocalFileSystem.</p> <pre><code>{\n  \"overlay_root\": \"local:///path/to/copick_project\",\n  \"overlay_fs_args\": {\n    \"auto_mkdir\": true\n  }\n}\n</code></pre> More about <code>overlay_fs_args</code> ... <p>The <code>auto_mkdir</code>-flag is necessary to create copick-directories if they do not yet exist.</p> <p>Set up your static project</p> <p>In the case of CZ cryoET data portal datasets, setting up the static project is as easy as specifying one or multiple dataset IDs. The below example selects runs from datasets 10301 and 10302.</p> <pre><code>{\n  \"dataset_ids\": [\n    10301,\n    10302\n  ]\n}\n</code></pre> <p>Configuration Type</p> <p>When using the CZ cryoET data portal, the <code>config_type</code>-field should be set to <code>cryoet-data-portal</code>.</p> Cofiguration Template <pre><code>{\n    \"name\": \"Example Project\",\n    \"description\": \"This is an example project, demonstrating overlaying a local-backend ona project in a smb-backend.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"label\": 1,\n            \"color\": [\n                0,\n                117,\n                220,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"label\": 2,\n            \"color\": [\n                251,\n                192,\n                147,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"label\": 3,\n            \"color\": [\n                200,\n                200,\n                200,\n                255\n            ],\n            \"radius\": 10.0\n        }\n    ],\n    \"user_id\": \"example.user\",\n    \"config_type\": \"filesystem\",\n    \"overlay_root\": \"local:///path/to/copick_project/\",\n    \"static_root\": \"smb:///shared_drive/copick_project_static/\",\n    \"overlay_fs_args\": {\n        \"auto_mkdir\": true\n    },\n    \"static_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"temppath\": \"/shared_drive\",\n        \"auto_mkdir\": true\n    }\n}\n</code></pre> <p>Set up your overlay project</p> <p>This directory will contain all newly created data for your project.</p> <p>Make sure it exists on the filesystem and is writable: <pre><code>touch /path/to/copick_project\n# Replace /path/to/copick_project with the path to your project overlay\n</code></pre></p> <p>If it does not yet exist, create it with the following command: <pre><code>mkdir /path/to/copick_project\n# Replace /path/to/copick_project with the path to your project overlay\n</code></pre></p> <p>In the config file, the location should be passed to the <code>overlay_root</code>-field. Any arguments specified to the <code>overlay_fs_args</code>-field will be passed to LocalFileSystem.</p> <pre><code>{\n  \"overlay_root\": \"local:///path/to/copick_project\",\n  \"overlay_fs_args\": {\n    \"auto_mkdir\": true\n  }\n}\n</code></pre> More about <code>overlay_fs_args</code> ... <p>The <code>auto_mkdir</code>-flag is necessary to create copick-directories if they do not yet exist.</p> <p>Set up your static project</p> <p>This SMB-share will contain all static data for your project.</p> <p>In the config file, the location should be passed to the <code>static_root</code>-field. Any arguments specified to the <code>static_fs_args</code>-field will be passed to SMBFileSystem.</p> <pre><code>{\n    \"static_root\": \"smb:///shared_drive/copick_project/\",\n    \"static_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"temppath\": \"/shared_drive\",\n        \"auto_mkdir\": true,\n    }\n}\n</code></pre> More about <code>static_fs_args</code> ... <p>The <code>auto_mkdir</code>-flag is necessary to create copick-directories if they do not yet exist. The <code>tmpath</code>-flag is not strictly necessary, this depends on your SMB setup (e.g. if only a specific directory is shared).</p> <pre><code>{\n    \"static_root\": \"smb:///shared_drive/copick_project/\",\n    \"static_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"auto_mkdir\": true,\n    }\n}\n</code></pre> Cofiguration Template <pre><code>{\n    \"name\": \"Example Project\",\n    \"description\": \"This is an example project, demonstrating overlaying a local-backend ona project in a s3-backend.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"label\": 1,\n            \"color\": [\n                0,\n                117,\n                220,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"label\": 2,\n            \"color\": [\n                251,\n                192,\n                147,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"label\": 3,\n            \"color\": [\n                200,\n                200,\n                200,\n                255\n            ],\n            \"radius\": 10.0\n        }\n    ],\n    \"user_id\": \"example.user\",\n    \"config_type\": \"filesystem\",\n    \"overlay_root\": \"local:///path/to/copick_project/\",\n    \"static_root\": \"s3://bucket/copick_project_static/\",\n    \"overlay_fs_args\": {\n        \"auto_mkdir\": true\n    },\n    \"static_fs_args\": {\n        \"profile\": \"your_profile\"\n    }\n}\n</code></pre> <p>Set up your overlay project</p> <p>This directory will contain all newly created data for your project.</p> <p>Make sure it exists on the filesystem and is writable: <pre><code>touch /path/to/copick_project\n# Replace /path/to/copick_project with the path to your project overlay\n</code></pre></p> <p>If it does not yet exist, create it with the following command: <pre><code>mkdir /path/to/copick_project\n# Replace /path/to/copick_project with the path to your project overlay\n</code></pre></p> <p>In the config file, the location should be passed to the <code>overlay_root</code>-field. Any arguments specified to the <code>overlay_fs_args</code>-field will be passed to LocalFileSystem.</p> <pre><code>{\n  \"overlay_root\": \"local:///path/to/copick_project\",\n  \"overlay_fs_args\": {\n    \"auto_mkdir\": true\n  }\n}\n</code></pre> More about <code>overlay_fs_args</code> ... <p>The <code>auto_mkdir</code>-flag is necessary to create copick-directories if they do not yet exist.</p> <p>Set up your static project</p> <p>This S3 URI will contain all static data for your project.</p> <p>Make sure the intended S3 bucket is writable: <pre><code>echo \"Hello, World!\" &gt; test.txt\naws s3 cp test.txt s3://your-bucket-name/copick_project_static/test.txt\naws s3 ls s3://your-bucket-name/copick_project_static/\naws s3 rm s3://your-bucket-name/copick_project_static/test.txt\n# Replace s3://your-bucket-name/copick_project/ with your S3 URI\n</code></pre></p> <p>AWS authentication</p> <p>Make sure you have the necessary AWS credentials set up and available in the shell you're running the above commands in. Refer to the AWS CLI documentation for more information.</p> <p>In the config file, the location should be passed to the <code>static_root</code>-field. Any arguments specified to the <code>static_fs_args</code>-field will be passed to S3FileSystem. <code>profile</code> should be one of the profiles set up in your <code>~/.aws/credentials</code> file.</p> <pre><code>{\n  \"static_root\": \"s3://bucket-name/copick_project_static/\",\n  \"static_fs_args\": {\n        \"profile\": \"example_profile\"\n    }\n}\n</code></pre> More about <code>static_fs_args</code> ... <p>Specifying <code>profile</code> is one possible way of setting up AWS credentials. Refer to the S3FS documentation for detailed information.</p> <p>For local MinIO buckets, the following config may be appropriate:</p> <pre><code>{\n    \"static_fs_args\": {\n        \"key\":\"bucketkey\",\n        \"secret\":\"bucketsecret\",\n        \"endpoint_url\":\"http://10.30.121.49:7070\",\n        \"client_kwargs\":{\n            \"region_name\":\"us-east-1\"\n        }\n}\n</code></pre> Cofiguration Template <pre><code>{\n    \"name\": \"Example Project\",\n    \"description\": \"This is an example project, demonstrating overlaying a local-backend ona project in a ssh-backend.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"label\": 1,\n            \"color\": [\n                0,\n                117,\n                220,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"label\": 2,\n            \"color\": [\n                251,\n                192,\n                147,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"label\": 3,\n            \"color\": [\n                200,\n                200,\n                200,\n                255\n            ],\n            \"radius\": 10.0\n        }\n    ],\n    \"user_id\": \"example.user\",\n    \"config_type\": \"filesystem\",\n    \"overlay_root\": \"local:///path/to/copick_project/\",\n    \"static_root\": \"ssh:///hpc/storage/copick_project_static/\",\n    \"overlay_fs_args\": {\n        \"auto_mkdir\": true\n    },\n    \"static_fs_args\": {\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"host\": \"hpc.example.com\",\n        \"port\": 22\n    }\n}\n</code></pre> <p>Set up your overlay project</p> <p>This directory will contain all newly created data for your project.</p> <p>Make sure it exists on the filesystem and is writable: <pre><code>touch /path/to/copick_project\n# Replace /path/to/copick_project with the path to your project overlay\n</code></pre></p> <p>If it does not yet exist, create it with the following command: <pre><code>mkdir /path/to/copick_project\n# Replace /path/to/copick_project with the path to your project overlay\n</code></pre></p> <p>In the config file, the location should be passed to the <code>overlay_root</code>-field. Any arguments specified to the <code>overlay_fs_args</code>-field will be passed to LocalFileSystem.</p> <pre><code>{\n  \"overlay_root\": \"local:///path/to/copick_project\",\n  \"overlay_fs_args\": {\n    \"auto_mkdir\": true\n  }\n}\n</code></pre> More about <code>overlay_fs_args</code> ... <p>The <code>auto_mkdir</code>-flag is necessary to create copick-directories if they do not yet exist.</p> <p>Set up your static project</p> <p>This directory will contain all static data for your project.</p> <p>SSH authentication</p> <p>Copick will work best via SSH if you have set up passwordless SSH authentication. Refer to the SSH documentation for more information. In general, adding plain text passwords into copick configuration files is strongly discouraged.</p> <p>In cases of mandatory 2-FA authentication, you may need to set up an SSH tunnel to the remote filesystem, e.g.</p> <p><pre><code>ssh -L 2222:localhost:22 user.name@hpc.example.com\n</code></pre> and then use <code>localhost:2222</code> as the host in the config and commands below.</p> <p>Make sure it exists on the remote filesystem and is writable: <pre><code>ssh -p 22 user.name@hpc.example.com \"touch /path/to/copick_project_static\"\n# Replace port, user name and path to the static project with the correct values\n</code></pre></p> <p>If it does not yet exist, create it with the following command: <pre><code>ssh -p 22 user.name@hpc.example.com \"mkdir /path/to/copick_project_static\"\n# Replace port, user name and path to the static project with the correct values\n</code></pre></p> <p>In the config file, the location should be passed to the <code>static_root</code>-field. Any arguments specified to the <code>static_fs_args</code>-field will be passed to sshfs.SSHFileSystem.</p> <pre><code>{\n  \"static_root\": \"ssh:///path/to/copick_project_static/\",\n\n    \"static_fs_args\": {\n        \"username\": \"user.name\",\n        \"host\": \"hpc.example.com\",\n        \"port\": 22\n    }\n}\n</code></pre> More about <code>static_fs_args</code> ... <p>The <code>username</code>, <code>host</code> and <code>port</code>-fields are necessary to set up the SSH connection. Refer to the SSHFS documentation for detailed information.</p> <p>An easy way to use the SSH filesystem is to tunnel to the remote filesystem via SSH, e.g.</p> <pre><code>ssh -L 2222:localhost:22 user.name@hpc.example.com\n</code></pre> <p>and then use <code>localhost:2222</code> as the host in the config and commands above.</p> <pre><code>{\n  \"static_fs_args\": {\n      \"username\": \"user.name\",\n      \"host\": \"localhost\",\n      \"port\": 2222\n  }\n}\n</code></pre>"},{"location":"examples/setup/local/#option-4-an-other-overlay-local-static-copick-project","title":"Option 4: An other overlay, local static copick project","text":"<p>Choose your other overlay backend:</p> SMB ShareAWS S3SSH Cofiguration Template <pre><code>{\n    \"name\": \"Example Project\",\n    \"description\": \"This is an example project, demonstrating overlaying a smb-backend ona project in a local-backend.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"label\": 1,\n            \"color\": [\n                0,\n                117,\n                220,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"label\": 2,\n            \"color\": [\n                251,\n                192,\n                147,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"label\": 3,\n            \"color\": [\n                200,\n                200,\n                200,\n                255\n            ],\n            \"radius\": 10.0\n        }\n    ],\n    \"user_id\": \"example.user\",\n    \"config_type\": \"filesystem\",\n    \"overlay_root\": \"smb:///shared_drive/copick_project/\",\n    \"static_root\": \"local:///path/to/copick_project_static/\",\n    \"overlay_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"temppath\": \"/shared_drive\",\n        \"auto_mkdir\": true\n    },\n    \"static_fs_args\": {\n        \"auto_mkdir\": true\n    }\n}\n</code></pre> <p>Set up your overlay project</p> <p>This SMB-share will contain all newly created data for your project.</p> <p>In the config file, the location should be passed to the <code>overlay_root</code>-field. Any arguments specified to the <code>overlay_fs_args</code>-field will be passed to SMBFileSystem.</p> <pre><code>{\n    \"overlay_root\": \"smb:///shared_drive/copick_project/\",\n    \"overlay_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"temppath\": \"/shared_drive\",\n        \"auto_mkdir\": true,\n    }\n}\n</code></pre> More about <code>overlay_fs_args</code> ... <p>The <code>auto_mkdir</code>-flag is necessary to create copick-directories if they do not yet exist. The <code>tmpath</code>-flag is not strictly necessary, this depends on your SMB setup (e.g. if only a specific directory is shared).</p> <pre><code>{\n    \"overlay_root\": \"smb:///shared_drive/copick_project/\",\n    \"overlay_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"auto_mkdir\": true,\n    }\n}\n</code></pre> <p>Set up your static project</p> <p>This directory will contain all static data for your project.</p> <p>Make sure it exists on the filesystem and is writable: <pre><code>touch /path/to/copick_project_static\n# Replace /path/to/copick_project with the path to your static project\n</code></pre></p> <p>If it does not yet exist, create it with the following command: <pre><code>mkdir /path/to/copick_project_static\n# Replace /path/to/copick_project with the path to your static project\n</code></pre></p> <p>In the config file, the location should be passed to the <code>static_root</code>-field. Any arguments specified to the <code>static_fs_args</code>-field will be passed to LocalFileSystem.</p> <pre><code>{\n  \"static_root\": \"local:///path/to/copick_project\",\n  \"static_fs_args\": {\n    \"auto_mkdir\": true\n  }\n}\n</code></pre> More about <code>static_fs_args</code> ... <p>The <code>auto_mkdir</code>-flag is necessary to create copick-directories if they do not yet exist.</p> Cofiguration Template <pre><code>{\n    \"name\": \"Example Project\",\n    \"description\": \"This is an example project, demonstrating overlaying a s3-backend ona project in a local-backend.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"label\": 1,\n            \"color\": [\n                0,\n                117,\n                220,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"label\": 2,\n            \"color\": [\n                251,\n                192,\n                147,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"label\": 3,\n            \"color\": [\n                200,\n                200,\n                200,\n                255\n            ],\n            \"radius\": 10.0\n        }\n    ],\n    \"user_id\": \"example.user\",\n    \"config_type\": \"filesystem\",\n    \"overlay_root\": \"s3://bucket/copick_project/\",\n    \"static_root\": \"local:///path/to/copick_project_static/\",\n    \"overlay_fs_args\": {\n        \"profile\": \"your_profile\"\n    },\n    \"static_fs_args\": {\n        \"auto_mkdir\": true\n    }\n}\n</code></pre> <p>Set up your overlay project</p> <p>This S3 URI will contain all newly created data for your project.</p> <p>Make sure the intended S3 bucket is writable: <pre><code>echo \"Hello, World!\" &gt; test.txt\naws s3 cp test.txt s3://your-bucket-name/copick_project/test.txt\naws s3 ls s3://your-bucket-name/copick_project/\naws s3 rm s3://your-bucket-name/copick_project/test.txt\n# Replace s3://your-bucket-name/copick_project/ with your S3 URI\n</code></pre></p> <p>AWS authentication</p> <p>Make sure you have the necessary AWS credentials set up and available in the shell you're running the above commands in. Refer to the AWS CLI documentation for more information.</p> <p>In the config file, the location should be passed to the <code>overlay_root</code>-field. Any arguments specified to the <code>overlay_fs_args</code>-field will be passed to S3FileSystem. <code>profile</code> should be one of the profiles set up in your <code>~/.aws/credentials</code> file.</p> <pre><code>{\n  \"overlay_root\": \"s3://bucket-name/copick_project/\",\n  \"overlay_fs_args\": {\n        \"profile\": \"example_profile\"\n    }\n}\n</code></pre> More about <code>overlay_fs_args</code> ... <p>Specifying <code>profile</code> is one possible way of setting up AWS credentials. Refer to the S3FS documentation for detailed information.</p> <p>For local MinIO buckets, the following config may be appropriate:</p> <pre><code>{\n    \"overlay_fs_args\": {\n        \"key\":\"bucketkey\",\n        \"secret\":\"bucketsecret\",\n        \"endpoint_url\":\"http://10.30.121.49:7070\",\n        \"client_kwargs\":{\n            \"region_name\":\"us-east-1\"\n        }\n}\n</code></pre> <p>Set up your static project</p> <p>This directory will contain all static data for your project.</p> <p>Make sure it exists on the filesystem and is writable: <pre><code>touch /path/to/copick_project_static\n# Replace /path/to/copick_project with the path to your static project\n</code></pre></p> <p>If it does not yet exist, create it with the following command: <pre><code>mkdir /path/to/copick_project_static\n# Replace /path/to/copick_project with the path to your static project\n</code></pre></p> <p>In the config file, the location should be passed to the <code>static_root</code>-field. Any arguments specified to the <code>static_fs_args</code>-field will be passed to LocalFileSystem.</p> <pre><code>{\n  \"static_root\": \"local:///path/to/copick_project\",\n  \"static_fs_args\": {\n    \"auto_mkdir\": true\n  }\n}\n</code></pre> More about <code>static_fs_args</code> ... <p>The <code>auto_mkdir</code>-flag is necessary to create copick-directories if they do not yet exist.</p> Cofiguration Template <pre><code>{\n    \"name\": \"Example Project\",\n    \"description\": \"This is an example project, demonstrating overlaying a ssh-backend ona project in a local-backend.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"label\": 1,\n            \"color\": [\n                0,\n                117,\n                220,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"label\": 2,\n            \"color\": [\n                251,\n                192,\n                147,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"label\": 3,\n            \"color\": [\n                200,\n                200,\n                200,\n                255\n            ],\n            \"radius\": 10.0\n        }\n    ],\n    \"user_id\": \"example.user\",\n    \"config_type\": \"filesystem\",\n    \"overlay_root\": \"ssh:///hpc/storage/copick_project/\",\n    \"static_root\": \"local:///path/to/copick_project_static/\",\n    \"overlay_fs_args\": {\n        \"username\": \"user.name\",\n        \"host\": \"hpc.example.com\",\n        \"port\": 22\n    },\n    \"static_fs_args\": {\n        \"auto_mkdir\": true\n    }\n}\n</code></pre> <p>Set up your overlay project</p> <p>This directory will contain all newly created data for your project.</p> <p>SSH authentication</p> <p>Copick will work best via SSH if you have set up passwordless SSH authentication. Refer to the SSH documentation for more information. In general, adding plain text passwords into copick configuration files is strongly discouraged.</p> <p>In cases of mandatory 2-FA authentication, you may need to set up an SSH tunnel to the remote filesystem, e.g.</p> <p><pre><code>ssh -L 2222:localhost:22 user.name@hpc.example.com\n</code></pre> and then use <code>localhost:2222</code> as the host in the config and commands below.</p> <p>Make sure it exists on the remote filesystem and is writable: <pre><code>ssh -p 22 user.name@hpc.example.com \"touch /path/to/copick_project\"\n# Replace port, user name and path to the project overlay with the correct values\n</code></pre></p> <p>If it does not yet exist, create it with the following command: <pre><code>ssh -p 22 user.name@hpc.example.com \"mkdir /path/to/copick_project\"\n# Replace port, user name and path to the project overlay with the correct values\n</code></pre></p> <p>In the config file, the location should be passed to the <code>overlay_root</code>-field. Any arguments specified to the <code>overlay_fs_args</code>-field will be passed to sshfs.SSHFileSystem.</p> <pre><code>{\n  \"overlay_root\": \"ssh:///path/to/copick_project/\",\n\n    \"overlay_fs_args\": {\n        \"username\": \"user.name\",\n        \"host\": \"hpc.example.com\",\n        \"port\": 22\n    }\n}\n</code></pre> More about <code>overlay_fs_args</code> ... <p>The <code>username</code>, <code>host</code> and <code>port</code>-fields are necessary to set up the SSH connection. Refer to the SSHFS documentation for detailed information.</p> <p>An easy way to use the SSH filesystem is to tunnel to the remote filesystem via SSH, e.g.</p> <pre><code>ssh -L 2222:localhost:22 user.name@hpc.example.com\n</code></pre> <p>and then use <code>localhost:2222</code> as the host in the config and commands above.</p> <pre><code>{\n  \"overlay_fs_args\": {\n      \"username\": \"user.name\",\n      \"host\": \"localhost\",\n      \"port\": 2222\n  }\n}\n</code></pre> <p>Set up your static project</p> <p>This directory will contain all static data for your project.</p> <p>Make sure it exists on the filesystem and is writable: <pre><code>touch /path/to/copick_project_static\n# Replace /path/to/copick_project with the path to your static project\n</code></pre></p> <p>If it does not yet exist, create it with the following command: <pre><code>mkdir /path/to/copick_project_static\n# Replace /path/to/copick_project with the path to your static project\n</code></pre></p> <p>In the config file, the location should be passed to the <code>static_root</code>-field. Any arguments specified to the <code>static_fs_args</code>-field will be passed to LocalFileSystem.</p> <pre><code>{\n  \"static_root\": \"local:///path/to/copick_project\",\n  \"static_fs_args\": {\n    \"auto_mkdir\": true\n  }\n}\n</code></pre> More about <code>static_fs_args</code> ... <p>The <code>auto_mkdir</code>-flag is necessary to create copick-directories if they do not yet exist.</p>"},{"location":"examples/setup/shared/","title":"Shared Project","text":"copick project setup with SMB shared drive. <p>In copick, a project has an overlay and (optionally) a static part. The overlay is where all user-created entities are stored and is writable. The static part is read-only and contains the input data. There are four ways of setting up copick projects via SMB share:</p> <ul> <li> <p> Option 1: SMB overlay-only</p> <p>Using this method, there will be a single, shared project directory, all entities in the copick project will be writable.</p> <p> Get config template</p> </li> <li> <p> Option 2: SMB overlay, SMB static</p> <p>Using this method there will be two project directories, static and overlay, respectively. Files in the \"static\"-project directory will be read-only within copick, while files in the \"overlay\"-directory will be writeable. This is a good choice if you want to maintain the input data.</p> <p> Get config template</p> </li> <li> <p> Option 3: SMB overlay, other static</p> <p>Using this method, any user-created copick entities will be stored in a shared overlay, while static data (e.g. tomograms and baseline annotations) are stored in a different storage backend. This will be useful when multiple users are curating a dataset and have access to local copies of the static data.</p> <p> Get config templates</p> </li> <li> <p> Option 4: other overlay, SMB static</p> <p>Using this method, the static part of the project will be stored in a shared directory, while new copick entities are written to another storage backend. This could be useful when curating a large set of data with a group.</p> <p> Get config templates</p> </li> </ul>"},{"location":"examples/setup/shared/#option-1-a-smb-overlay-only-copick-project","title":"Option 1: A SMB overlay-only copick project","text":""},{"location":"examples/setup/shared/#set-up-your-project-root-directory","title":"Set up your project root directory","text":"<p>The following example assumes that you have a shared directory on a network drive that you can access via SMB.</p>"},{"location":"examples/setup/shared/#create-the-config-file","title":"Create the config file","text":"<p>All information necessary to use the copick API is stored in a config file in <code>json</code>-Format. This has to be created before accessing the data is possible.</p> <p>Create a json file with your favorite editor and paste the below template. Fill in the abolute path of the copick root directory as indicated below.</p> <pre><code>vi copick_config.json\n</code></pre> Cofiguration Template <pre><code>{\n    \"name\": \"Example Project\",\n    \"description\": \"This is an example project, demonstrating an overlay-only smb-backend project.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"label\": 1,\n            \"color\": [\n                0,\n                117,\n                220,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"label\": 2,\n            \"color\": [\n                251,\n                192,\n                147,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"label\": 3,\n            \"color\": [\n                200,\n                200,\n                200,\n                255\n            ],\n            \"radius\": 10.0\n        }\n    ],\n    \"user_id\": \"example.user\",\n    \"config_type\": \"filesystem\",\n    \"overlay_root\": \"smb:///shared_drive/copick_project/\",\n    \"overlay_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"temppath\": \"/shared_drive\",\n        \"auto_mkdir\": true\n    }\n}\n</code></pre> <p>The project is now set up, you can now add objects, add tomograms or store annotations.</p>"},{"location":"examples/setup/shared/#option-2-a-smb-overlay-smb-static-copick-project","title":"Option 2: A SMB overlay, SMB static copick project","text":""},{"location":"examples/setup/shared/#set-up-your-project-root-directory_1","title":"Set up your project root directory","text":"<p>The following example assumes that you have two shared directories on a network drive that you can access via SMB.</p>"},{"location":"examples/setup/shared/#create-the-config-file_1","title":"Create the config file","text":"<p>All information necessary to use the copick API is stored in a config file in <code>json</code>-Format. This has to be created before accessing the data is possible.</p> <p>Create a json file with your favorite editor and paste the below template. Fill in the abolute path of the copick root directory as indicated below.</p> <pre><code>vi copick_config.json\n</code></pre> Cofiguration Template <pre><code>{\n    \"name\": \"Example Project\",\n    \"description\": \"This is an example project, demonstrating overlaying a smb-backend ona project in a smb-backend.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"label\": 1,\n            \"color\": [\n                0,\n                117,\n                220,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"label\": 2,\n            \"color\": [\n                251,\n                192,\n                147,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"label\": 3,\n            \"color\": [\n                200,\n                200,\n                200,\n                255\n            ],\n            \"radius\": 10.0\n        }\n    ],\n    \"user_id\": \"example.user\",\n    \"config_type\": \"filesystem\",\n    \"overlay_root\": \"smb:///shared_drive/copick_project/\",\n    \"static_root\": \"smb:///shared_drive/copick_project_static/\",\n    \"overlay_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"temppath\": \"/shared_drive\",\n        \"auto_mkdir\": true\n    },\n    \"static_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"temppath\": \"/shared_drive\",\n        \"auto_mkdir\": true\n    }\n}\n</code></pre>"},{"location":"examples/setup/shared/#option-3-a-smb-overlay-other-static-copick-project","title":"Option 3: A SMB overlay, other static copick project","text":"<p>Choose your other static backend:</p> CZ cryoET Data PortalLocalAWS S3SSH Cofiguration Template <pre><code>{\n    \"name\": \"Example Project\",\n    \"description\": \"This is an example project, demonstrating overlaying a smb-backend on a CZ cryoET Data Portal dataset.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"label\": 1,\n            \"color\": [\n                0,\n                117,\n                220,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"label\": 2,\n            \"color\": [\n                251,\n                192,\n                147,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"label\": 3,\n            \"color\": [\n                200,\n                200,\n                200,\n                255\n            ],\n            \"radius\": 10.0\n        }\n    ],\n    \"user_id\": \"example.user\",\n    \"config_type\": \"cryoet_data_portal\",\n    \"overlay_root\": \"smb:///shared_drive/copick_project/\",\n    \"dataset_ids\": [\n        10301,\n        10302\n    ],\n    \"overlay_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"temppath\": \"/shared_drive\",\n        \"auto_mkdir\": true\n    }\n}\n</code></pre> <p>Set up your overlay project</p> <p>This SMB-share will contain all newly created data for your project.</p> <p>In the config file, the location should be passed to the <code>overlay_root</code>-field. Any arguments specified to the <code>overlay_fs_args</code>-field will be passed to SMBFileSystem.</p> <pre><code>{\n    \"overlay_root\": \"smb:///shared_drive/copick_project/\",\n    \"overlay_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"temppath\": \"/shared_drive\",\n        \"auto_mkdir\": true,\n    }\n}\n</code></pre> More about <code>overlay_fs_args</code> ... <p>The <code>auto_mkdir</code>-flag is necessary to create copick-directories if they do not yet exist. The <code>tmpath</code>-flag is not strictly necessary, this depends on your SMB setup (e.g. if only a specific directory is shared).</p> <pre><code>{\n    \"overlay_root\": \"smb:///shared_drive/copick_project/\",\n    \"overlay_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"auto_mkdir\": true,\n    }\n}\n</code></pre> <p>Set up your static project</p> <p>In the case of CZ cryoET data portal datasets, setting up the static project is as easy as specifying one or multiple dataset IDs. The below example selects runs from datasets 10301 and 10302.</p> <pre><code>{\n  \"dataset_ids\": [\n    10301,\n    10302\n  ]\n}\n</code></pre> <p>Configuration Type</p> <p>When using the CZ cryoET data portal, the <code>config_type</code>-field should be set to <code>cryoet-data-portal</code>.</p> Cofiguration Template <pre><code>{\n    \"name\": \"Example Project\",\n    \"description\": \"This is an example project, demonstrating overlaying a smb-backend ona project in a local-backend.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"label\": 1,\n            \"color\": [\n                0,\n                117,\n                220,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"label\": 2,\n            \"color\": [\n                251,\n                192,\n                147,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"label\": 3,\n            \"color\": [\n                200,\n                200,\n                200,\n                255\n            ],\n            \"radius\": 10.0\n        }\n    ],\n    \"user_id\": \"example.user\",\n    \"config_type\": \"filesystem\",\n    \"overlay_root\": \"smb:///shared_drive/copick_project/\",\n    \"static_root\": \"local:///path/to/copick_project_static/\",\n    \"overlay_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"temppath\": \"/shared_drive\",\n        \"auto_mkdir\": true\n    },\n    \"static_fs_args\": {\n        \"auto_mkdir\": true\n    }\n}\n</code></pre> <p>Set up your overlay project</p> <p>This SMB-share will contain all newly created data for your project.</p> <p>In the config file, the location should be passed to the <code>overlay_root</code>-field. Any arguments specified to the <code>overlay_fs_args</code>-field will be passed to SMBFileSystem.</p> <pre><code>{\n    \"overlay_root\": \"smb:///shared_drive/copick_project/\",\n    \"overlay_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"temppath\": \"/shared_drive\",\n        \"auto_mkdir\": true,\n    }\n}\n</code></pre> More about <code>overlay_fs_args</code> ... <p>The <code>auto_mkdir</code>-flag is necessary to create copick-directories if they do not yet exist. The <code>tmpath</code>-flag is not strictly necessary, this depends on your SMB setup (e.g. if only a specific directory is shared).</p> <pre><code>{\n    \"overlay_root\": \"smb:///shared_drive/copick_project/\",\n    \"overlay_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"auto_mkdir\": true,\n    }\n}\n</code></pre> <p>Set up your static project</p> <p>This directory will contain all static data for your project.</p> <p>Make sure it exists on the filesystem and is writable: <pre><code>touch /path/to/copick_project_static\n# Replace /path/to/copick_project with the path to your static project\n</code></pre></p> <p>If it does not yet exist, create it with the following command: <pre><code>mkdir /path/to/copick_project_static\n# Replace /path/to/copick_project with the path to your static project\n</code></pre></p> <p>In the config file, the location should be passed to the <code>static_root</code>-field. Any arguments specified to the <code>static_fs_args</code>-field will be passed to LocalFileSystem.</p> <pre><code>{\n  \"static_root\": \"local:///path/to/copick_project\",\n  \"static_fs_args\": {\n    \"auto_mkdir\": true\n  }\n}\n</code></pre> More about <code>static_fs_args</code> ... <p>The <code>auto_mkdir</code>-flag is necessary to create copick-directories if they do not yet exist.</p> Cofiguration Template <pre><code>{\n    \"name\": \"Example Project\",\n    \"description\": \"This is an example project, demonstrating overlaying a smb-backend ona project in a s3-backend.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"label\": 1,\n            \"color\": [\n                0,\n                117,\n                220,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"label\": 2,\n            \"color\": [\n                251,\n                192,\n                147,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"label\": 3,\n            \"color\": [\n                200,\n                200,\n                200,\n                255\n            ],\n            \"radius\": 10.0\n        }\n    ],\n    \"user_id\": \"example.user\",\n    \"config_type\": \"filesystem\",\n    \"overlay_root\": \"smb:///shared_drive/copick_project/\",\n    \"static_root\": \"s3://bucket/copick_project_static/\",\n    \"overlay_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"temppath\": \"/shared_drive\",\n        \"auto_mkdir\": true\n    },\n    \"static_fs_args\": {\n        \"profile\": \"your_profile\"\n    }\n}\n</code></pre> <p>Set up your overlay project</p> <p>This SMB-share will contain all newly created data for your project.</p> <p>In the config file, the location should be passed to the <code>overlay_root</code>-field. Any arguments specified to the <code>overlay_fs_args</code>-field will be passed to SMBFileSystem.</p> <pre><code>{\n    \"overlay_root\": \"smb:///shared_drive/copick_project/\",\n    \"overlay_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"temppath\": \"/shared_drive\",\n        \"auto_mkdir\": true,\n    }\n}\n</code></pre> More about <code>overlay_fs_args</code> ... <p>The <code>auto_mkdir</code>-flag is necessary to create copick-directories if they do not yet exist. The <code>tmpath</code>-flag is not strictly necessary, this depends on your SMB setup (e.g. if only a specific directory is shared).</p> <pre><code>{\n    \"overlay_root\": \"smb:///shared_drive/copick_project/\",\n    \"overlay_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"auto_mkdir\": true,\n    }\n}\n</code></pre> <p>Set up your static project</p> <p>This S3 URI will contain all static data for your project.</p> <p>Make sure the intended S3 bucket is writable: <pre><code>echo \"Hello, World!\" &gt; test.txt\naws s3 cp test.txt s3://your-bucket-name/copick_project_static/test.txt\naws s3 ls s3://your-bucket-name/copick_project_static/\naws s3 rm s3://your-bucket-name/copick_project_static/test.txt\n# Replace s3://your-bucket-name/copick_project/ with your S3 URI\n</code></pre></p> <p>AWS authentication</p> <p>Make sure you have the necessary AWS credentials set up and available in the shell you're running the above commands in. Refer to the AWS CLI documentation for more information.</p> <p>In the config file, the location should be passed to the <code>static_root</code>-field. Any arguments specified to the <code>static_fs_args</code>-field will be passed to S3FileSystem. <code>profile</code> should be one of the profiles set up in your <code>~/.aws/credentials</code> file.</p> <pre><code>{\n  \"static_root\": \"s3://bucket-name/copick_project_static/\",\n  \"static_fs_args\": {\n        \"profile\": \"example_profile\"\n    }\n}\n</code></pre> More about <code>static_fs_args</code> ... <p>Specifying <code>profile</code> is one possible way of setting up AWS credentials. Refer to the S3FS documentation for detailed information.</p> <p>For local MinIO buckets, the following config may be appropriate:</p> <pre><code>{\n    \"static_fs_args\": {\n        \"key\":\"bucketkey\",\n        \"secret\":\"bucketsecret\",\n        \"endpoint_url\":\"http://10.30.121.49:7070\",\n        \"client_kwargs\":{\n            \"region_name\":\"us-east-1\"\n        }\n}\n</code></pre> Cofiguration Template <pre><code>{\n    \"name\": \"Example Project\",\n    \"description\": \"This is an example project, demonstrating overlaying a smb-backend ona project in a ssh-backend.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"label\": 1,\n            \"color\": [\n                0,\n                117,\n                220,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"label\": 2,\n            \"color\": [\n                251,\n                192,\n                147,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"label\": 3,\n            \"color\": [\n                200,\n                200,\n                200,\n                255\n            ],\n            \"radius\": 10.0\n        }\n    ],\n    \"user_id\": \"example.user\",\n    \"config_type\": \"filesystem\",\n    \"overlay_root\": \"smb:///shared_drive/copick_project/\",\n    \"static_root\": \"ssh:///hpc/storage/copick_project_static/\",\n    \"overlay_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"temppath\": \"/shared_drive\",\n        \"auto_mkdir\": true\n    },\n    \"static_fs_args\": {\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"host\": \"hpc.example.com\",\n        \"port\": 22\n    }\n}\n</code></pre> <p>Set up your overlay project</p> <p>This SMB-share will contain all newly created data for your project.</p> <p>In the config file, the location should be passed to the <code>overlay_root</code>-field. Any arguments specified to the <code>overlay_fs_args</code>-field will be passed to SMBFileSystem.</p> <pre><code>{\n    \"overlay_root\": \"smb:///shared_drive/copick_project/\",\n    \"overlay_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"temppath\": \"/shared_drive\",\n        \"auto_mkdir\": true,\n    }\n}\n</code></pre> More about <code>overlay_fs_args</code> ... <p>The <code>auto_mkdir</code>-flag is necessary to create copick-directories if they do not yet exist. The <code>tmpath</code>-flag is not strictly necessary, this depends on your SMB setup (e.g. if only a specific directory is shared).</p> <pre><code>{\n    \"overlay_root\": \"smb:///shared_drive/copick_project/\",\n    \"overlay_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"auto_mkdir\": true,\n    }\n}\n</code></pre> <p>Set up your static project</p> <p>This directory will contain all static data for your project.</p> <p>SSH authentication</p> <p>Copick will work best via SSH if you have set up passwordless SSH authentication. Refer to the SSH documentation for more information. In general, adding plain text passwords into copick configuration files is strongly discouraged.</p> <p>In cases of mandatory 2-FA authentication, you may need to set up an SSH tunnel to the remote filesystem, e.g.</p> <p><pre><code>ssh -L 2222:localhost:22 user.name@hpc.example.com\n</code></pre> and then use <code>localhost:2222</code> as the host in the config and commands below.</p> <p>Make sure it exists on the remote filesystem and is writable: <pre><code>ssh -p 22 user.name@hpc.example.com \"touch /path/to/copick_project_static\"\n# Replace port, user name and path to the static project with the correct values\n</code></pre></p> <p>If it does not yet exist, create it with the following command: <pre><code>ssh -p 22 user.name@hpc.example.com \"mkdir /path/to/copick_project_static\"\n# Replace port, user name and path to the static project with the correct values\n</code></pre></p> <p>In the config file, the location should be passed to the <code>static_root</code>-field. Any arguments specified to the <code>static_fs_args</code>-field will be passed to sshfs.SSHFileSystem.</p> <pre><code>{\n  \"static_root\": \"ssh:///path/to/copick_project_static/\",\n\n    \"static_fs_args\": {\n        \"username\": \"user.name\",\n        \"host\": \"hpc.example.com\",\n        \"port\": 22\n    }\n}\n</code></pre> More about <code>static_fs_args</code> ... <p>The <code>username</code>, <code>host</code> and <code>port</code>-fields are necessary to set up the SSH connection. Refer to the SSHFS documentation for detailed information.</p> <p>An easy way to use the SSH filesystem is to tunnel to the remote filesystem via SSH, e.g.</p> <pre><code>ssh -L 2222:localhost:22 user.name@hpc.example.com\n</code></pre> <p>and then use <code>localhost:2222</code> as the host in the config and commands above.</p> <pre><code>{\n  \"static_fs_args\": {\n      \"username\": \"user.name\",\n      \"host\": \"localhost\",\n      \"port\": 2222\n  }\n}\n</code></pre>"},{"location":"examples/setup/shared/#option-4-an-other-overlay-smb-static-copick-project","title":"Option 4: An other overlay, SMB static copick project","text":"<p>Choose your other overlay backend:</p> LocalAWS S3SSH Cofiguration Template <pre><code>{\n    \"name\": \"Example Project\",\n    \"description\": \"This is an example project, demonstrating overlaying a local-backend ona project in a smb-backend.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"label\": 1,\n            \"color\": [\n                0,\n                117,\n                220,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"label\": 2,\n            \"color\": [\n                251,\n                192,\n                147,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"label\": 3,\n            \"color\": [\n                200,\n                200,\n                200,\n                255\n            ],\n            \"radius\": 10.0\n        }\n    ],\n    \"user_id\": \"example.user\",\n    \"config_type\": \"filesystem\",\n    \"overlay_root\": \"local:///path/to/copick_project/\",\n    \"static_root\": \"smb:///shared_drive/copick_project_static/\",\n    \"overlay_fs_args\": {\n        \"auto_mkdir\": true\n    },\n    \"static_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"temppath\": \"/shared_drive\",\n        \"auto_mkdir\": true\n    }\n}\n</code></pre> <p>Set up your overlay project</p> <p>This directory will contain all newly created data for your project.</p> <p>Make sure it exists on the filesystem and is writable: <pre><code>touch /path/to/copick_project\n# Replace /path/to/copick_project with the path to your project overlay\n</code></pre></p> <p>If it does not yet exist, create it with the following command: <pre><code>mkdir /path/to/copick_project\n# Replace /path/to/copick_project with the path to your project overlay\n</code></pre></p> <p>In the config file, the location should be passed to the <code>overlay_root</code>-field. Any arguments specified to the <code>overlay_fs_args</code>-field will be passed to LocalFileSystem.</p> <pre><code>{\n  \"overlay_root\": \"local:///path/to/copick_project\",\n  \"overlay_fs_args\": {\n    \"auto_mkdir\": true\n  }\n}\n</code></pre> More about <code>overlay_fs_args</code> ... <p>The <code>auto_mkdir</code>-flag is necessary to create copick-directories if they do not yet exist.</p> <p>Set up your static project</p> <p>This SMB-share will contain all static data for your project.</p> <p>In the config file, the location should be passed to the <code>static_root</code>-field. Any arguments specified to the <code>static_fs_args</code>-field will be passed to SMBFileSystem.</p> <pre><code>{\n    \"static_root\": \"smb:///shared_drive/copick_project/\",\n    \"static_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"temppath\": \"/shared_drive\",\n        \"auto_mkdir\": true,\n    }\n}\n</code></pre> More about <code>static_fs_args</code> ... <p>The <code>auto_mkdir</code>-flag is necessary to create copick-directories if they do not yet exist. The <code>tmpath</code>-flag is not strictly necessary, this depends on your SMB setup (e.g. if only a specific directory is shared).</p> <pre><code>{\n    \"static_root\": \"smb:///shared_drive/copick_project/\",\n    \"static_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"auto_mkdir\": true,\n    }\n}\n</code></pre> Cofiguration Template <pre><code>{\n    \"name\": \"Example Project\",\n    \"description\": \"This is an example project, demonstrating overlaying a s3-backend ona project in a smb-backend.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"label\": 1,\n            \"color\": [\n                0,\n                117,\n                220,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"label\": 2,\n            \"color\": [\n                251,\n                192,\n                147,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"label\": 3,\n            \"color\": [\n                200,\n                200,\n                200,\n                255\n            ],\n            \"radius\": 10.0\n        }\n    ],\n    \"user_id\": \"example.user\",\n    \"config_type\": \"filesystem\",\n    \"overlay_root\": \"s3://bucket/copick_project/\",\n    \"static_root\": \"smb:///shared_drive/copick_project_static/\",\n    \"overlay_fs_args\": {\n        \"profile\": \"your_profile\"\n    },\n    \"static_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"temppath\": \"/shared_drive\",\n        \"auto_mkdir\": true\n    }\n}\n</code></pre> <p>Set up your overlay project</p> <p>This S3 URI will contain all newly created data for your project.</p> <p>Make sure the intended S3 bucket is writable: <pre><code>echo \"Hello, World!\" &gt; test.txt\naws s3 cp test.txt s3://your-bucket-name/copick_project/test.txt\naws s3 ls s3://your-bucket-name/copick_project/\naws s3 rm s3://your-bucket-name/copick_project/test.txt\n# Replace s3://your-bucket-name/copick_project/ with your S3 URI\n</code></pre></p> <p>AWS authentication</p> <p>Make sure you have the necessary AWS credentials set up and available in the shell you're running the above commands in. Refer to the AWS CLI documentation for more information.</p> <p>In the config file, the location should be passed to the <code>overlay_root</code>-field. Any arguments specified to the <code>overlay_fs_args</code>-field will be passed to S3FileSystem. <code>profile</code> should be one of the profiles set up in your <code>~/.aws/credentials</code> file.</p> <pre><code>{\n  \"overlay_root\": \"s3://bucket-name/copick_project/\",\n  \"overlay_fs_args\": {\n        \"profile\": \"example_profile\"\n    }\n}\n</code></pre> More about <code>overlay_fs_args</code> ... <p>Specifying <code>profile</code> is one possible way of setting up AWS credentials. Refer to the S3FS documentation for detailed information.</p> <p>For local MinIO buckets, the following config may be appropriate:</p> <pre><code>{\n    \"overlay_fs_args\": {\n        \"key\":\"bucketkey\",\n        \"secret\":\"bucketsecret\",\n        \"endpoint_url\":\"http://10.30.121.49:7070\",\n        \"client_kwargs\":{\n            \"region_name\":\"us-east-1\"\n        }\n}\n</code></pre> <p>Set up your static project</p> <p>This SMB-share will contain all static data for your project.</p> <p>In the config file, the location should be passed to the <code>static_root</code>-field. Any arguments specified to the <code>static_fs_args</code>-field will be passed to SMBFileSystem.</p> <pre><code>{\n    \"static_root\": \"smb:///shared_drive/copick_project/\",\n    \"static_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"temppath\": \"/shared_drive\",\n        \"auto_mkdir\": true,\n    }\n}\n</code></pre> More about <code>static_fs_args</code> ... <p>The <code>auto_mkdir</code>-flag is necessary to create copick-directories if they do not yet exist. The <code>tmpath</code>-flag is not strictly necessary, this depends on your SMB setup (e.g. if only a specific directory is shared).</p> <pre><code>{\n    \"static_root\": \"smb:///shared_drive/copick_project/\",\n    \"static_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"auto_mkdir\": true,\n    }\n}\n</code></pre> Cofiguration Template <pre><code>{\n    \"name\": \"Example Project\",\n    \"description\": \"This is an example project, demonstrating overlaying a ssh-backend ona project in a smb-backend.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"label\": 1,\n            \"color\": [\n                0,\n                117,\n                220,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"label\": 2,\n            \"color\": [\n                251,\n                192,\n                147,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"label\": 3,\n            \"color\": [\n                200,\n                200,\n                200,\n                255\n            ],\n            \"radius\": 10.0\n        }\n    ],\n    \"user_id\": \"example.user\",\n    \"config_type\": \"filesystem\",\n    \"overlay_root\": \"ssh:///hpc/storage/copick_project/\",\n    \"static_root\": \"smb:///shared_drive/copick_project_static/\",\n    \"overlay_fs_args\": {\n        \"username\": \"user.name\",\n        \"host\": \"hpc.example.com\",\n        \"port\": 22\n    },\n    \"static_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"temppath\": \"/shared_drive\",\n        \"auto_mkdir\": true\n    }\n}\n</code></pre> <p>Set up your overlay project</p> <p>This directory will contain all newly created data for your project.</p> <p>SSH authentication</p> <p>Copick will work best via SSH if you have set up passwordless SSH authentication. Refer to the SSH documentation for more information. In general, adding plain text passwords into copick configuration files is strongly discouraged.</p> <p>In cases of mandatory 2-FA authentication, you may need to set up an SSH tunnel to the remote filesystem, e.g.</p> <p><pre><code>ssh -L 2222:localhost:22 user.name@hpc.example.com\n</code></pre> and then use <code>localhost:2222</code> as the host in the config and commands below.</p> <p>Make sure it exists on the remote filesystem and is writable: <pre><code>ssh -p 22 user.name@hpc.example.com \"touch /path/to/copick_project\"\n# Replace port, user name and path to the project overlay with the correct values\n</code></pre></p> <p>If it does not yet exist, create it with the following command: <pre><code>ssh -p 22 user.name@hpc.example.com \"mkdir /path/to/copick_project\"\n# Replace port, user name and path to the project overlay with the correct values\n</code></pre></p> <p>In the config file, the location should be passed to the <code>overlay_root</code>-field. Any arguments specified to the <code>overlay_fs_args</code>-field will be passed to sshfs.SSHFileSystem.</p> <pre><code>{\n  \"overlay_root\": \"ssh:///path/to/copick_project/\",\n\n    \"overlay_fs_args\": {\n        \"username\": \"user.name\",\n        \"host\": \"hpc.example.com\",\n        \"port\": 22\n    }\n}\n</code></pre> More about <code>overlay_fs_args</code> ... <p>The <code>username</code>, <code>host</code> and <code>port</code>-fields are necessary to set up the SSH connection. Refer to the SSHFS documentation for detailed information.</p> <p>An easy way to use the SSH filesystem is to tunnel to the remote filesystem via SSH, e.g.</p> <pre><code>ssh -L 2222:localhost:22 user.name@hpc.example.com\n</code></pre> <p>and then use <code>localhost:2222</code> as the host in the config and commands above.</p> <pre><code>{\n  \"overlay_fs_args\": {\n      \"username\": \"user.name\",\n      \"host\": \"localhost\",\n      \"port\": 2222\n  }\n}\n</code></pre> <p>Set up your static project</p> <p>This SMB-share will contain all static data for your project.</p> <p>In the config file, the location should be passed to the <code>static_root</code>-field. Any arguments specified to the <code>static_fs_args</code>-field will be passed to SMBFileSystem.</p> <pre><code>{\n    \"static_root\": \"smb:///shared_drive/copick_project/\",\n    \"static_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"temppath\": \"/shared_drive\",\n        \"auto_mkdir\": true,\n    }\n}\n</code></pre> More about <code>static_fs_args</code> ... <p>The <code>auto_mkdir</code>-flag is necessary to create copick-directories if they do not yet exist. The <code>tmpath</code>-flag is not strictly necessary, this depends on your SMB setup (e.g. if only a specific directory is shared).</p> <pre><code>{\n    \"static_root\": \"smb:///shared_drive/copick_project/\",\n    \"static_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"auto_mkdir\": true,\n    }\n}\n</code></pre>"},{"location":"examples/setup/ssh/","title":"SSH Project","text":"copick project setup with remote storage via SSH. <p>In copick, a project has an overlay and (optionally) a static part. The overlay is where all user-created entities are stored and is writable. The static part is read-only and contains the input data. There are four ways of setting up SSH-based copick projects:</p> <ul> <li> <p> Option 1: SSH overlay-only</p> <p>Using this method, there will be a single, remote SSH project directory, all entities in the copick project will be writable. This is a good choice for when one wants to visualize and annotate data from a personal project that is stored on a remote SSH server.</p> <p> Get config template</p> </li> <li> <p> Option 2: SSH overlay, SSH static</p> <p>Using this method there will be two project directories, static and overlay, respectively. Files in the \"static\"-project directory will be read-only within copick, while files in the \"overlay\"-directory will be writeable. This is a good choice if you want to maintain the input data.</p> <p> Get config template</p> </li> <li> <p> Option 3: SSH overlay, other static</p> <p>Using this method, any user-created copick entities will be stored in a remote SSH overlay, while static data (e.g. tomograms and baseline annotations) are stored in a different storage backend. This will be useful when one wants to curate a dataset and have the curated data directly accessible on a remote SSH server.</p> <p> Get config templates</p> </li> <li> <p> Option 4: other overlay, SSH static</p> <p>Using this method, the static part of the project will be stored remotely via SSH, while new copick entities are written to another storage backend. This could be useful together with a group of people curating a large set of data.</p> <p> Get config templates</p> </li> </ul>"},{"location":"examples/setup/ssh/#option-1-a-ssh-overlay-only-copick-project","title":"Option 1: A SSH overlay-only copick project","text":""},{"location":"examples/setup/ssh/#set-up-your-project-root-directory","title":"Set up your project root directory","text":"<p>In order to create an <code>overlay-only</code>-project we first need to set up one project directory on a remote SSH server.</p> <p>SSH authentication</p> <p>Copick will work best via SSH if you have set up passwordless SSH authentication. Refer to the SSH documentation for more information. In general, adding plain text passwords into copick configuration files is strongly discouraged.</p> <p>In cases of mandatory 2-FA authentication, you may need to set up an SSH tunnel to the remote filesystem, e.g.</p> <p><pre><code>ssh -L 2222:localhost:22 user.name@hpc.example.com\n</code></pre> and then use <code>localhost:2222</code> as the host in the config and commands below.</p> <p>Make sure it exists on the remote SSH filesystem and is writable: <pre><code>ssh -p 22 user.name@hpc.example.com \"touch /path/to/copick_project\"\n# Replace port, user name and path to the project overlay with the correct values\n</code></pre></p> <p>If it does not yet exist, create it with the following command: <pre><code>ssh -p 22 user.name@hpc.example.com \"mkdir /path/to/copick_project\"\n# Replace port, user name and path to the project overlay with the correct values\n</code></pre></p>"},{"location":"examples/setup/ssh/#create-the-config-file","title":"Create the config file","text":"<p>All information necessary to use the copick API is stored in a config file in <code>json</code>-Format. This has to be created before accessing the data is possible.</p> <p>Create a json file with your favorite editor and paste the below template. Fill in the abolute path of the copick root directory on the remote SSH server as indicated below.</p> <pre><code>vi copick_config.json\n</code></pre> Cofiguration Template <pre><code>{\n    \"name\": \"Example Project\",\n    \"description\": \"This is an example project, demonstrating an overlay-only ssh-backend project.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"label\": 1,\n            \"color\": [\n                0,\n                117,\n                220,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"label\": 2,\n            \"color\": [\n                251,\n                192,\n                147,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"label\": 3,\n            \"color\": [\n                200,\n                200,\n                200,\n                255\n            ],\n            \"radius\": 10.0\n        }\n    ],\n    \"user_id\": \"example.user\",\n    \"config_type\": \"filesystem\",\n    \"overlay_root\": \"ssh:///hpc/storage/copick_project/\",\n    \"overlay_fs_args\": {\n        \"username\": \"user.name\",\n        \"host\": \"hpc.example.com\",\n        \"port\": 22\n    }\n}\n</code></pre> <p>In the config file, the location should be passed to the <code>overlay_root</code>-field. Any arguments specified to the <code>overlay_fs_args</code>-field will be passed to sshfs.SSHFileSystem.</p> More about <code>overlay_fs_args</code> ... <p>The <code>username</code>, <code>host</code> and <code>port</code>-fields are necessary to set up the SSH connection. Refer to the SSHFS documentation for detailed information.</p> <p>An easy way to use the SSH filesystem is to tunnel to the remote filesystem via SSH, e.g.</p> <pre><code>ssh -L 2222:localhost:22 user.name@hpc.example.com\n</code></pre> <p>and then use <code>localhost:2222</code> as the host in the config and commands above.</p> <pre><code>{\n  \"overlay_fs_args\": {\n      \"username\": \"user.name\",\n      \"host\": \"localhost\",\n      \"port\": 2222\n  }\n}\n</code></pre> <p>The project is now set up, you can now add objects, add tomograms or store annotations.</p>"},{"location":"examples/setup/ssh/#option-2-a-ssh-overlay-ssh-static-copick-project","title":"Option 2: A SSH overlay, SSH static copick project","text":""},{"location":"examples/setup/ssh/#set-up-your-project-root-directory_1","title":"Set up your project root directory","text":"<p>In order to create an <code>static/overlay</code>-project we first need to set up two project directories, one to store the static data, and another to store any new or curated annotations.</p> <p>Make sure it exists on the remote SSH filesystem and is writable: <pre><code>ssh -p 22 user.name@hpc.example.com \"mkdir /path/to/copick_project\"\nssh -p 22 user.name@hpc.example.com \"mkdir /path/to/copick_project_static\"\n# Replace port, user name and path to the project overlay with the correct values\n</code></pre></p> <p>If it does not yet exist, create it with the following command: <pre><code>ssh -p 22 user.name@hpc.example.com \"mkdir /path/to/copick_project\"\nssh -p 22 user.name@hpc.example.com \"mkdir /path/to/copick_project_static\"\n# Replace port, user name and path to the project overlay with the correct values\n</code></pre></p>"},{"location":"examples/setup/ssh/#create-the-config-file_1","title":"Create the config file","text":"<p>All information necessary to use the copick API is stored in a config file in <code>json</code>-Format. This has to be created before accessing the data is possible.</p> <p>Create a json file with your favorite editor and paste the below template. Fill in the abolute path of the copick root directory as indicated below.</p> <pre><code>vi copick_config.json\n</code></pre> Cofiguration Template <pre><code>{\n    \"name\": \"Example Project\",\n    \"description\": \"This is an example project, demonstrating overlaying a ssh-backend ona project in a ssh-backend.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"label\": 1,\n            \"color\": [\n                0,\n                117,\n                220,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"label\": 2,\n            \"color\": [\n                251,\n                192,\n                147,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"label\": 3,\n            \"color\": [\n                200,\n                200,\n                200,\n                255\n            ],\n            \"radius\": 10.0\n        }\n    ],\n    \"user_id\": \"example.user\",\n    \"config_type\": \"filesystem\",\n    \"overlay_root\": \"ssh:///hpc/storage/copick_project/\",\n    \"static_root\": \"ssh:///hpc/storage/copick_project_static/\",\n    \"overlay_fs_args\": {\n        \"username\": \"user.name\",\n        \"host\": \"hpc.example.com\",\n        \"port\": 22\n    },\n    \"static_fs_args\": {\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"host\": \"hpc.example.com\",\n        \"port\": 22\n    }\n}\n</code></pre>"},{"location":"examples/setup/ssh/#option-3-a-ssh-overlay-other-static-copick-project","title":"Option 3: A SSH overlay, other static copick project","text":"<p>Choose your static backend:</p> CZ cryoET Data PortalSMB ShareAWS S3Local Cofiguration Template <pre><code>{\n    \"name\": \"Example Project\",\n    \"description\": \"This is an example project, demonstrating overlaying a ssh-backend on a CZ cryoET Data Portal dataset.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"label\": 1,\n            \"color\": [\n                0,\n                117,\n                220,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"label\": 2,\n            \"color\": [\n                251,\n                192,\n                147,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"label\": 3,\n            \"color\": [\n                200,\n                200,\n                200,\n                255\n            ],\n            \"radius\": 10.0\n        }\n    ],\n    \"user_id\": \"example.user\",\n    \"config_type\": \"cryoet_data_portal\",\n    \"overlay_root\": \"ssh:///hpc/storage/copick_project/\",\n    \"dataset_ids\": [\n        10301,\n        10302\n    ],\n    \"overlay_fs_args\": {\n        \"username\": \"user.name\",\n        \"host\": \"hpc.example.com\",\n        \"port\": 22\n    }\n}\n</code></pre> <p>Set up your overlay project</p> <p>This directory will contain all newly created data for your project.</p> <p>SSH authentication</p> <p>Copick will work best via SSH if you have set up passwordless SSH authentication. Refer to the SSH documentation for more information. In general, adding plain text passwords into copick configuration files is strongly discouraged.</p> <p>In cases of mandatory 2-FA authentication, you may need to set up an SSH tunnel to the remote filesystem, e.g.</p> <p><pre><code>ssh -L 2222:localhost:22 user.name@hpc.example.com\n</code></pre> and then use <code>localhost:2222</code> as the host in the config and commands below.</p> <p>Make sure it exists on the remote filesystem and is writable: <pre><code>ssh -p 22 user.name@hpc.example.com \"touch /path/to/copick_project\"\n# Replace port, user name and path to the project overlay with the correct values\n</code></pre></p> <p>If it does not yet exist, create it with the following command: <pre><code>ssh -p 22 user.name@hpc.example.com \"mkdir /path/to/copick_project\"\n# Replace port, user name and path to the project overlay with the correct values\n</code></pre></p> <p>In the config file, the location should be passed to the <code>overlay_root</code>-field. Any arguments specified to the <code>overlay_fs_args</code>-field will be passed to sshfs.SSHFileSystem.</p> <pre><code>{\n  \"overlay_root\": \"ssh:///path/to/copick_project/\",\n\n    \"overlay_fs_args\": {\n        \"username\": \"user.name\",\n        \"host\": \"hpc.example.com\",\n        \"port\": 22\n    }\n}\n</code></pre> More about <code>overlay_fs_args</code> ... <p>The <code>username</code>, <code>host</code> and <code>port</code>-fields are necessary to set up the SSH connection. Refer to the SSHFS documentation for detailed information.</p> <p>An easy way to use the SSH filesystem is to tunnel to the remote filesystem via SSH, e.g.</p> <pre><code>ssh -L 2222:localhost:22 user.name@hpc.example.com\n</code></pre> <p>and then use <code>localhost:2222</code> as the host in the config and commands above.</p> <pre><code>{\n  \"overlay_fs_args\": {\n      \"username\": \"user.name\",\n      \"host\": \"localhost\",\n      \"port\": 2222\n  }\n}\n</code></pre> <p>Set up your static project</p> <p>In the case of CZ cryoET data portal datasets, setting up the static project is as easy as specifying one or multiple dataset IDs. The below example selects runs from datasets 10301 and 10302.</p> <pre><code>{\n  \"dataset_ids\": [\n    10301,\n    10302\n  ]\n}\n</code></pre> <p>Configuration Type</p> <p>When using the CZ cryoET data portal, the <code>config_type</code>-field should be set to <code>cryoet-data-portal</code>.</p> Cofiguration Template <pre><code>{\n    \"name\": \"Example Project\",\n    \"description\": \"This is an example project, demonstrating overlaying a ssh-backend ona project in a smb-backend.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"label\": 1,\n            \"color\": [\n                0,\n                117,\n                220,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"label\": 2,\n            \"color\": [\n                251,\n                192,\n                147,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"label\": 3,\n            \"color\": [\n                200,\n                200,\n                200,\n                255\n            ],\n            \"radius\": 10.0\n        }\n    ],\n    \"user_id\": \"example.user\",\n    \"config_type\": \"filesystem\",\n    \"overlay_root\": \"ssh:///hpc/storage/copick_project/\",\n    \"static_root\": \"smb:///shared_drive/copick_project_static/\",\n    \"overlay_fs_args\": {\n        \"username\": \"user.name\",\n        \"host\": \"hpc.example.com\",\n        \"port\": 22\n    },\n    \"static_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"temppath\": \"/shared_drive\",\n        \"auto_mkdir\": true\n    }\n}\n</code></pre> <p>Set up your overlay project</p> <p>This directory will contain all newly created data for your project.</p> <p>SSH authentication</p> <p>Copick will work best via SSH if you have set up passwordless SSH authentication. Refer to the SSH documentation for more information. In general, adding plain text passwords into copick configuration files is strongly discouraged.</p> <p>In cases of mandatory 2-FA authentication, you may need to set up an SSH tunnel to the remote filesystem, e.g.</p> <p><pre><code>ssh -L 2222:localhost:22 user.name@hpc.example.com\n</code></pre> and then use <code>localhost:2222</code> as the host in the config and commands below.</p> <p>Make sure it exists on the remote filesystem and is writable: <pre><code>ssh -p 22 user.name@hpc.example.com \"touch /path/to/copick_project\"\n# Replace port, user name and path to the project overlay with the correct values\n</code></pre></p> <p>If it does not yet exist, create it with the following command: <pre><code>ssh -p 22 user.name@hpc.example.com \"mkdir /path/to/copick_project\"\n# Replace port, user name and path to the project overlay with the correct values\n</code></pre></p> <p>In the config file, the location should be passed to the <code>overlay_root</code>-field. Any arguments specified to the <code>overlay_fs_args</code>-field will be passed to sshfs.SSHFileSystem.</p> <pre><code>{\n  \"overlay_root\": \"ssh:///path/to/copick_project/\",\n\n    \"overlay_fs_args\": {\n        \"username\": \"user.name\",\n        \"host\": \"hpc.example.com\",\n        \"port\": 22\n    }\n}\n</code></pre> More about <code>overlay_fs_args</code> ... <p>The <code>username</code>, <code>host</code> and <code>port</code>-fields are necessary to set up the SSH connection. Refer to the SSHFS documentation for detailed information.</p> <p>An easy way to use the SSH filesystem is to tunnel to the remote filesystem via SSH, e.g.</p> <pre><code>ssh -L 2222:localhost:22 user.name@hpc.example.com\n</code></pre> <p>and then use <code>localhost:2222</code> as the host in the config and commands above.</p> <pre><code>{\n  \"overlay_fs_args\": {\n      \"username\": \"user.name\",\n      \"host\": \"localhost\",\n      \"port\": 2222\n  }\n}\n</code></pre> <p>Set up your static project</p> <p>This SMB-share will contain all static data for your project.</p> <p>In the config file, the location should be passed to the <code>static_root</code>-field. Any arguments specified to the <code>static_fs_args</code>-field will be passed to SMBFileSystem.</p> <pre><code>{\n    \"static_root\": \"smb:///shared_drive/copick_project/\",\n    \"static_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"temppath\": \"/shared_drive\",\n        \"auto_mkdir\": true,\n    }\n}\n</code></pre> More about <code>static_fs_args</code> ... <p>The <code>auto_mkdir</code>-flag is necessary to create copick-directories if they do not yet exist. The <code>tmpath</code>-flag is not strictly necessary, this depends on your SMB setup (e.g. if only a specific directory is shared).</p> <pre><code>{\n    \"static_root\": \"smb:///shared_drive/copick_project/\",\n    \"static_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"auto_mkdir\": true,\n    }\n}\n</code></pre> Cofiguration Template <pre><code>{\n    \"name\": \"Example Project\",\n    \"description\": \"This is an example project, demonstrating overlaying a ssh-backend ona project in a s3-backend.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"label\": 1,\n            \"color\": [\n                0,\n                117,\n                220,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"label\": 2,\n            \"color\": [\n                251,\n                192,\n                147,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"label\": 3,\n            \"color\": [\n                200,\n                200,\n                200,\n                255\n            ],\n            \"radius\": 10.0\n        }\n    ],\n    \"user_id\": \"example.user\",\n    \"config_type\": \"filesystem\",\n    \"overlay_root\": \"ssh:///hpc/storage/copick_project/\",\n    \"static_root\": \"s3://bucket/copick_project_static/\",\n    \"overlay_fs_args\": {\n        \"username\": \"user.name\",\n        \"host\": \"hpc.example.com\",\n        \"port\": 22\n    },\n    \"static_fs_args\": {\n        \"profile\": \"your_profile\"\n    }\n}\n</code></pre> <p>Set up your overlay project</p> <p>This directory will contain all newly created data for your project.</p> <p>SSH authentication</p> <p>Copick will work best via SSH if you have set up passwordless SSH authentication. Refer to the SSH documentation for more information. In general, adding plain text passwords into copick configuration files is strongly discouraged.</p> <p>In cases of mandatory 2-FA authentication, you may need to set up an SSH tunnel to the remote filesystem, e.g.</p> <p><pre><code>ssh -L 2222:localhost:22 user.name@hpc.example.com\n</code></pre> and then use <code>localhost:2222</code> as the host in the config and commands below.</p> <p>Make sure it exists on the remote filesystem and is writable: <pre><code>ssh -p 22 user.name@hpc.example.com \"touch /path/to/copick_project\"\n# Replace port, user name and path to the project overlay with the correct values\n</code></pre></p> <p>If it does not yet exist, create it with the following command: <pre><code>ssh -p 22 user.name@hpc.example.com \"mkdir /path/to/copick_project\"\n# Replace port, user name and path to the project overlay with the correct values\n</code></pre></p> <p>In the config file, the location should be passed to the <code>overlay_root</code>-field. Any arguments specified to the <code>overlay_fs_args</code>-field will be passed to sshfs.SSHFileSystem.</p> <pre><code>{\n  \"overlay_root\": \"ssh:///path/to/copick_project/\",\n\n    \"overlay_fs_args\": {\n        \"username\": \"user.name\",\n        \"host\": \"hpc.example.com\",\n        \"port\": 22\n    }\n}\n</code></pre> More about <code>overlay_fs_args</code> ... <p>The <code>username</code>, <code>host</code> and <code>port</code>-fields are necessary to set up the SSH connection. Refer to the SSHFS documentation for detailed information.</p> <p>An easy way to use the SSH filesystem is to tunnel to the remote filesystem via SSH, e.g.</p> <pre><code>ssh -L 2222:localhost:22 user.name@hpc.example.com\n</code></pre> <p>and then use <code>localhost:2222</code> as the host in the config and commands above.</p> <pre><code>{\n  \"overlay_fs_args\": {\n      \"username\": \"user.name\",\n      \"host\": \"localhost\",\n      \"port\": 2222\n  }\n}\n</code></pre> <p>Set up your static project</p> <p>This S3 URI will contain all static data for your project.</p> <p>Make sure the intended S3 bucket is writable: <pre><code>echo \"Hello, World!\" &gt; test.txt\naws s3 cp test.txt s3://your-bucket-name/copick_project_static/test.txt\naws s3 ls s3://your-bucket-name/copick_project_static/\naws s3 rm s3://your-bucket-name/copick_project_static/test.txt\n# Replace s3://your-bucket-name/copick_project/ with your S3 URI\n</code></pre></p> <p>AWS authentication</p> <p>Make sure you have the necessary AWS credentials set up and available in the shell you're running the above commands in. Refer to the AWS CLI documentation for more information.</p> <p>In the config file, the location should be passed to the <code>static_root</code>-field. Any arguments specified to the <code>static_fs_args</code>-field will be passed to S3FileSystem. <code>profile</code> should be one of the profiles set up in your <code>~/.aws/credentials</code> file.</p> <pre><code>{\n  \"static_root\": \"s3://bucket-name/copick_project_static/\",\n  \"static_fs_args\": {\n        \"profile\": \"example_profile\"\n    }\n}\n</code></pre> More about <code>static_fs_args</code> ... <p>Specifying <code>profile</code> is one possible way of setting up AWS credentials. Refer to the S3FS documentation for detailed information.</p> <p>For local MinIO buckets, the following config may be appropriate:</p> <pre><code>{\n    \"static_fs_args\": {\n        \"key\":\"bucketkey\",\n        \"secret\":\"bucketsecret\",\n        \"endpoint_url\":\"http://10.30.121.49:7070\",\n        \"client_kwargs\":{\n            \"region_name\":\"us-east-1\"\n        }\n}\n</code></pre> Cofiguration Template <pre><code>{\n    \"name\": \"Example Project\",\n    \"description\": \"This is an example project, demonstrating overlaying a ssh-backend ona project in a local-backend.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"label\": 1,\n            \"color\": [\n                0,\n                117,\n                220,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"label\": 2,\n            \"color\": [\n                251,\n                192,\n                147,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"label\": 3,\n            \"color\": [\n                200,\n                200,\n                200,\n                255\n            ],\n            \"radius\": 10.0\n        }\n    ],\n    \"user_id\": \"example.user\",\n    \"config_type\": \"filesystem\",\n    \"overlay_root\": \"ssh:///hpc/storage/copick_project/\",\n    \"static_root\": \"local:///path/to/copick_project_static/\",\n    \"overlay_fs_args\": {\n        \"username\": \"user.name\",\n        \"host\": \"hpc.example.com\",\n        \"port\": 22\n    },\n    \"static_fs_args\": {\n        \"auto_mkdir\": true\n    }\n}\n</code></pre> <p>Set up your overlay project</p> <p>This directory will contain all newly created data for your project.</p> <p>SSH authentication</p> <p>Copick will work best via SSH if you have set up passwordless SSH authentication. Refer to the SSH documentation for more information. In general, adding plain text passwords into copick configuration files is strongly discouraged.</p> <p>In cases of mandatory 2-FA authentication, you may need to set up an SSH tunnel to the remote filesystem, e.g.</p> <p><pre><code>ssh -L 2222:localhost:22 user.name@hpc.example.com\n</code></pre> and then use <code>localhost:2222</code> as the host in the config and commands below.</p> <p>Make sure it exists on the remote filesystem and is writable: <pre><code>ssh -p 22 user.name@hpc.example.com \"touch /path/to/copick_project\"\n# Replace port, user name and path to the project overlay with the correct values\n</code></pre></p> <p>If it does not yet exist, create it with the following command: <pre><code>ssh -p 22 user.name@hpc.example.com \"mkdir /path/to/copick_project\"\n# Replace port, user name and path to the project overlay with the correct values\n</code></pre></p> <p>In the config file, the location should be passed to the <code>overlay_root</code>-field. Any arguments specified to the <code>overlay_fs_args</code>-field will be passed to sshfs.SSHFileSystem.</p> <pre><code>{\n  \"overlay_root\": \"ssh:///path/to/copick_project/\",\n\n    \"overlay_fs_args\": {\n        \"username\": \"user.name\",\n        \"host\": \"hpc.example.com\",\n        \"port\": 22\n    }\n}\n</code></pre> More about <code>overlay_fs_args</code> ... <p>The <code>username</code>, <code>host</code> and <code>port</code>-fields are necessary to set up the SSH connection. Refer to the SSHFS documentation for detailed information.</p> <p>An easy way to use the SSH filesystem is to tunnel to the remote filesystem via SSH, e.g.</p> <pre><code>ssh -L 2222:localhost:22 user.name@hpc.example.com\n</code></pre> <p>and then use <code>localhost:2222</code> as the host in the config and commands above.</p> <pre><code>{\n  \"overlay_fs_args\": {\n      \"username\": \"user.name\",\n      \"host\": \"localhost\",\n      \"port\": 2222\n  }\n}\n</code></pre> <p>Set up your static project</p> <p>This directory will contain all static data for your project.</p> <p>Make sure it exists on the filesystem and is writable: <pre><code>touch /path/to/copick_project_static\n# Replace /path/to/copick_project with the path to your static project\n</code></pre></p> <p>If it does not yet exist, create it with the following command: <pre><code>mkdir /path/to/copick_project_static\n# Replace /path/to/copick_project with the path to your static project\n</code></pre></p> <p>In the config file, the location should be passed to the <code>static_root</code>-field. Any arguments specified to the <code>static_fs_args</code>-field will be passed to LocalFileSystem.</p> <pre><code>{\n  \"static_root\": \"local:///path/to/copick_project\",\n  \"static_fs_args\": {\n    \"auto_mkdir\": true\n  }\n}\n</code></pre> More about <code>static_fs_args</code> ... <p>The <code>auto_mkdir</code>-flag is necessary to create copick-directories if they do not yet exist.</p>"},{"location":"examples/setup/ssh/#option-4-an-other-overlay-ssh-static-copick-project","title":"Option 4: An other overlay, SSH static copick project","text":"<p>Choose your overlay backend:</p> SMB ShareAWS S3Local Cofiguration Template <pre><code>{\n    \"name\": \"Example Project\",\n    \"description\": \"This is an example project, demonstrating overlaying a smb-backend ona project in a ssh-backend.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"label\": 1,\n            \"color\": [\n                0,\n                117,\n                220,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"label\": 2,\n            \"color\": [\n                251,\n                192,\n                147,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"label\": 3,\n            \"color\": [\n                200,\n                200,\n                200,\n                255\n            ],\n            \"radius\": 10.0\n        }\n    ],\n    \"user_id\": \"example.user\",\n    \"config_type\": \"filesystem\",\n    \"overlay_root\": \"smb:///shared_drive/copick_project/\",\n    \"static_root\": \"ssh:///hpc/storage/copick_project_static/\",\n    \"overlay_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"temppath\": \"/shared_drive\",\n        \"auto_mkdir\": true\n    },\n    \"static_fs_args\": {\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"host\": \"hpc.example.com\",\n        \"port\": 22\n    }\n}\n</code></pre> <p>Set up your overlay project</p> <p>This SMB-share will contain all newly created data for your project.</p> <p>In the config file, the location should be passed to the <code>overlay_root</code>-field. Any arguments specified to the <code>overlay_fs_args</code>-field will be passed to SMBFileSystem.</p> <pre><code>{\n    \"overlay_root\": \"smb:///shared_drive/copick_project/\",\n    \"overlay_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"temppath\": \"/shared_drive\",\n        \"auto_mkdir\": true,\n    }\n}\n</code></pre> More about <code>overlay_fs_args</code> ... <p>The <code>auto_mkdir</code>-flag is necessary to create copick-directories if they do not yet exist. The <code>tmpath</code>-flag is not strictly necessary, this depends on your SMB setup (e.g. if only a specific directory is shared).</p> <pre><code>{\n    \"overlay_root\": \"smb:///shared_drive/copick_project/\",\n    \"overlay_fs_args\": {\n        \"host\": \"192.158.1.38\",\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"auto_mkdir\": true,\n    }\n}\n</code></pre> <p>Set up your static project</p> <p>This directory will contain all static data for your project.</p> <p>SSH authentication</p> <p>Copick will work best via SSH if you have set up passwordless SSH authentication. Refer to the SSH documentation for more information. In general, adding plain text passwords into copick configuration files is strongly discouraged.</p> <p>In cases of mandatory 2-FA authentication, you may need to set up an SSH tunnel to the remote filesystem, e.g.</p> <p><pre><code>ssh -L 2222:localhost:22 user.name@hpc.example.com\n</code></pre> and then use <code>localhost:2222</code> as the host in the config and commands below.</p> <p>Make sure it exists on the remote filesystem and is writable: <pre><code>ssh -p 22 user.name@hpc.example.com \"touch /path/to/copick_project_static\"\n# Replace port, user name and path to the static project with the correct values\n</code></pre></p> <p>If it does not yet exist, create it with the following command: <pre><code>ssh -p 22 user.name@hpc.example.com \"mkdir /path/to/copick_project_static\"\n# Replace port, user name and path to the static project with the correct values\n</code></pre></p> <p>In the config file, the location should be passed to the <code>static_root</code>-field. Any arguments specified to the <code>static_fs_args</code>-field will be passed to sshfs.SSHFileSystem.</p> <pre><code>{\n  \"static_root\": \"ssh:///path/to/copick_project_static/\",\n\n    \"static_fs_args\": {\n        \"username\": \"user.name\",\n        \"host\": \"hpc.example.com\",\n        \"port\": 22\n    }\n}\n</code></pre> More about <code>static_fs_args</code> ... <p>The <code>username</code>, <code>host</code> and <code>port</code>-fields are necessary to set up the SSH connection. Refer to the SSHFS documentation for detailed information.</p> <p>An easy way to use the SSH filesystem is to tunnel to the remote filesystem via SSH, e.g.</p> <pre><code>ssh -L 2222:localhost:22 user.name@hpc.example.com\n</code></pre> <p>and then use <code>localhost:2222</code> as the host in the config and commands above.</p> <pre><code>{\n  \"static_fs_args\": {\n      \"username\": \"user.name\",\n      \"host\": \"localhost\",\n      \"port\": 2222\n  }\n}\n</code></pre> Cofiguration Template <pre><code>{\n    \"name\": \"Example Project\",\n    \"description\": \"This is an example project, demonstrating overlaying a s3-backend ona project in a ssh-backend.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"label\": 1,\n            \"color\": [\n                0,\n                117,\n                220,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"label\": 2,\n            \"color\": [\n                251,\n                192,\n                147,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"label\": 3,\n            \"color\": [\n                200,\n                200,\n                200,\n                255\n            ],\n            \"radius\": 10.0\n        }\n    ],\n    \"user_id\": \"example.user\",\n    \"config_type\": \"filesystem\",\n    \"overlay_root\": \"s3://bucket/copick_project/\",\n    \"static_root\": \"ssh:///hpc/storage/copick_project_static/\",\n    \"overlay_fs_args\": {\n        \"profile\": \"your_profile\"\n    },\n    \"static_fs_args\": {\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"host\": \"hpc.example.com\",\n        \"port\": 22\n    }\n}\n</code></pre> <p>Set up your overlay project</p> <p>This S3 URI will contain all newly created data for your project.</p> <p>Make sure the intended S3 bucket is writable: <pre><code>echo \"Hello, World!\" &gt; test.txt\naws s3 cp test.txt s3://your-bucket-name/copick_project/test.txt\naws s3 ls s3://your-bucket-name/copick_project/\naws s3 rm s3://your-bucket-name/copick_project/test.txt\n# Replace s3://your-bucket-name/copick_project/ with your S3 URI\n</code></pre></p> <p>AWS authentication</p> <p>Make sure you have the necessary AWS credentials set up and available in the shell you're running the above commands in. Refer to the AWS CLI documentation for more information.</p> <p>In the config file, the location should be passed to the <code>overlay_root</code>-field. Any arguments specified to the <code>overlay_fs_args</code>-field will be passed to S3FileSystem. <code>profile</code> should be one of the profiles set up in your <code>~/.aws/credentials</code> file.</p> <pre><code>{\n  \"overlay_root\": \"s3://bucket-name/copick_project/\",\n  \"overlay_fs_args\": {\n        \"profile\": \"example_profile\"\n    }\n}\n</code></pre> More about <code>overlay_fs_args</code> ... <p>Specifying <code>profile</code> is one possible way of setting up AWS credentials. Refer to the S3FS documentation for detailed information.</p> <p>For local MinIO buckets, the following config may be appropriate:</p> <pre><code>{\n    \"overlay_fs_args\": {\n        \"key\":\"bucketkey\",\n        \"secret\":\"bucketsecret\",\n        \"endpoint_url\":\"http://10.30.121.49:7070\",\n        \"client_kwargs\":{\n            \"region_name\":\"us-east-1\"\n        }\n}\n</code></pre> <p>Set up your static project</p> <p>This directory will contain all static data for your project.</p> <p>SSH authentication</p> <p>Copick will work best via SSH if you have set up passwordless SSH authentication. Refer to the SSH documentation for more information. In general, adding plain text passwords into copick configuration files is strongly discouraged.</p> <p>In cases of mandatory 2-FA authentication, you may need to set up an SSH tunnel to the remote filesystem, e.g.</p> <p><pre><code>ssh -L 2222:localhost:22 user.name@hpc.example.com\n</code></pre> and then use <code>localhost:2222</code> as the host in the config and commands below.</p> <p>Make sure it exists on the remote filesystem and is writable: <pre><code>ssh -p 22 user.name@hpc.example.com \"touch /path/to/copick_project_static\"\n# Replace port, user name and path to the static project with the correct values\n</code></pre></p> <p>If it does not yet exist, create it with the following command: <pre><code>ssh -p 22 user.name@hpc.example.com \"mkdir /path/to/copick_project_static\"\n# Replace port, user name and path to the static project with the correct values\n</code></pre></p> <p>In the config file, the location should be passed to the <code>static_root</code>-field. Any arguments specified to the <code>static_fs_args</code>-field will be passed to sshfs.SSHFileSystem.</p> <pre><code>{\n  \"static_root\": \"ssh:///path/to/copick_project_static/\",\n\n    \"static_fs_args\": {\n        \"username\": \"user.name\",\n        \"host\": \"hpc.example.com\",\n        \"port\": 22\n    }\n}\n</code></pre> More about <code>static_fs_args</code> ... <p>The <code>username</code>, <code>host</code> and <code>port</code>-fields are necessary to set up the SSH connection. Refer to the SSHFS documentation for detailed information.</p> <p>An easy way to use the SSH filesystem is to tunnel to the remote filesystem via SSH, e.g.</p> <pre><code>ssh -L 2222:localhost:22 user.name@hpc.example.com\n</code></pre> <p>and then use <code>localhost:2222</code> as the host in the config and commands above.</p> <pre><code>{\n  \"static_fs_args\": {\n      \"username\": \"user.name\",\n      \"host\": \"localhost\",\n      \"port\": 2222\n  }\n}\n</code></pre> Cofiguration Template <pre><code>{\n    \"name\": \"Example Project\",\n    \"description\": \"This is an example project, demonstrating overlaying a local-backend ona project in a ssh-backend.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"label\": 1,\n            \"color\": [\n                0,\n                117,\n                220,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"label\": 2,\n            \"color\": [\n                251,\n                192,\n                147,\n                255\n            ],\n            \"radius\": 150.0\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"label\": 3,\n            \"color\": [\n                200,\n                200,\n                200,\n                255\n            ],\n            \"radius\": 10.0\n        }\n    ],\n    \"user_id\": \"example.user\",\n    \"config_type\": \"filesystem\",\n    \"overlay_root\": \"local:///path/to/copick_project/\",\n    \"static_root\": \"ssh:///hpc/storage/copick_project_static/\",\n    \"overlay_fs_args\": {\n        \"auto_mkdir\": true\n    },\n    \"static_fs_args\": {\n        \"username\": \"user.name\",\n        \"password\": \"1234\",\n        \"host\": \"hpc.example.com\",\n        \"port\": 22\n    }\n}\n</code></pre> <p>Set up your overlay project</p> <p>This directory will contain all newly created data for your project.</p> <p>Make sure it exists on the filesystem and is writable: <pre><code>touch /path/to/copick_project\n# Replace /path/to/copick_project with the path to your project overlay\n</code></pre></p> <p>If it does not yet exist, create it with the following command: <pre><code>mkdir /path/to/copick_project\n# Replace /path/to/copick_project with the path to your project overlay\n</code></pre></p> <p>In the config file, the location should be passed to the <code>overlay_root</code>-field. Any arguments specified to the <code>overlay_fs_args</code>-field will be passed to LocalFileSystem.</p> <pre><code>{\n  \"overlay_root\": \"local:///path/to/copick_project\",\n  \"overlay_fs_args\": {\n    \"auto_mkdir\": true\n  }\n}\n</code></pre> More about <code>overlay_fs_args</code> ... <p>The <code>auto_mkdir</code>-flag is necessary to create copick-directories if they do not yet exist.</p> <p>Set up your static project</p> <p>This directory will contain all static data for your project.</p> <p>SSH authentication</p> <p>Copick will work best via SSH if you have set up passwordless SSH authentication. Refer to the SSH documentation for more information. In general, adding plain text passwords into copick configuration files is strongly discouraged.</p> <p>In cases of mandatory 2-FA authentication, you may need to set up an SSH tunnel to the remote filesystem, e.g.</p> <p><pre><code>ssh -L 2222:localhost:22 user.name@hpc.example.com\n</code></pre> and then use <code>localhost:2222</code> as the host in the config and commands below.</p> <p>Make sure it exists on the remote filesystem and is writable: <pre><code>ssh -p 22 user.name@hpc.example.com \"touch /path/to/copick_project_static\"\n# Replace port, user name and path to the static project with the correct values\n</code></pre></p> <p>If it does not yet exist, create it with the following command: <pre><code>ssh -p 22 user.name@hpc.example.com \"mkdir /path/to/copick_project_static\"\n# Replace port, user name and path to the static project with the correct values\n</code></pre></p> <p>In the config file, the location should be passed to the <code>static_root</code>-field. Any arguments specified to the <code>static_fs_args</code>-field will be passed to sshfs.SSHFileSystem.</p> <pre><code>{\n  \"static_root\": \"ssh:///path/to/copick_project_static/\",\n\n    \"static_fs_args\": {\n        \"username\": \"user.name\",\n        \"host\": \"hpc.example.com\",\n        \"port\": 22\n    }\n}\n</code></pre> More about <code>static_fs_args</code> ... <p>The <code>username</code>, <code>host</code> and <code>port</code>-fields are necessary to set up the SSH connection. Refer to the SSHFS documentation for detailed information.</p> <p>An easy way to use the SSH filesystem is to tunnel to the remote filesystem via SSH, e.g.</p> <pre><code>ssh -L 2222:localhost:22 user.name@hpc.example.com\n</code></pre> <p>and then use <code>localhost:2222</code> as the host in the config and commands above.</p> <pre><code>{\n  \"static_fs_args\": {\n      \"username\": \"user.name\",\n      \"host\": \"localhost\",\n      \"port\": 2222\n  }\n}\n</code></pre>"},{"location":"examples/tutorials/album/","title":"Copick and Album","text":""},{"location":"examples/tutorials/album/#copick-album","title":"copick  album","text":"<p>Album provides an easy way to deploy code and environments for processing tasks across platforms. Setting up an album solution that iterates over all runs in a copick project is extremely simple. Below is a step-by-step guide to writing an album solution that processes all runs in a copick project and stores a set of random points in each run.</p> <p>A cookiecutter solution for copick can be found at the end of this page.</p>"},{"location":"examples/tutorials/album/#step-1-install-album","title":"Step 1: Install Album","text":"<p>Comprehensive installation instructions for Album can be found on the Album docs website.</p> <p>TL;DR: <pre><code>conda create -n album album -c conda-forge\nconda activate album\n</code></pre></p>"},{"location":"examples/tutorials/album/#step-2-setup-your-copick-project","title":"Step 2: Setup your copick project","text":"<p>In this example, we will create a solution that processes all runs in a copick project and stores a set of random points. Here, we will use the runs from dataset 10301 on the CZ cryoET Data Portal and a local overlay project. Other overlay backends can be used as well, see here.</p> Cofiguration Template <pre><code>{\n    \"config_type\": \"cryoet_data_portal\",\n    \"name\": \"Example Project\",\n    \"description\": \"This is an example project.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"random-points\",\n            \"is_particle\": true,\n            \"label\": 1,\n            \"color\": [\n                0,\n                117,\n                220,\n                255\n            ],\n            \"radius\": 10\n        }\n    ],\n    \"overlay_root\": \"local:///Users/utz.ermel/Documents/chlamy_proc/random_points/\",\n    \"overlay_fs_args\": {\n        \"auto_mkdir\": true\n    },\n    \"dataset_ids\" : [10301]\n}\n</code></pre>"},{"location":"examples/tutorials/album/#step-3-create-your-solution","title":"Step 3: Create your solution","text":""},{"location":"examples/tutorials/album/#environment-setup","title":"Environment setup","text":"<p>Album solutions are single Python files that contain the code to be run and information about the environment in which the code should be run. First, we will set up a baseline environment for copick projects, <code>scikit-image</code> and <code>numpy</code>. This will be used by album to create a conda environment for the solution upon installation.</p> <pre><code>###album catalog: mycatalog\n\nfrom album.runner.api import get_args, setup\n\nenv_file = \"\"\"\nchannels:\n  - conda-forge\n  - defaults\ndependencies:\n  - python=3.11\n  - pip\n  - zarr\n  - ome-zarr\n  - numpy&lt;2\n  - scipy\n  - scikit-image\n  - trimesh\n  - pip:\n    - album\n    - \"copick[all]&gt;=0.5.2\"\n\"\"\"\n</code></pre>"},{"location":"examples/tutorials/album/#arguments","title":"Arguments","text":"<p>Album automatically parses command line arguments passed to the album runner. These arguments can be accessed using the <code>get_args</code> function inside the <code>run</code> function. They can be defined as a list of dictionaries, which is passed to the <code>album.runner.api.setup()</code> call in the last step. In case of copick, useful arguments could be the path to the copick config, the run names and any output object definitions.</p> <pre><code>args = [\n    {\n        \"name\": \"copick_config_path\",\n        \"description\": \"Path to the copick config file\",\n        \"type\": \"string\",\n        \"required\": True,\n    },\n    {\n        \"name\": \"run_names\",\n        \"description\": \"List of comma-separated run names to process\",\n        \"type\": \"string\",\n        \"required\": False,\n        \"default\": \"\",\n    },\n    {\n        \"name\": \"voxel_spacing\",\n        \"description\": \"Voxel spacing for the tomograms\",\n        \"type\": \"float\",\n        \"required\": False,\n        \"default\": 10.0,\n    },\n    {\n        \"name\": \"tomo_type\",\n        \"description\": \"Type of tomogram\",\n        \"type\": \"string\",\n        \"required\": False,\n        \"default\": \"wbp\",\n    },\n    {\n        \"name\": \"num_points\",\n        \"description\": \"Number of random points to generate\",\n        \"type\": \"integer\",\n        \"required\": False,\n        \"default\": 10,\n    },\n    {\n        \"name\": \"out_object\",\n        \"description\": \"Name of the output pickable object.\",\n        \"type\": \"string\",\n        \"required\": False,\n        \"default\": \"random-points\",\n    },\n    {\n        \"name\": \"out_user\",\n        \"description\": \"User/Tool name for output points.\",\n        \"type\": \"string\",\n        \"required\": False,\n        \"default\": \"solution-01\",\n    },\n    {\n        \"name\": \"out_session\",\n        \"description\": \"Output session, indicating this set was generated by a tool.\",\n        \"type\": \"string\",\n        \"required\": False,\n        \"default\": \"0\",\n    },\n]\n</code></pre>"},{"location":"examples/tutorials/album/#solution-code","title":"Solution code","text":"<p>Next, we will write the code that will be run by album. This code has to be defined within a function called <code>run</code>. As <code>run</code> will be executed in a different environment than the solution file, it is important to move all imports into the body of the function.</p> <pre><code>def run():\n    # Imports\n    from typing import List, Sequence\n\n    import copick\n    import numpy as np\n    import zarr\n    from copick.models import CopickLocation, CopickPoint\n</code></pre> <p>Next we will parse the input arguments passed from the album runner.</p> <pre><code>    # Parse arguments\n    args = get_args()\n    copick_config_path = args.copick_config_path\n    run_names = args.run_names.split(\",\")\n    voxel_spacing = args.voxel_spacing\n    tomo_type = args.tomo_type\n    num_points = args.num_points\n    out_object = args.out_object\n    out_user = args.out_user\n    out_session = args.out_session\n</code></pre> <p>Now we will define any function that we need to process the runs. In this case, we will generate a set of random points for each run and store them in the copick project.</p> <p>Note</p> <p>This function needs to be defined within the <code>run</code> function to ensure that it is available in the album environment.</p> <pre><code>    def generate_random_points(npoints: int, mdim: Sequence[float]) -&gt; List[CopickPoint]:\n        \"\"\"Generate a set of random points.\"\"\"\n        points = []\n        for _i in range(npoints):\n            point = CopickPoint(\n                location=CopickLocation(\n                    x=np.random.rand(1) * mdim[0],\n                    y=np.random.rand(1) * mdim[1],\n                    z=np.random.rand(1) * mdim[2],\n                ),\n            )\n            points.append(point)\n        return points\n</code></pre> <p>Next, we will iterate over all runs in the copick project and store a set of random points in each run.</p> <pre><code>    # Load copick project root\n    root = copick.from_file(copick_config_path)\n\n    # If no run names are provided, process all runs\n    if run_names == [\"\"]:\n        run_names = [r.name for r in root.runs]\n\n    # Process runs\n    for run_name in run_names:\n        print(f\"Processing run {run_name}\")\n        run = root.get_run(run_name)\n\n        # Get the physical tomogram dimensions\n        vs = run.get_voxel_spacing(voxel_spacing)\n        tomo = vs.get_tomogram(tomo_type)\n        pixel_max_dim = zarr.open(tomo.zarr())[\"0\"].shape[::-1]\n        max_dim = np.array([d * voxel_spacing for d in pixel_max_dim])\n\n        # If picks of the same type already exist, we will get and overwrite them\n        picks = run.get_picks(object_name=out_object, user_id=out_user, session_id=out_session)\n\n        # If picks do not exist, we will generate new picks and add them to the run\n        if len(picks) == 0:\n            picks = run.new_picks(object_name=out_object, user_id=out_user, session_id=out_session)\n        else:\n            picks = picks[0]\n\n        points = generate_random_points(num_points, max_dim)\n        picks.points = points\n        picks.store()\n\n    print(\"Processing complete.\")\n</code></pre>"},{"location":"examples/tutorials/album/#album-solution-setup","title":"Album solution setup","text":"<p>Finally, we will set up the album solution. This is done by calling the <code>setup</code> function with the arguument list, the solution code and the environment file.</p> <pre><code>setup(\n    group=\"copick\",\n    name=\"random_points\",\n    version=\"0.1.0\",\n    title=\"Random Points\",\n    description=\"This solution generates a set of random points for each run in a copick project.\",\n    solution_creators=[\"Alice\", \"Bob\"],\n    tags=[\"copick\", \"points \"],\n    license=\"MIT\",\n    album_api_version=\"0.5.1\",\n    args=args,\n    run=run,\n    dependencies={\"environment_file\": env_file},\n)\n</code></pre>"},{"location":"examples/tutorials/album/#step-4-run-your-solution","title":"Step 4: Run your solution","text":"<p>To run the solution, save the solution code to a file, e.g. <code>random_points.py</code>, and run the following command:</p> <pre><code>album install random_points.py\nalbum run random_points.py --copick_config_path /path/to/copick_config.json --voxel_spacing 7.84\n</code></pre> <p>This will generate a set of 10 random points for each run in the copick project.</p>"},{"location":"examples/tutorials/album/#step-5-visualize-your-results","title":"Step 5: Visualize your results","text":"<p>You can visualize your output using ChimeraX-copick, napari-copick or any other visualization tool that supports the copick dataset API.</p>"},{"location":"examples/tutorials/album/#step-6-share-your-solution","title":"Step 6: Share your solution","text":"<p>The album documentation provides a comprehensive guide on how to share your solution with others using the album catalog.</p>"},{"location":"examples/tutorials/album/#tldr","title":"TL;DR","text":"<p>Full code for the solution above:</p> Random Points <pre><code>###album catalog: mycatalog\n\nfrom album.runner.api import get_args, setup\n\nenv_file = \"\"\"\nchannels:\n  - conda-forge\n  - defaults\ndependencies:\n  - python=3.11\n  - pip\n  - zarr\n  - ome-zarr\n  - numpy&lt;2\n  - scipy\n  - scikit-image\n  - trimesh\n  - pip:\n    - album\n    - \"copick[all]&gt;=0.5.2\"\n\"\"\"\n\nargs = [\n    {\n        \"name\": \"copick_config_path\",\n        \"description\": \"Path to the copick config file\",\n        \"type\": \"string\",\n        \"required\": True,\n    },\n    {\n        \"name\": \"run_names\",\n        \"description\": \"List of comma-separated run names to process\",\n        \"type\": \"string\",\n        \"required\": False,\n        \"default\": \"\",\n    },\n    {\n        \"name\": \"voxel_spacing\",\n        \"description\": \"Voxel spacing for the tomograms\",\n        \"type\": \"float\",\n        \"required\": False,\n        \"default\": 10.0,\n    },\n    {\n        \"name\": \"tomo_type\",\n        \"description\": \"Type of tomogram\",\n        \"type\": \"string\",\n        \"required\": False,\n        \"default\": \"wbp\",\n    },\n    {\n        \"name\": \"num_points\",\n        \"description\": \"Number of random points to generate\",\n        \"type\": \"integer\",\n        \"required\": False,\n        \"default\": 10,\n    },\n    {\n        \"name\": \"out_object\",\n        \"description\": \"Name of the output pickable object.\",\n        \"type\": \"string\",\n        \"required\": False,\n        \"default\": \"random-points\",\n    },\n    {\n        \"name\": \"out_user\",\n        \"description\": \"User/Tool name for output points.\",\n        \"type\": \"string\",\n        \"required\": False,\n        \"default\": \"solution-01\",\n    },\n    {\n        \"name\": \"out_session\",\n        \"description\": \"Output session, indicating this set was generated by a tool.\",\n        \"type\": \"string\",\n        \"required\": False,\n        \"default\": \"0\",\n    },\n]\n\n\ndef run():\n    # Imports\n    from typing import List, Sequence\n\n    import copick\n    import numpy as np\n    import zarr\n    from copick.models import CopickLocation, CopickPoint\n\n    # Parse arguments\n    args = get_args()\n    copick_config_path = args.copick_config_path\n    run_names = args.run_names.split(\",\")\n    voxel_spacing = args.voxel_spacing\n    tomo_type = args.tomo_type\n    num_points = args.num_points\n    out_object = args.out_object\n    out_user = args.out_user\n    out_session = args.out_session\n\n    # Function definitions\n    def generate_random_points(npoints: int, mdim: Sequence[float]) -&gt; List[CopickPoint]:\n        \"\"\"Generate a set of random points.\"\"\"\n        points = []\n        for _i in range(npoints):\n            point = CopickPoint(\n                location=CopickLocation(\n                    x=np.random.rand(1) * mdim[0],\n                    y=np.random.rand(1) * mdim[1],\n                    z=np.random.rand(1) * mdim[2],\n                ),\n            )\n            points.append(point)\n        return points\n\n    # Load copick project root\n    root = copick.from_file(copick_config_path)\n\n    # If no run names are provided, process all runs\n    if run_names == [\"\"]:\n        run_names = [r.name for r in root.runs]\n\n    # Process runs\n    for run_name in run_names:\n        print(f\"Processing run {run_name}\")\n        run = root.get_run(run_name)\n\n        # Get the physical tomogram dimensions\n        vs = run.get_voxel_spacing(voxel_spacing)\n        tomo = vs.get_tomogram(tomo_type)\n        pixel_max_dim = zarr.open(tomo.zarr())[\"0\"].shape[::-1]\n        max_dim = np.array([d * voxel_spacing for d in pixel_max_dim])\n\n        # If picks of the same type already exist, we will get and overwrite them\n        picks = run.get_picks(object_name=out_object, user_id=out_user, session_id=out_session)\n\n        # If picks do not exist, we will generate new picks and add them to the run\n        if len(picks) == 0:\n            picks = run.new_picks(object_name=out_object, user_id=out_user, session_id=out_session)\n        else:\n            picks = picks[0]\n\n        points = generate_random_points(num_points, max_dim)\n        picks.points = points\n        picks.store()\n\n    print(\"Processing complete.\")\n\n\nsetup(\n    group=\"copick\",\n    name=\"random_points\",\n    version=\"0.1.0\",\n    title=\"Random Points\",\n    description=\"This solution generates a set of random points for each run in a copick project.\",\n    solution_creators=[\"Alice\", \"Bob\"],\n    tags=[\"copick\", \"points \"],\n    license=\"MIT\",\n    album_api_version=\"0.5.1\",\n    args=args,\n    run=run,\n    dependencies={\"environment_file\": env_file},\n)\n</code></pre>"},{"location":"examples/tutorials/album/#cookiecutter-template","title":"Cookiecutter template","text":"<p>A cookiecutter template for copick solutions can be found below:</p> Cookiecutter Template <pre><code>###album catalog: mycatalog\n\nfrom album.runner.api import get_args, setup\n\nenv_file = \"\"\"\nchannels:\n  - conda-forge\n  - defaults\ndependencies:\n  - python=3.11\n  - pip\n  - zarr\n  - ome-zarr\n  - numpy&lt;2\n  - scipy\n  - scikit-image\n  - trimesh\n  - pip:\n    - album\n    - \"copick[all]&gt;=0.5.2\"\n\"\"\"\n\nargs = [\n    {\n        \"name\": \"copick_config_path\",\n        \"description\": \"Path to the copick config file\",\n        \"type\": \"string\",\n        \"required\": True,\n    },\n    {\n        \"name\": \"run_names\",\n        \"description\": \"List of comma-separated run names to process\",\n        \"type\": \"string\",\n        \"required\": False,\n        \"default\": \"\",\n    },\n    {\n        \"name\": \"voxel_spacing\",\n        \"description\": \"Voxel spacing for the tomograms\",\n        \"type\": \"float\",\n        \"required\": False,\n        \"default\": 10.0,\n    },\n    {\n        \"name\": \"tomo_type\",\n        \"description\": \"Type of tomogram\",\n        \"type\": \"string\",\n        \"required\": False,\n        \"default\": \"wbp\",\n    },\n    {\n        \"name\": \"out_object\",\n        \"description\": \"Name of the output pickable object.\",\n        \"type\": \"string\",\n        \"required\": False,\n        \"default\": \"random-points\",\n    },\n    {\n        \"name\": \"out_user\",\n        \"description\": \"User/Tool name for output points.\",\n        \"type\": \"string\",\n        \"required\": False,\n        \"default\": \"solution-01\",\n    },\n    {\n        \"name\": \"out_session\",\n        \"description\": \"Output session, indicating this set was generated by a tool.\",\n        \"type\": \"string\",\n        \"required\": False,\n        \"default\": \"0\",\n    },\n]\n\n\ndef run():\n    # Imports\n    import copick\n    from copick.models import CopickRun\n\n    # Parse arguments\n    args = get_args()\n    copick_config_path = args.copick_config_path\n\n    run_names = args.run_names.split(\",\")\n\n    # Function definitions\n    def process_run(run: CopickRun):\n        # some code ...\n        pass\n\n    # Load copick project root\n    root = copick.from_file(copick_config_path)\n\n    # If no run names are provided, process all runs\n    if run_names == [\"\"]:\n        run_names = [r.name for r in root.runs]\n\n    # Process runs\n    for run_name in run_names:\n        print(f\"Processing run {run_name}\")\n        run = root.get_run(run_name)\n\n        process_run(run)\n\n        # Store result\n\n    print(\"Processing complete.\")\n\n\nsetup(\n    group=\"copick\",\n    name=\"solution-name\",\n    version=\"0.1.0\",\n    title=\"Template\",\n    description=\"Description.\",\n    solution_creators=[\"Alice\", \"Bob\"],\n    tags=[\"copick\"],\n    license=\"MIT\",\n    album_api_version=\"0.5.1\",\n    args=args,\n    run=run,\n    dependencies={\"environment_file\": env_file},\n)\n</code></pre>"},{"location":"examples/tutorials/chimerax/","title":"ChimeraX-Copick","text":"<p>coming soon!</p>"},{"location":"examples/tutorials/data_portal/","title":"CZ cryoET Data Portal","text":""},{"location":"examples/tutorials/data_portal/#copick-cz-cryoet-data-portal","title":"copick  CZ cryoET Data Portal","text":"<p>The CZ cryoET Data Portal provides a standardized access to cryoET datasets and annotations. This tutorial demonstrates how to datasets and annotations stored on the CZ cryoET Data Portal as static data in a copick project.</p>"},{"location":"examples/tutorials/data_portal/#step-1-install-copick","title":"Step 1: Install copick","text":"<p>See the quickstart guide for instructions on how to install copick.</p>"},{"location":"examples/tutorials/data_portal/#step-2-setup-your-project","title":"Step 2: Setup your project","text":"<p>We will create a project that uses dataset 10301 from the CZ cryoET Data Portal. We will store locally created annotations in a local directory, called the \"overlay\". In the following, we will create a configuration file <code>copick_config.json</code> that describes the project.</p> <p>The configuration file is a JSON file that contains all information necessary to access the data. We first provide general information about the project, such as the project name, description, and version.</p> <pre><code>{\n  \"config_type\": \"cryoet_data_portal\",\n  \"name\": \"Example Project\",\n  \"description\": \"This is an example project.\",\n  \"version\": \"0.5.0\"\n}\n</code></pre> <p>Next, we define the objects that can be accessed and created using the copick API. Dataset 10301 already contains annotations from multiple authors, which we can access from within copick. In order to make data portal annotations available, we need to include the Gene Ontology IDs or UniProtKB accessions (<code>identifier</code>) of the objects we want to access. Any portal annotation that has a matching GO ID will be available in the copick project.</p> <p>In this case, we will obtain pre-existing annotations for the ribosome, ATPase, and membrane. We will also create a new object called \"prohibitin\" that will be stored in the overlay directory, but is not available on the data portal.</p> <pre><code>{\n  \"pickable_objects\": [\n    {\n      \"name\": \"ribosome\",\n      \"is_particle\": true,\n      \"identifier\": \"GO:0022626\",\n      \"label\": 1,\n      \"color\": [  0, 117, 220, 255],\n      \"radius\": 150\n    },\n    {\n      \"name\": \"atpase\",\n      \"is_particle\": true,\n      \"identifier\": \"GO:0045259\",\n      \"label\": 2,\n      \"color\": [251, 192, 147, 255],\n      \"radius\": 150\n    },\n    {\n      \"name\": \"membrane\",\n      \"is_particle\": false,\n      \"identifier\": \"GO:0016020\",\n      \"label\": 3,\n      \"color\": [200, 200, 200, 255],\n      \"radius\": 10\n    },\n    {\n      \"name\": \"prohibitin\",\n      \"is_particle\": true,\n      \"label\": 4,\n      \"color\": [  155, 117, 220, 255],\n      \"radius\": 10\n    }\n  ]\n}\n</code></pre> <p>Finally, we define the overlay directory where the new annotations will be stored, and the dataset ID of dataset 10301 on the CZ cryoET Data Portal.</p> <pre><code>{\n  \"overlay_root\": \"local:///home/bob/copick_project/\",\n  \"overlay_fs_args\": {\n    \"auto_mkdir\": true\n  },\n  \"dataset_ids\" : [10301]\n}\n</code></pre> Full Configuration Template <pre><code>{\n    \"config_type\": \"cryoet_data_portal\",\n    \"name\": \"Example Project\",\n    \"description\": \"This is an example project.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"identifier\": \"GO:0022626\",\n            \"label\": 1,\n            \"color\": [  0, 117, 220, 255],\n            \"radius\": 150\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"identifier\": \"GO:0045259\",\n            \"label\": 2,\n            \"color\": [251, 192, 147, 255],\n            \"radius\": 150\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"identifier\": \"GO:0016020\",\n            \"label\": 3,\n            \"color\": [200, 200, 200, 255],\n            \"radius\": 10\n        }\n    ],\n    \"overlay_root\": \"local:///Users/utz.ermel/Documents/chlamy_proc/random_points/\",\n    \"overlay_fs_args\": {\n        \"auto_mkdir\": true\n    },\n    \"dataset_ids\" : [10301]\n}\n</code></pre>"},{"location":"examples/tutorials/data_portal/#step-3-visualize-curate-or-process-the-data","title":"Step 3: Visualize, curate or process the data","text":"<p>You can now use the copick API to access the data from dataset 10301 and the overlay directory. As a first step, you can print the available objects and runs.</p> <pre><code>\"\"\"Print all objects and runs in a copick project.\"\"\"\n\nimport copick\n\n# Initialize the root object from a configuration file\nroot = copick.from_file(\"path/to/config.json\")\n\n# List all available objects\nobj_info = [(o.name, o.label) for o in root.pickable_objects]\n\nprint(\"Pickable objects in this project:\")\nfor name, label in obj_info:\n    print(f\"  {name}: {label}\")\n\n# Execute a function on each run in the project\nruns = root.runs\n\nprint(\"Runs in this project:\")\nfor run in runs:\n    print(f\"Run: {run.name}\")\n    # Do something with the run\n</code></pre> <p>Visualization works as with any other copick project. For more information, see the tutorial on ChimeraX-copick integration., or check out CellCanvas or napari-copick for alternative visualization options.</p>"},{"location":"examples/tutorials/hpc/","title":"Copick and HPC","text":""},{"location":"examples/tutorials/hpc/#copick-hpc","title":"copick  HPC","text":"<p>A frequent issue encountered when working with cryoET datasets is the need to validate or visualize results of data analysis run on a high-performance computing (HPC) cluster. Often the data is stored on a remote file system that the user's machine does not have direct access to.</p> <p>This tutorial demonstrates how to use copick to access data stored on an HPC cluster on your local machine.</p>"},{"location":"examples/tutorials/hpc/#step-1-install-copick","title":"Step 1: Install copick","text":"<p>See the quickstart guide for instructions on how to install copick. Copick must be installed on both the HPC cluster and your local machine.</p>"},{"location":"examples/tutorials/hpc/#step-2-setup-your-hpc-project","title":"Step 2: Setup your HPC project","text":"<p>On the HPC cluster we can access the data via the local filesystem. Here, we assume that we are working on the HPC cluster <code>my_cluster</code>. For reproducibility's sake we will assume that the static dataset is dataset 10301, retrieved from the cryoET data portal at cryoetdataportal.czscience.com. We will assume that the project overlay is stored in the directory <code>/hpc/data/copick_project</code> on the HPC cluster.</p> <p>We will store this information in a configuration file <code>copick_config.json</code> on the HPC cluster.</p> <p>HPC Configuration</p> <pre><code>{\n    \"config_type\": \"cryoet_data_portal\",\n    \"name\": \"Example HPC Project\",\n    \"description\": \"This project lives on an HPC cluster.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"identifier\": \"GO:0022626\",\n            \"label\": 1,\n            \"color\": [  0, 117, 220, 255],\n            \"radius\": 150\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"identifier\": \"GO:0045259\",\n            \"label\": 2,\n            \"color\": [251, 192, 147, 255],\n            \"radius\": 150\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"identifier\": \"GO:0016020\",\n            \"label\": 3,\n            \"color\": [200, 200, 200, 255],\n            \"radius\": 10\n        }\n    ],\n    \"overlay_root\": \"local:///hpc/data/copick_project/\",\n    \"overlay_fs_args\": {\n        \"auto_mkdir\": true\n    },\n    \"dataset_ids\" : [10301]\n}\n</code></pre> <p>Note that the same concept can also be applied on fully locally stored datasets. A config for that case is provided here, but will not be used in this tutorial.</p> HPC Configuration (data fully on cluster) <pre><code>{\n    \"config_type\": \"filesystem\",\n    \"name\": \"Example HPC Project\",\n    \"description\": \"This project lives on an HPC cluster.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"identifier\": \"GO:0022626\",\n            \"label\": 1,\n            \"color\": [  0, 117, 220, 255],\n            \"radius\": 150\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"identifier\": \"GO:0045259\",\n            \"label\": 2,\n            \"color\": [251, 192, 147, 255],\n            \"radius\": 150\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"identifier\": \"GO:0016020\",\n            \"label\": 3,\n            \"color\": [200, 200, 200, 255],\n            \"radius\": 10\n        }\n    ],\n    \"overlay_root\": \"local:///hpc/data/copick_project\",\n    \"overlay_fs_args\": {\n        \"auto_mkdir\": true\n    },\n    \"static_root\": \"local:///hpc/data/copick_project_static\",\n    \"static_fs_args\": {\n        \"auto_mkdir\": true\n    }\n}\n</code></pre>"},{"location":"examples/tutorials/hpc/#step-3-access-the-data-on-your-local-machine","title":"Step 3: Access the data on your local machine","text":"<p>To access the data on your local machine, we reuse most parts of the configuration file from the HPC cluster. We only need to inform copick about the location of the project on the cluster and how to access it. For simplicity, we will assume that passwordless login is set up on the HPC cluster, see the SSH documentation for more information.</p> <p>SSH Authentication</p> <p>In cases of mandatory 2-FA authentication, you may need to set up an SSH tunnel to the remote filesystem, e.g. <pre><code>ssh -L 2222:localhost:22 user.name@]my_cluster\n</code></pre> and then use <code>\"host\":\"localhost\"</code> and <code>\"port\":2222</code> as the host in the config and commands below.</p> <p>On our local machine, we create a new configuration file <code>copick_config_local.json</code> with the following content:</p> <p>Local Configuration</p> <pre><code>{\n    \"config_type\": \"cryoet_data_portal\",\n    \"name\": \"Example Local Project\",\n    \"description\": \"This Project accesses data from an HPC cluster.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"identifier\": \"GO:0022626\",\n            \"label\": 1,\n            \"color\": [  0, 117, 220, 255],\n            \"radius\": 150\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"identifier\": \"GO:0045259\",\n            \"label\": 2,\n            \"color\": [251, 192, 147, 255],\n            \"radius\": 150\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"identifier\": \"GO:0016020\",\n            \"label\": 3,\n            \"color\": [200, 200, 200, 255],\n            \"radius\": 10\n        }\n    ],\n    \"overlay_root\": \"ssh:///hpc/data/copick_project/\",\n    \"overlay_fs_args\": {\n        \"host\": \"my_cluster\",\n        \"username\": \"user.name\"\n    },\n    \"dataset_ids\" : [10301]\n}\n</code></pre> <p>As before, we can also provide a configuration for a dataset that is fully stored on the HPC cluster. This will not be used in this tutorial.</p> Local Configuration (data fully on cluster) <pre><code>{\n    \"config_type\": \"filesystem\",\n    \"name\": \"Example Local Project\",\n    \"description\": \"This Project accesses data from an HPC cluster.\",\n    \"version\": \"0.5.0\",\n    \"pickable_objects\": [\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"identifier\": \"GO:0022626\",\n            \"label\": 1,\n            \"color\": [  0, 117, 220, 255],\n            \"radius\": 150\n        },\n        {\n            \"name\": \"atpase\",\n            \"is_particle\": true,\n            \"identifier\": \"GO:0045259\",\n            \"label\": 2,\n            \"color\": [251, 192, 147, 255],\n            \"radius\": 150\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"identifier\": \"GO:0016020\",\n            \"label\": 3,\n            \"color\": [200, 200, 200, 255],\n            \"radius\": 10\n        }\n    ],\n    \"overlay_root\": \"ssh:///hpc/data/copick_project/\",\n    \"overlay_fs_args\": {\n        \"host\": \"my_cluster\",\n        \"username\": \"user.name\"\n    },\n    \"static_root\": \"ssh:///hpc/data/copick_project_static\",\n    \"static_fs_args\": {\n        \"host\": \"my_cluster\",\n        \"username\": \"user.name\"\n    }\n}\n</code></pre>"},{"location":"examples/tutorials/hpc/#step-4-modify-the-data-on-the-hpc-cluster","title":"Step 4: Modify the data on the HPC cluster","text":"<p>Using the configuration file <code>copick_config.json</code> from the previous step we can now access the data on the HPC cluster and perform processing tasks. In lieu of a full processing example, we will demonstrate how read a set of picks from the dataset save a random subset to a new file.</p> <pre><code>import copick\nimport numpy as np\n\n# Get applicable picks\nroot = copick.from_file(\"copick_config.json\")\nrun = root.get_run(\"14069\")\npicks = run.get_picks(object_name=\"ribosome\")[0]\n\n# Get a random subset of picks\npoints = picks.points\n\n# Create a new pick object (this will be saved in the overlay directory)\nnew_picks = run.new_picks(object_name=\"ribosome\", user_id=\"subset\", session_id=\"0\")\nnew_picks.points = np.random.choice(points, 20, replace=False)\nnew_picks.store()\n</code></pre>"},{"location":"examples/tutorials/hpc/#step-5-access-the-modified-data-on-your-local-machine","title":"Step 5: Access the modified data on your local machine","text":"<p>Using the configuration file <code>copick_config_local.json</code> from the previous step we can now access the modified data on our local machine without additional downloads.</p> <pre><code>import copick\n\n# Get applicable picks\nroot = copick.from_file(\"copick_config_local.json\")\nrun = root.get_run(\"14069\")\npicks = run.get_picks(object_name=\"ribosome\", user_id=\"subset\")[0]\n\n# Confirm the number\nprint(f\"Number of picks: {len(picks.points)}\")\n</code></pre>"},{"location":"examples/tutorials/hpc/#step-6-visualize-the-data","title":"Step 6: Visualize the data","text":"<p>In reality, you would likely want to visualize the data, instead of just counting the number of picks. For this, you can use the ChimeraX-copick plugin. Visualization works as with any other copick project. For more information, see the tutorial on ChimeraX-copick integration., or check out CellCanvas or napari-copick for alternative visualization options.</p>"},{"location":"examples/tutorials/kaggle_czii_sync/","title":"Syncing CZII Kaggle Challenge Dataset with Copick","text":"<p>This tutorial demonstrates how to use Copick's sync functionality to reproduce the CZII CryoET Object Identification Kaggle competition dataset structure and naming conventions.</p>"},{"location":"examples/tutorials/kaggle_czii_sync/#competition-overview","title":"Competition Overview","text":"<p>The CZII CryoET Object Identification Competition challenged participants to develop machine learning algorithms that can automatically annotate particles in 3D cellular tomograms. The competition features a phantom dataset containing 6 protein complexes:</p> <ol> <li>Apo-ferritin - Iron storage protein complex</li> <li>Beta-amylase - Starch-degrading enzyme</li> <li>Beta-galactosidase - Lactose-metabolizing enzyme</li> <li>Thyroglobulin - Thyroid hormone precursor protein</li> <li>80S ribosome - Protein synthesis machinery</li> <li>Virus-like Particles (VLPs) - Synthetic viral capsids</li> </ol>"},{"location":"examples/tutorials/kaggle_czii_sync/#prerequisites","title":"Prerequisites","text":"<p>Before starting, ensure you have the required packages installed:</p> <pre><code>uv pip install \"copick[all]&gt;=1.10.0\" \"cryoet-data-portal\"\n</code></pre> <p>You'll also need sufficient disk space for the dataset (several GB) and a stable internet connection for downloading from the CryoET Data Portal.</p>"},{"location":"examples/tutorials/kaggle_czii_sync/#how-to-sync","title":"How To Sync","text":"<p>This example demonstrates how to sync the CZII competition dataset with compatible naming conventions:</p> <pre><code>import copick\nfrom copick.ops.sync import sync_tomograms, sync_picks\nimport cryoet_data_portal as cdp\n\n# Step 1: Establish connection and name mappings\n# =============================================\n\n# Connect to the CryoET Data Portal\nclient = cdp.Client()\n\n# Retrieve all runs from dataset 10440 (CZII competition dataset)\nruns = cdp.Run.find(client, [cdp.Run.dataset_id == 10440])\n\n# Create mapping from portal run IDs to Kaggle-compatible run names\n# Copick normally uses run IDs by default because they are unique,\n# while run names may not be unique across multiple cryoET data portal datasets.\nportal_runs_to_kaggle_runs = {str(r.id): r.name for r in runs}\n\n# Map portal object names to competition object names\n# The portal uses scientific names (Gene Ontology Term/UniProtKB accession),\n# while the Kaggle competition uses simplified names\nportal_objects_to_kaggle_objects = {\n    \"beta-galactosidase\": \"beta-galactosidase\",\n    \"cytosolic-ribosome\": \"ribosome\",\n    \"virus-like-capsid\": \"virus-like-particle\",\n    \"ferritin-complex\": \"apo-ferritin\",\n    \"beta-amylase\": \"beta-amylase\",\n    \"thyroglobulin\": \"thyroglobulin\",\n}\n\n# Step 2: Configure source data access\n# ====================================\n\n# Create Copick root pointing to CryoET Data Portal dataset\n# The '/tmp/overlay' path won't store anything - it's just required by the API\nportal_root = copick.from_czcdp_datasets([10440], '/tmp/overlay')\n\n# Extract and rename pickable objects for the target dataset\nobjects = []\nfor obj in portal_root.config.pickable_objects:\n    if obj.name in portal_objects_to_kaggle_objects:\n        # Create a copy with the Kaggle-compatible name\n        kaggle_obj = obj.copy()\n        kaggle_obj.name = portal_objects_to_kaggle_objects[obj.name]\n        objects.append(kaggle_obj)\n\n# Step 3: Create target dataset structure\n# =======================================\n\n# Create new Copick project with Kaggle-compatible structure\n# This will store the synchronized data locally.\n# Update the paths as needed for your environment.\ntarget_root = copick.new_config(\n    '/tmp/czcdp_dataset_demo/copick_config.json',  # Configuration file path\n    '/tmp/czcdp_dataset_demo/',      # Data storage directory\n    pickable_objects=objects         # Object definitions with correct names\n)\n\n# Step 4: Sync tomographic data\n# =============================\n\n# Copick constructs the tomogram type from data portal metadata. The competition used\n# simplified names for tomograms, so we map the portal's processed tomogram type as well.\nsync_tomograms(\n    portal_root,                                           # Source: CryoET Data Portal\n    target_root,                                           # Target: Local Copick project\n    source_runs=list(portal_runs_to_kaggle_runs.keys()),   # All available runs\n    target_runs=portal_runs_to_kaggle_runs,                # Run name mapping\n    voxel_spacings=[10.012],                               # Competition voxel size\n    source_tomo_types=[\"wbp-denoised-denoiset-ctfdeconv\"], # Tomogram type to sync\n    target_tomo_types={\"wbp-denoised-denoiset-ctfdeconv\": \"denoised\"}, # Mapping to simplified name\n    log=True,                                              # Show progress\n    exist_ok=True,                                         # Allow overwriting\n)\n\n# Step 5: Sync annotation data\n# ============================\n\nsync_picks(\n    portal_root,                                           # Source: CryoET Data Portal\n    target_root,                                           # Target: Local Copick project\n    source_runs=list(portal_runs_to_kaggle_runs.keys()),   # All available runs\n    target_runs=portal_runs_to_kaggle_runs,                # Run name mapping\n    source_objects=list(portal_objects_to_kaggle_objects.keys()), # Portal object names\n    target_objects=portal_objects_to_kaggle_objects,       # Kaggle object name mapping\n    log=True,                                              # Show progress\n    exist_ok=True,                                         # Allow overwriting\n)\n</code></pre>"},{"location":"examples/tutorials/kaggle_czii_sync/#expected-outcomes","title":"Expected Outcomes","text":"<p>After running this script, you'll have:</p>"},{"location":"examples/tutorials/kaggle_czii_sync/#local-dataset-structure","title":"Local Dataset Structure","text":"<pre><code>/tmp/czcdp_dataset_demo/\n\u251c\u2500\u2500 ExperimentRuns/\n\u2502   \u251c\u2500\u2500 TS_5_4/\n\u2502   \u2502   \u251c\u2500\u2500 VoxelSpacing10.012/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 Tomograms/\n\u2502   \u2502   \u2502       \u2514\u2500\u2500 denoised.zarr/\n\u2502   \u2502   \u2514\u2500\u2500 Picks/\n\u2502   \u2502       \u251c\u2500\u2500 data-portal_74183_apo-ferritin.json\n\u2502   \u2502       \u251c\u2500\u2500 data-portal_74184_beta-amylase.json\n\u2502   \u2502       \u251c\u2500\u2500 data-portal_74185_beta-galactosidase.json\n\u2502   \u2502       \u251c\u2500\u2500 data-portal_74186_ribosome.json\n\u2502   \u2502       \u251c\u2500\u2500 data-portal_74187_thyroglobulin.json\n\u2502   \u2502       \u2514\u2500\u2500 data-portal_74188_virus-like-particle.json\n\u2502   \u251c\u2500\u2500 [run_name_2]/\n\u2502   \u2514\u2500\u2500 [additional_runs]/\n\u2514\u2500\u2500 copick_config.json\n</code></pre>"},{"location":"examples/tutorials/kaggle_czii_sync/#next-steps-for-ml-pipeline-integration","title":"Next Steps for ML Pipeline Integration","text":"<p>After syncing the data, you can:</p> <ol> <li> <p>Load into ML frameworks: <pre><code>import copick\nroot = copick.from_file('/tmp/czcdp_dataset_demo/copick_config.json')\n</code></pre></p> </li> <li> <p>Explore the data: <pre><code># List available runs and objects\nfor run in root.runs:\n    print(f\"Run: {run.name}\")\n    for pick in run.picks:\n        print(f\"  - {pick.object_name}: {len(pick.points)} particles\")\n        picks_array, _ = pick.points.numpy()  # Get points as NumPy array\n</code></pre></p> </li> </ol>"},{"location":"examples/tutorials/membrain/","title":"Copick and membrain-seg","text":"<p>coming soon!</p>"},{"location":"examples/tutorials/sample_boundaries/","title":"Detecting Sample Boundaries","text":""},{"location":"examples/tutorials/sample_boundaries/#predicting-sample-boundaries","title":"Predicting sample boundaries","text":"Side view onto a cryo-electron tomogram (run 15094) without (left) and with (right) sample boundary annotation <p>Biological samples acquired in a cryoET experiment are usually thin slabs of vitrified ice containing the biological specimen of interest. Unfortunately, it is difficult to determine orientation and thickness of the samples ahead of reconstruction. For this reason, volumes reconstructed from cryoET tilt series are often larger than the actual sample and contain a significant amount of empty space (i.e. the vacuum inside the TEM column).</p> <p>There are several reasons for why it can be useful to determine more accurate sample boundaries, e.g.</p> <ul> <li>statistical analysis of the sample preparation process</li> <li>masking out the vacuum region to reduce the size of the volume</li> <li>masking out the vacuum region during the training of a neural network</li> <li>capping of membrane segmentations to define topological boundaries</li> </ul> <p>Below, we will show how to use copick, an adapted version of deepfinder and album to predict sample boundaries for datasets 10301 and 10302 from the CZ cryoET Data Portal.</p> Top view onto the same tomogram (run 15094) from dataset 10302."},{"location":"examples/tutorials/sample_boundaries/#step-0-environment-and-pre-requisites","title":"Step 0: Environment and Pre-requisites","text":"<p>For the purpose of this tutorial we will assume that we are working on a machine with access to an NVIDIA GPU and a working <code>CUDA 12.3</code>/<code>CUDNN 8.9</code> installation. Before we can start, we need to install the necessary software. We will use the following tools:</p>"},{"location":"examples/tutorials/sample_boundaries/#1-chimerax-and-chimerax-copick-for-visualization-and-annotation","title":"1. ChimeraX and ChimeraX-copick (for visualization and annotation)","text":"<p>Download and install ChimeraX from here. After installing ChimeraX, install the ChimeraX-copick extension by running the following command in ChimeraX:</p> <pre><code>toolshed install copick\n</code></pre>"},{"location":"examples/tutorials/sample_boundaries/#2-album-and-copick-catalog-for-processing-steps","title":"2. Album and copick-catalog (for processing steps)","text":"<p>Comprehensive installation instructions for Album can be found on the Album docs website.</p> <p>TL;DR: <pre><code>conda create -n album album -c conda-forge\nconda activate album\n</code></pre></p> <p>Now, add copick's Album catalog (copick-catalog) to your album installation and install the requried solutions by running the following commands:</p> <pre><code>album add-catalog git@github.com:copick/copick-catalog.git\nalbum update &amp;&amp; album upgrade\nalbum install copick:create_empty_picks:0.4.0\nalbum install copick:fit_sample:0.8.0\nalbum install copick:create_rec_limits:0.6.0\nalbum install copick:intersect_mesh:0.6.0\nalbum install copick:mesh_to_seg:0.8.0\nalbum install copick:sample_mesh:0.6.0\nalbum install copick:fit_sample_seg:0.10.0\n</code></pre>"},{"location":"examples/tutorials/sample_boundaries/#3-j-finder-for-segmentation","title":"3. J-finder (for segmentation)","text":"<p>Download and install a copick-compatible version of deepfinder:</p> <pre><code>conda create -n deepfinder python=3.10\nconda activate deepfinder\ngit clone https://github.com/jtschwar/cryoet-deepfinder.git\ncd cryoet-deepfinder\npip install .\n</code></pre>"},{"location":"examples/tutorials/sample_boundaries/#step-1-setup-your-copick-projects","title":"Step 1: Setup your copick projects","text":"<p>We will create two copick projects that use datasets 10301 and 10302 from the CZ cryoET Data Portal. Both datasets stem from the same experiments and have the same characteristics, but the tomograms in dataset 10301 have protein annotations. We will use dataset 10301 as a training set and evaluate on dataset 10302.</p> <p>We will store new annotations in a local directory, called the \"overlay\", while the tomogram image data is obtained from the CZ cryoet data portal. In the following, we will create a configuration file <code>config_train.json</code> that describes the project. The configuration file is a JSON file that contains all information necessary to access the data and describing the objects that can be accessed and created using the copick API.</p> <p>The first part of the configuration file provides general information about the project, such as the project name, description, and copick-API version.</p> click to expand <pre><code>{\n  \"config_type\": \"cryoet_data_portal\",\n  \"name\": \"Sample Boundary Prediction - Training Set\",\n  \"description\": \"This project uses dataset 10301 from the CZ cryoET Data Portal as a training set for sample boundary prediction.\",\n  \"version\": \"0.5.4\"\n}\n</code></pre> <p>Next, we define the objects that can be accessed and created using the copick API. In this case we will create X objects:</p> <ul> <li>top-layer -- the top layer of the sample</li> <li>bottom-layer -- the bottom layer of the sample</li> <li>valid-area -- the valid area of the reconstructed tomogram</li> <li>sample -- the sample itself</li> <li>valid-sample -- the sample excluding the invalid reconstruction area</li> </ul> click to expand <pre><code>{\n  \"pickable_objects\": [\n        {\n            \"name\": \"top-layer\",\n            \"is_particle\": true,\n            \"label\": 100,\n            \"color\": [  255, 0, 0, 255],\n            \"radius\": 150,\n            \"map_threshold\": 0.037\n        },\n        {\n            \"name\": \"bottom-layer\",\n            \"is_particle\": true,\n            \"label\": 101,\n            \"color\": [\n                0,\n                255,\n                0,\n                255\n            ],\n            \"radius\": 150,\n            \"map_threshold\": 0.037\n        },\n        {\n            \"name\": \"sample\",\n            \"is_particle\": false,\n            \"label\": 102,\n            \"color\": [  0, 0, 255, 128],\n            \"radius\": 150,\n            \"map_threshold\": 0.037\n        },\n        {\n            \"name\": \"valid-area\",\n            \"is_particle\": false,\n            \"label\": 103,\n            \"color\": [\n                255,\n                255,\n                0,\n                128\n            ],\n            \"radius\": 150,\n            \"map_threshold\": 0.037\n        },\n        {\n            \"name\": \"valid-sample\",\n            \"is_particle\": false,\n            \"label\": 2,\n            \"color\": [\n                0,\n                255,\n                255,\n                128\n            ],\n            \"radius\": 150,\n            \"map_threshold\": 0.037\n        }\n    ]\n}\n</code></pre> <p>Finally, we define where copick should look for the data and store any annotations (in this case the home directory of Bob).</p> click to expand <pre><code>{\n  \"overlay_root\": \"local:///home/bob/copick_project_train/\",\n  \"overlay_fs_args\": {\n    \"auto_mkdir\": true\n  },\n  \"dataset_ids\" : [10301]\n}\n</code></pre> <p>We will repeat this process for a second project, <code>config_evaluate.json</code>, that includes both dataset 10301 and dataset 10302 for evaluation. Find both full examples below:</p> <code>config_train.json</code> <pre><code>{\n  \"config_type\": \"cryoet_data_portal\",\n  \"name\": \"Sample Boundary Prediction - Training Set\",\n  \"description\": \"This project uses dataset 10301 from the CZ cryoET Data Portal as a training set for sample boundary prediction.\",\n  \"version\": \"0.5.4\",\n  \"pickable_objects\": [\n        {\n            \"name\": \"top-layer\",\n            \"is_particle\": true,\n            \"label\": 100,\n            \"color\": [  255, 0, 0, 255],\n            \"radius\": 150,\n            \"map_threshold\": 0.037\n        },\n        {\n            \"name\": \"bottom-layer\",\n            \"is_particle\": true,\n            \"label\": 101,\n            \"color\": [\n                0,\n                255,\n                0,\n                255\n            ],\n            \"radius\": 150,\n            \"map_threshold\": 0.037\n        },\n        {\n            \"name\": \"sample\",\n            \"is_particle\": false,\n            \"label\": 102,\n            \"color\": [  0, 0, 255, 128],\n            \"radius\": 150,\n            \"map_threshold\": 0.037\n        },\n        {\n            \"name\": \"valid-area\",\n            \"is_particle\": false,\n            \"label\": 103,\n            \"color\": [\n                255,\n                255,\n                0,\n                128\n            ],\n            \"radius\": 150,\n            \"map_threshold\": 0.037\n        },\n        {\n            \"name\": \"valid-sample\",\n            \"is_particle\": false,\n            \"label\": 2,\n            \"color\": [\n                0,\n                255,\n                255,\n                128\n            ],\n            \"radius\": 150,\n            \"map_threshold\": 0.037\n        }\n    ],\n  \"overlay_root\": \"local:///home/bob/copick_project_train/\",\n  \"overlay_fs_args\": {\n    \"auto_mkdir\": true\n  },\n  \"dataset_ids\" : [10301]\n}\n</code></pre> <code>config_evaluate.json</code> <pre><code>{\n  \"config_type\": \"cryoet_data_portal\",\n  \"name\": \"Sample Boundary Prediction - Evaluation Set\",\n  \"description\": \"This project uses datasets 10301 and 10302 from the CZ cryoET Data Portal for sample boundary prediction.\",\n  \"version\": \"0.5.4\",\n  \"pickable_objects\": [\n        {\n            \"name\": \"top-layer\",\n            \"is_particle\": true,\n            \"label\": 100,\n            \"color\": [  255, 0, 0, 255],\n            \"radius\": 150,\n            \"map_threshold\": 0.037\n        },\n        {\n            \"name\": \"bottom-layer\",\n            \"is_particle\": true,\n            \"label\": 101,\n            \"color\": [\n                0,\n                255,\n                0,\n                255\n            ],\n            \"radius\": 150,\n            \"map_threshold\": 0.037\n        },\n        {\n            \"name\": \"sample\",\n            \"is_particle\": false,\n            \"label\": 102,\n            \"color\": [  0, 0, 255, 128],\n            \"radius\": 150,\n            \"map_threshold\": 0.037\n        },\n        {\n            \"name\": \"valid-area\",\n            \"is_particle\": false,\n            \"label\": 103,\n            \"color\": [\n                255,\n                255,\n                0,\n                128\n            ],\n            \"radius\": 150,\n            \"map_threshold\": 0.037\n        },\n        {\n            \"name\": \"valid-sample\",\n            \"is_particle\": false,\n            \"label\": 2,\n            \"color\": [\n                0,\n                255,\n                255,\n                128\n            ],\n            \"radius\": 150,\n            \"map_threshold\": 0.037\n        }\n    ],\n  \"overlay_root\": \"local:///home/bob/copick_project_evaluate/\",\n  \"overlay_fs_args\": {\n    \"auto_mkdir\": true\n  },\n  \"dataset_ids\" : [10301, 10302]\n}\n</code></pre>"},{"location":"examples/tutorials/sample_boundaries/#step-2-annotate-the-training-set","title":"Step 2: Annotate the training set","text":"<p>We will now use ChimeraX to annotate the top- and bottom- boundaries of the training set. In a first step we will create empty <code>CopickPicks</code> objects for the top- and bottom-layer in the training set. To do this we use the <code>create_empty_picks</code>-solution:</p> <pre><code>album run copick:create_empty_picks:0.4.0 \\\n--copick_config_path config_train.json \\\n--out_object top-layer \\\n--out_user bob \\\n--out_session 1\n\nalbum run copick:create_empty_picks:0.4.0 \\\n--copick_config_path config_train.json \\\n--out_object bottom-layer \\\n--out_user bob \\\n--out_session 1\n</code></pre> <p>Open ChimeraX and start the copick extension by running the following command in the ChimeraX command line:</p> <pre><code>copick start config_train.json\n</code></pre> The ChimeraX-copick interface after loading run 14069. <p>This will open a new window with the copick interface. On the top left side you will see the available objects, on the bottom left you can find a list of runs in the dataset. On the right side you can find the interface of ArtiaX (the plugin that allows you to annotate objects in ChimeraX).</p> <p>Double-click a run's directory (e.g. <code>14069</code>) in the run list to show the available resolutions, double-click the resolution's directory (<code>VS:7.840</code>) to display the available tomograms. In order to load a tomogram, double-click the tomogram.</p> <p>The tomogram will be displayed in the main viewport in the center. Available pickable objects are displayed in the list on the left side. Select a pickable object (e.g. top-layer) by double-clicking it and start annotating the top-border of the sample by placing points on the top-border of the sample.</p> <p>You can switch the slicing direction in the <code>Tomogram</code>-tab on the right. You can move through the 2D slices of the tomogram using the slider on the right or <code>Shift + Mouse Wheel</code>. For more information on how to use the copick interface, see the info box below and refer to the ChimeraX documentation.</p> Keyboard Shortcuts <p>Particles</p> <ul> <li><code>--</code> Remove Particle.</li> <li><code>00</code> Set 0% transparency for active particle list.</li> <li><code>55</code> Set 50% transparency for active particle list.</li> <li><code>88</code> Set 80% transparency for active particle list.</li> <li><code>aa</code> Previous Particle.</li> <li><code>dd</code> Next Particle.</li> <li><code>sa</code> Select all particles for active particle list.</li> <li><code>ss</code> Select particles mode</li> <li><code>ww</code> Hide/Show ArtiaX particle lists.</li> </ul> <p>Picking</p> <ul> <li><code>ap</code> Add on plane mode</li> <li><code>dp</code> Delete picked mode</li> <li><code>ds</code> Delete selected particles</li> </ul> <p>Visualization</p> <ul> <li><code>cc</code> Turn Clipping On/Off</li> <li><code>ee</code> Switch to orthoplanes.</li> <li><code>ff</code> Move planes mouse mode.</li> <li><code>qq</code> Switch to single plane.</li> <li><code>rr</code> Rotate slab mouse mode.</li> <li><code>xx</code> View XY orientation.</li> <li><code>yy</code> View YZ orientation.</li> <li><code>zz</code> View XZ orientation.</li> </ul> <p>Info</p> <ul> <li><code>?</code> Show Shortcuts in Log.</li> <li><code>il</code> Toggle Info Label.</li> </ul> <p>At the end of this step, you should have annotated the top- and bottom-layer of the all 18 tomograms in the training set.</p> Points clicked along the top and bottom boundary of the sample of a tomogram."},{"location":"examples/tutorials/sample_boundaries/#step-3-create-the-training-data","title":"Step 3: Create the training data","text":""},{"location":"examples/tutorials/sample_boundaries/#valid-reconstruction-area","title":"Valid reconstruction area","text":"<p>Next, we will create the training data for the sample boundary prediction. First, we will create bounding boxes that describe the valid reconstruction area in each tomogram. In most TEMs, the tilt axis is not exactly parallel to either of the detector axes, causing tomograms to have small regions of invalid reconstruction at the corners. Using the <code>create_rec_limits</code>-solution, we can compute 3D meshes that describe the valid reconstruction area in each tomogram.</p> <p>In this case, we will assume an in-plane rotation of -6 degrees.</p> <pre><code>album run copick:create_rec_limits:0.6.0 \\\n--copick_config_path config_train.json \\\n--voxel_spacing 7.84 \\\n--tomo_type wbp \\\n--angle -6 \\\n--output_object valid-area \\\n--output_user bob \\\n--output_session 0\n</code></pre> <p>You can now visualize the created bounding boxes in ChimeraX by restarting the copick interface and selecting the <code>valid-area</code> object in the Mesh-tab on the left side.</p> Top view onto a tomogram (run 15094) without (left) and with (right) valid reconstruction area mesh overlayed."},{"location":"examples/tutorials/sample_boundaries/#sample","title":"Sample","text":"<p>Now, we will use the points created in Step 2 to create a second 3D mesh that describes the sample boundaries. We do this, by fitting a plane defined by a cubic spline grid to the points using the torch-cubic-spline-grid package in the <code>fit_sample</code>-solution.</p> <pre><code>album run copick:fit_sample:0.8.0 \\\n--copick_config_path config_train.json \\\n--top_object top-layer \\\n--bottom_object bottom-layer \\\n--input_user bob --input_session 1 \\\n--voxel_spacing 7.84 \\\n--tomo_type wbp \\\n--output_object sample \\\n--output_user bob \\\n--output_session 0\n</code></pre>"},{"location":"examples/tutorials/sample_boundaries/#intersection","title":"Intersection","text":"<p>Next, we will intersect the valid reconstruction area with the sample to create a new object that describes the valid sample area. We do this using the <code>intersect_mesh</code>-solution:</p> <p><pre><code>album run copick:intersect_mesh:0.6.0 \\\n--copick_config_path config_train.json \\\n--object_a valid-area \\\n--user_a bob \\\n--session_a 0 \\\n--object_b sample \\\n--user_b bob \\\n--session_b 0 \\\n--output_object valid-sample \\\n--output_user bob \\\n--output_session 0 \\\n</code></pre> You can now visualize the final 3D mesh for training in ChimeraX by restarting the copick interface and selecting the <code>valid-area</code> object in the Mesh-tab on the left side.</p> Side view of the tomogram with points and intersected, valid sample area."},{"location":"examples/tutorials/sample_boundaries/#training-data","title":"Training data","text":"<p>Finally, we will create the training data for the sample boundary prediction. We will use the <code>mesh_to_seg</code>-solution to create a dense segmentation of the same size as the tomogram from the 3D meshes.</p> <pre><code>album run copick:mesh_to_seg:0.8.0 \\\n--copick_config_path config_train.json \\\n--input_object valid-sample \\\n--input_user bob \\\n--input_session 0 \\\n--voxel_spacing 7.84 \\\n--tomo_type wbp\n</code></pre> <p>We also need to determine where sub-volumes for training should be cropped. This allows us to ensure the correct ratio of positive and negative samples in the training data. We will use the <code>sample_mesh</code>-solution to create a set of points sampled using poisson disk and rejection sampling. The solution allows to specify the number of points inside, on the surface and outside the mesh.</p> <pre><code>album run copick:sample_mesh:0.6.0 \\\n--copick_config_path config_train.json \\\n--input_object valid-sample \\\n--input_user bob \\\n--input_session 0 \\\n--voxel_spacing 7.84 \\\n--tomo_type wbp \\\n--num_surf 300 \\        # Number of points on the surface of the mesh\n--num_internal 300 \\    # Number of points inside of the mesh\n--num_random 100 \\      # Number of points outside of the mesh\n--min_dist 200 \\        # Minimum distance between points in angstrom\n--output_user bob\n</code></pre> <p>The resulting segmentations will have the same name, user and session ID as the input object. You can now visualize the segmentations in ChimeraX by restarting the copick interface and selecting the <code>valid-sample</code> object in the <code>Segmentation</code>-tab on the top left part of the interface. You can also visualize the sampled points from the <code>Points</code>-tab on the left side.</p>"},{"location":"examples/tutorials/sample_boundaries/#step-4-train-the-model","title":"Step 4: Train the model","text":""},{"location":"examples/tutorials/sample_boundaries/#create-the-multilabel-segmentation","title":"Create the multilabel segmentation","text":"<p>In the next step, we will create a second dense segmentation volume that contains the sample segmentation from the previous step. This is redundant in this case, but necessary for the training of the J-finder model if there were multiple segmentation targets. While the segmentation created previously is a binary mask, the segmentation volume created here contains integer labels for each voxel, corresponding to the \"label\" field in the <code>pickable_objects</code>-list in the configuration file.</p> <p>In order to do this, we will run step 1 of the J-finder pipeline:</p> <pre><code>step1 create \\\n--config config_train.json \\\n--target valid-sample bob 0 0 \\          # Format: input-picks-name user session radius\n--seg-target valid-sample bob 0 \\        # Format: input-segmentation-name from-mesh user session\n--voxel-size 7.84 \\\n--tomogram-algorithm wbp \\\n--out-name sampletargets\n</code></pre> <p>This should create a new segmentation volume with name <code>sampletargets</code>, user <code>train-deepfinder</code> and session <code>0</code>.</p>"},{"location":"examples/tutorials/sample_boundaries/#train-the-model","title":"Train the model","text":"<p>Next, we will train the J-finder model using the training data created in the previous steps. We will use the <code>train</code>-command of the J-finder pipeline:</p> <pre><code>mkdir outputs\n\nstep2 train \\\n--path-train config_train.json \\\n--train-voxel-size 7.84 \\\n--train-tomo-type wbp \\\n--output-path outputs/ \\\n--n-class 3 --dim-in 64 \\\n--valid-tomo-ids 14069,14070,14071 \\\n--train-tomo-ids 14072,14073,14074,14075,14076,14077,14078,14079,14080,14081,14082,14083,14084,14085,14086 \\\n--sample-size 10 \\\n--label-name sampletargets \\\n--target valid-sample bob 0\n</code></pre> <p>In this case, runs <code>14069</code>, <code>14070</code>, and <code>14071</code> will be used for validation, while the remaining runs will be used for training. The model will be trained for 10 epochs with a sample size of 10. The model will be saved in the <code>outputs</code>-directory.</p>"},{"location":"examples/tutorials/sample_boundaries/#step-5-evaluate-the-model","title":"Step 5: Evaluate the model","text":"<p>Now, we will evaluate the model on the evaluation set. For demonstration purposes we will only evaluate on three tomograms. We will use the <code>segment</code>-command of the J-finder pipeline:</p> <pre><code>step3 segment \\\n--predict-config config_evaluate.json \\\n--path-weights outputs/net_weights_FINAL.h5 \\\n--n-class 3 --patch-size 196 \\\n--voxel-size 7.84 \\\n--tomogram-algorithm wbp \\\n--segmentation-name segmentation \\\n--user-id output \\\n--session-id 0 \\\n--tomo-ids 14114,14132,14137,14163\n</code></pre> <p>This will create a new segmentation volume with name <code>segmentation</code>, user <code>output</code> and session <code>0</code> for the tomograms <code>14114</code>, <code>14132</code>, <code>14137</code>, and <code>14163</code>. You can now visualize the segmentations in ChimeraX by restarting the copick interface and selecting the <code>segmentation</code> object in the <code>Segmentation</code>-tab on the top left part of the interface.</p> Segmentation generated by the model and box fit to the segmentation."},{"location":"examples/tutorials/sample_boundaries/#step-6-post-processing","title":"Step 6: Post-processing","text":"<p>Finally, we will post-process the segmentations to create the final sample boundaries. The segmentations can contain small isolated regions that are not part of the sample. We will use the <code>fit_sample_seg</code>-solution to fit a box with parallel sides to the segmentation.</p> <pre><code>album run copick:fit_sample_seg:0.10.0 \\\n--copick_config_path config_evaluate.json \\\n--top_object top-layer \\\n--bottom_object bottom-layer \\\n--input_user output \\\n--input_session 0 \\\n--seg_name segmentation \\\n--voxel_spacing 7.84 \\\n--tomo_type wbp \\\n--run_names 14114,14132,14137,14163 \\\n--output_object valid-sample \\\n--output_user output \\\n--output_session 0\n</code></pre> <p>You can now visualize the final 3D mesh for evaluation in ChimeraX by restarting the copick interface and selecting the <code>valid-sample</code> object in the <code>Mesh</code>-tab on the left side. Below you can see the final result for the three tomograms <code>14114</code>, <code>14132</code>, <code>14137</code>, and <code>14163</code>.</p>  Clipped boundaries predicted for run 14114,   run 14132,   run 14137, and   run 14163 (left to right, top to bottom)."}]}