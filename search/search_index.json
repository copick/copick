{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"copick","text":"<p>copick is a cross-platform, storage-agnostic and server-less dataset API for cryoET datasets. Access to the data is provided through an object-oriented API that abstracts away the underlying storage using the fsspec-family of libraries.</p>"},{"location":"#why-copick","title":"Why copick?","text":"<ul> <li>storage-agnostic: Access data on local or shared filesystems, via SSH or on the cloud with the same API. No     need for your own boilerplate!</li> <li>cloud-ready: Access image data quickly and in parallel thanks to multiscale OME-Zarr!</li> <li>server-less: No need for a dedicated server or database to access your data, just point copick to your data     and go!</li> <li>cross-platform: copick works on any platform that supports Python. Compute on Linux, visualize on Windows or     Mac, all with the same dataset API!</li> <li>ecosystem: Using the copick API allows visualizing and curating data in ChimeraX and Napari right away!</li> </ul>"},{"location":"#data","title":"Data","text":"<p>Currently, copick supports the following types of data frequently encountered in cryoET datasets:</p> <ul> <li>tomograms</li> <li>feature maps</li> <li>dense segmentations</li> <li>mesh annotations</li> <li>point annotations</li> </ul>"},{"location":"#storage-backends","title":"Storage backends","text":"<p>Copick should support any storage backend that is supported by fsspec.</p> <p>The following backends are included in tests and should work out of the box:</p> <ul> <li>local filesystem</li> <li>s3</li> <li>smb</li> <li>access via ssh</li> </ul>"},{"location":"datamodel/","title":"Data Model","text":"<p>The on-disk data model of copick is as follows:</p> <pre><code>\ud83d\udcc1 copick_root\n\u251c\u2500 \ud83d\udcc4 copick_config.json\n\u251c\u2500 \ud83d\udcc1 Objects\n\u2502  \u2514\u2500 \ud83d\udcc4 [pickable_object_name].zarr\n\u2514\u2500 \ud83d\udcc1 ExperimentRuns\n   \u2514\u2500 \ud83d\udcc1 [run_name] (index: src/io/copick_models.py:CopickPicks.runs)\n      \u251c\u2500 \ud83d\udcc1 VoxelSpacing[xx.yyy]/\n      \u2502  \u251c\u2500 \ud83d\udcc1 [tomotype].zarr/\n      \u2502  \u2502  \u2514\u2500 [OME-NGFF spec at 100%, 50% and 25% scale]\n      \u2502  \u2514\u2500 \ud83d\udcc1 [tomotype]_[feature_type]_features.zarr/\n      \u2502     \u2514\u2500 [OME-NGFF spec at 100% scale]\n      \u251c\u2500 \ud83d\udcc1 VoxelSpacing[x2.yy2]/\n      \u2502  \u251c\u2500 \ud83d\udcc1 [tomotype].zarr/\n      \u2502  \u2502  \u2514\u2500 [OME-NGFF spec at 100%, 50% and 25% scale]\n      \u2502  \u2514\u2500 \ud83d\udcc1 [tomotype]_[feature_type]_features.zarr/\n      \u2502     \u2514\u2500 [OME-NGFF spec at 100% scale]\n      \u251c\u2500 \ud83d\udcc1 Picks/\n      \u2502  \u2514\u2500 \ud83d\udcc4 [user_id | tool_name]_[session_id | 0]_[object_name].json\n      \u251c\u2500 \ud83d\udcc1 Meshes/\n      \u2502  \u2514\u2500 \ud83d\udcc4 [user_id | tool_name]_[session_id | 0]_[object_name].glb\n      \u2514\u2500 \ud83d\udcc1 Segmentations/\n         \u251c\u2500 \ud83d\udcc1 [xx.yyy]_[user_id | tool_name]_[session_id | 0]_[object_name].zarr\n         \u2502   \u2514\u2500 [OME-NGFF spec at 100% scale, 50% and 25% scale]\n         \u2514\u2500 \ud83d\udcc1 [xx.yyy]_[user_id | tool_name]_[session_id | 0]_[name]-multilabel.zarr\n             \u2514\u2500 [OME-NGFF spec at 100% scale, 50% and 25% scale]\n</code></pre>"},{"location":"quickstart/","title":"Quick Start","text":""},{"location":"quickstart/#requirements","title":"Requirements","text":"<p>copick runs on Python 3.9 and above on Linux, MacOS, and Windows.</p> <p>It requires the following packages:</p> <ul> <li>fsspec</li> <li>pydantic</li> <li>numpy</li> <li>trimesh</li> <li>zarr</li> </ul>"},{"location":"quickstart/#installation","title":"Installation","text":"<p>copick can be installed using pip. Using the <code>all</code> extra installs necessary requirements for all tested filesystem implementations from the fsspec family (<code>local</code>, <code>s3fs</code>, <code>smb</code>, <code>sshfs</code>). Separate <code>s3</code>, <code>smb</code>, and <code>ssh</code> extras are available.</p> <pre><code>pip install \"copick[all]\"\n</code></pre>"},{"location":"quickstart/#example-dataset","title":"Example dataset","text":"<p>An example dataset can be obtained from Zenodo.</p> <p>To test with the example dataset:</p> <ol> <li>Download and unpack the example dataset</li> <li> <p>Add the location of the <code>sample_project</code>-directory in the unpacked dataset to <code>filesystem_overlay_only.json</code> <pre><code>{\n    \"name\": \"test\",\n    \"description\": \"A test project.\",\n    \"version\": \"1.0.0\",\n\n    \"pickable_objects\": [\n        {\n            \"name\": \"proteasome\",\n            \"is_particle\": true,\n            \"pdb_id\": \"3J9I\",\n            \"label\": 1,\n            \"color\": [255, 0, 0, 255],\n            \"radius\": 60,\n            \"map_threshold\": 0.0418\n        },\n        {\n            \"name\": \"ribosome\",\n            \"is_particle\": true,\n            \"pdb_id\": \"7P6Z\",\n            \"label\": 2,\n            \"color\": [0, 255, 0, 255],\n            \"radius\": 150,\n            \"map_threshold\": 0.037\n\n        },\n        {\n            \"name\": \"membrane\",\n            \"is_particle\": false,\n            \"label\": 3,\n            \"color\": [0, 0, 0, 255]\n        }\n    ],\n\n    // Change this path to the location of sample_project\n    \"overlay_root\": \"local:///PATH/TO/EXTRACTED/PROJECT/\",\n\n    \"overlay_fs_args\": {\n        \"auto_mkdir\": true\n    }\n}\n</code></pre></p> </li> <li> <p>Start copick with the configuration file</p> <pre><code>from copick.impl.filesystem import CopickRootFSSpec\nroot = CopickRootFSSpec.from_file('path/to/filesystem_overlay_only.json')\n</code></pre> </li> <li> <p>Access the data using the copick API</p> <pre><code>import zarr\n\nfrom copick.impl.filesystem import CopickRootFSSpec\nroot = CopickRootFSSpec.from_file('path/to/filesystem_overlay_only.json')\n\n# Get a run by name\nrun = root.get_run(\"TS_001\")\n\n # Get a tomogram by name\ntomogram = run.get_voxel_spacing(10).get_tomogram(\"wbp\")\n\n# Access the data\ngroup = zarr.open(tomogram.zarr())\n_, array = group.arrays()[0]\n</code></pre> </li> </ol>"},{"location":"api_reference/api/","title":"API Overview","text":""},{"location":"api_reference/api/#abstract-data-entities","title":"Abstract Data Entities","text":"<p>The copick API allows object-oriented access to cryoET data entities. Each data entity has a corresponding metadata model defined in pydantic. There is a set of abstract base classes that define the common interface for all data entities and the associated metadata models. The data entities are organized in a hierarchy that reflects the on-disk data model of copick and the structure of a typical cryoET dataset.</p> <p>The abstract data entities are defined in the <code>copick.models</code> module and given in the table below.</p> Data Entity Class Metadata Class Project Root CopickRoot CopickConfig ... Copick Object CopickObject PickableObject ... Run CopickRun CopickRunMeta ...... Picks CopickPicks CopickPicksFile ...... Mesh CopickMesh CopickMeshMeta ...... Segmentation CopickSegmentation CopickSegmentationMeta ...... Voxel Spacing CopickVoxelSpacing CopickVoxelSpacingMeta ......... Tomogram CopickTomogram CopickTomogramMeta ......... Features CopickFeatures CopickFeaturesMeta"},{"location":"api_reference/api/#implementations","title":"Implementations","text":"<p>There are concrete implementations of the abstract data entities that are used to access data in a copick dataset.</p> <ul> <li>Overlay: An extenstion to the abstract copick API implementation that adds methods to seamlessly overlay data from different sources.</li> <li>Filesystem: A concrete implementation that reads and writes data to any storage supported by <code>fsspec</code>.</li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickFeatures/","title":"CopickFeatures","text":""},{"location":"api_reference/base_classes/data_entity_models/CopickFeatures/#copick.models.CopickFeatures","title":"<code>copick.models.CopickFeatures</code>","text":"<p>Encapsulates all data pertaining to a specific feature map, i.e. the Zarr-store for the feature map.</p> <p>Attributes:</p> <ul> <li> <code>tomogram</code>               (<code>CopickTomogram</code>)           \u2013            <p>Reference to the tomogram this feature map belongs to.</p> </li> <li> <code>meta</code>               (<code>CopickFeaturesMeta</code>)           \u2013            <p>Metadata for this feature map.</p> </li> <li> <code>tomo_type</code>               (<code>str</code>)           \u2013            <p>Type of the tomogram that the features were computed on.</p> </li> <li> <code>feature_type</code>               (<code>str</code>)           \u2013            <p>Type of the features contained.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickFeatures/#copick.models.CopickFeatures.__init__","title":"<code>__init__(tomogram: TCopickTomogram, meta: CopickFeaturesMeta)</code>","text":"<p>Parameters:</p> <ul> <li> <code>tomogram</code>               (<code>TCopickTomogram</code>)           \u2013            <p>Reference to the tomogram this feature map belongs to.</p> </li> <li> <code>meta</code>               (<code>CopickFeaturesMeta</code>)           \u2013            <p>Metadata for this feature map.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickFeatures/#copick.models.CopickFeatures.zarr","title":"<code>zarr() -&gt; MutableMapping</code>","text":"<p>Override to return the Zarr store for this feature set. Also needs to handle creating the store if it doesn't exist.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickMesh/","title":"CopickMesh","text":""},{"location":"api_reference/base_classes/data_entity_models/CopickMesh/#copick.models.CopickMesh","title":"<code>copick.models.CopickMesh</code>","text":"<p>Encapsulates all data pertaining to a specific mesh. This includes the mesh (<code>trimesh.parent.Geometry</code>) and other metadata.</p> <p>Attributes:</p> <ul> <li> <code>run</code>               (<code>CopickRun</code>)           \u2013            <p>Reference to the run this mesh belongs to.</p> </li> <li> <code>meta</code>               (<code>CopickMeshMeta</code>)           \u2013            <p>Metadata for this mesh.</p> </li> <li> <code>mesh</code>               (<code>Geometry</code>)           \u2013            <p>Mesh for this pick. Either populated from storage or lazily loaded when <code>CopickMesh.mesh</code> is accessed for the first time.</p> </li> <li> <code>from_tool</code>               (<code>bool</code>)           \u2013            <p>Flag to indicate if this pick was generated by a tool.</p> </li> <li> <code>from_user</code>               (<code>bool</code>)           \u2013            <p>Flag to indicate if this pick was generated by a user.</p> </li> <li> <code>pickable_object_name</code>               (<code>str</code>)           \u2013            <p>Pickable object name from <code>CopickConfig.pickable_objects[...].name</code></p> </li> <li> <code>user_id</code>               (<code>str</code>)           \u2013            <p>Unique identifier for the user or tool name.</p> </li> <li> <code>session_id</code>               (<code>str</code>)           \u2013            <p>Unique identifier for the pick session</p> </li> <li> <code>color</code>           \u2013            <p>Color of the pickable object this pick belongs to.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickMesh/#copick.models.CopickMesh.load","title":"<code>load() -&gt; Geometry</code>","text":"<p>Load the mesh from storage.</p> <p>Returns:</p> <ul> <li> <code>Geometry</code>           \u2013            <p>trimesh.parent.Geometry: The loaded mesh.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickMesh/#copick.models.CopickMesh.store","title":"<code>store()</code>","text":"<p>Store the mesh.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickMesh/#copick.models.CopickMesh.refresh","title":"<code>refresh() -&gt; None</code>","text":"<p>Refresh <code>CopickMesh.mesh</code> from storage.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickObject/","title":"CopickObject","text":""},{"location":"api_reference/base_classes/data_entity_models/CopickObject/#copick.models.CopickObject","title":"<code>copick.models.CopickObject</code>","text":"<p>Object that can be picked or segmented in a tomogram.</p> <p>Attributes:</p> <ul> <li> <code>meta</code>               (<code>PickableObject</code>)           \u2013            <p>Metadata for this object.</p> </li> <li> <code>root</code>               (<code>CopickRoot</code>)           \u2013            <p>Reference to the root this object belongs to.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name of the object.</p> </li> <li> <code>is_particle</code>               (<code>bool</code>)           \u2013            <p>Whether this object should be represented by points (True) or segmentation masks (False).</p> </li> <li> <code>label</code>               (<code>Union[int, None]</code>)           \u2013            <p>Numeric label/id for the object, as used in multilabel segmentation masks. Must be unique.</p> </li> <li> <code>color</code>               (<code>Union[Tuple[int, int, int, int], None]</code>)           \u2013            <p>RGBA color for the object.</p> </li> <li> <code>emdb_id</code>               (<code>Union[str, None]</code>)           \u2013            <p>EMDB ID for the object.</p> </li> <li> <code>pdb_id</code>               (<code>Union[str, None]</code>)           \u2013            <p>PDB ID for the object.</p> </li> <li> <code>map_threshold</code>               (<code>Union[float, None]</code>)           \u2013            <p>Threshold to apply to the map when rendering the isosurface.</p> </li> <li> <code>radius</code>               (<code>Union[float, None]</code>)           \u2013            <p>Radius of the particle, when displaying as a sphere.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickObject/#copick.models.CopickObject.__init__","title":"<code>__init__(root: TCopickRoot, meta: PickableObject)</code>","text":"<p>Parameters:</p> <ul> <li> <code>root(CopickRoot)</code>           \u2013            <p>The copick project root.</p> </li> <li> <code>meta</code>               (<code>PickableObject</code>)           \u2013            <p>The metadata for this object.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickObject/#copick.models.CopickObject.zarr","title":"<code>zarr() -&gt; Union[None, MutableMapping]</code>","text":"<p>Override this method to return a zarr store for this object. Should return None if CopickObject.is_particle is False.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickPicks/","title":"CopickPicks","text":""},{"location":"api_reference/base_classes/data_entity_models/CopickPicks/#copick.models.CopickPicks","title":"<code>copick.models.CopickPicks</code>","text":"<p>Encapsulates all data pertaining to a specific set of picked points. This includes the locations, orientations, and other metadata for the set of points.</p> <p>Attributes:</p> <ul> <li> <code>run</code>               (<code>CopickRun</code>)           \u2013            <p>Reference to the run this pick belongs to.</p> </li> <li> <code>meta</code>               (<code>CopickPicksFile</code>)           \u2013            <p>Metadata for this pick.</p> </li> <li> <code>points</code>               (<code>List[CopickPoint]</code>)           \u2013            <p>Points for this pick. Either populated from storage or lazily loaded when <code>CopickPicks.points</code> is accessed for the first time.</p> </li> <li> <code>from_tool</code>               (<code>bool</code>)           \u2013            <p>Flag to indicate if this pick was generated by a tool.</p> </li> <li> <code>pickable_object_name</code>               (<code>str</code>)           \u2013            <p>Pickable object name from <code>CopickConfig.pickable_objects[...].name</code></p> </li> <li> <code>user_id</code>               (<code>str</code>)           \u2013            <p>Unique identifier for the user or tool name.</p> </li> <li> <code>session_id</code>               (<code>str</code>)           \u2013            <p>Unique identifier for the pick session</p> </li> <li> <code>trust_orientation</code>               (<code>bool</code>)           \u2013            <p>Flag to indicate if the angles are known for this pick or should be ignored.</p> </li> <li> <code>color</code>               (<code>Union[Tuple[int, int, int, int], None]</code>)           \u2013            <p>Color of the pickable object this pick belongs to.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickPicks/#copick.models.CopickPicks.__init__","title":"<code>__init__(run: TCopickRun, file: CopickPicksFile)</code>","text":"<p>Parameters:</p> <ul> <li> <code>run</code>               (<code>TCopickRun</code>)           \u2013            <p>Reference to the run this pick belongs to.</p> </li> <li> <code>file</code>               (<code>CopickPicksFile</code>)           \u2013            <p>Metadata for this set of points.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickPicks/#copick.models.CopickPicks.load","title":"<code>load() -&gt; CopickPicksFile</code>","text":"<p>Load the points from storage.</p> <p>Returns:</p> <ul> <li> <code>CopickPicksFile</code> (              <code>CopickPicksFile</code> )          \u2013            <p>The loaded points.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickPicks/#copick.models.CopickPicks.store","title":"<code>store()</code>","text":"<p>Store the points (set using <code>CopickPicks.points</code> property).</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickPicks/#copick.models.CopickPicks.refresh","title":"<code>refresh() -&gt; None</code>","text":"<p>Refresh the points from storage.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickRoot/","title":"CopickRoot","text":""},{"location":"api_reference/base_classes/data_entity_models/CopickRoot/#copick.models.CopickRoot","title":"<code>copick.models.CopickRoot</code>","text":"<p>Root of a copick project. Contains references to the runs and pickable objects.</p> <p>Attributes:</p> <ul> <li> <code>config</code>               (<code>CopickConfig</code>)           \u2013            <p>Configuration of the copick project.</p> </li> <li> <code>user_id</code>               (<code>str</code>)           \u2013            <p>Unique identifier for the user.</p> </li> <li> <code>session_id</code>               (<code>str</code>)           \u2013            <p>Unique identifier for the session.</p> </li> <li> <code>runs</code>               (<code>List[CopickRun]</code>)           \u2013            <p>References to the runs for this project. Lazy loaded upon access.</p> </li> <li> <code>pickable_objects</code>               (<code>List[CopickObject]</code>)           \u2013            <p>References to the pickable objects for this project.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRoot/#copick.models.CopickRoot.__init__","title":"<code>__init__(config: TCopickConfig)</code>","text":"<p>Parameters:</p> <ul> <li> <code>config</code>               (<code>CopickConfig</code>)           \u2013            <p>Configuration of the copick project.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRoot/#copick.models.CopickRoot.query","title":"<code>query() -&gt; List[TCopickRun]</code>","text":"<p>Override this method to query for runs.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickRoot/#copick.models.CopickRoot.get_run","title":"<code>get_run(name: str, **kwargs) -&gt; Union[TCopickRun, None]</code>","text":"<p>Get run by name.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name of the run to retrieve.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional keyword arguments for the run metadata.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CopickRun</code> (              <code>Union[TCopickRun, None]</code> )          \u2013            <p>The run with the given name, or None if not found.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRoot/#copick.models.CopickRoot.get_object","title":"<code>get_object(name: str) -&gt; Union[TCopickObject, None]</code>","text":"<p>Get object by name.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name of the object to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CopickObject</code> (              <code>Union[TCopickObject, None]</code> )          \u2013            <p>The object with the given name, or None if not found.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRoot/#copick.models.CopickRoot.refresh","title":"<code>refresh() -&gt; None</code>","text":"<p>Refresh the list of runs.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickRoot/#copick.models.CopickRoot.new_run","title":"<code>new_run(name: str, **kwargs) -&gt; TCopickRun</code>","text":"<p>Create a new run.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name of the run to create.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional keyword arguments for the run metadata.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CopickRun</code> (              <code>TCopickRun</code> )          \u2013            <p>The newly created run.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If a run with the given name already exists.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/","title":"CopickRun","text":""},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun","title":"<code>copick.models.CopickRun</code>","text":"<p>Encapsulates all data pertaining to a physical location on a sample (i.e. typically one tilt series and the associated tomograms). This includes voxel spacings (of the reconstructed tomograms), picks, meshes, and segmentations.</p> <p>Attributes:</p> <ul> <li> <code>meta</code>               (<code>CopickRunMeta</code>)           \u2013            <p>Metadata for this run.</p> </li> <li> <code>root</code>               (<code>CopickRoot</code>)           \u2013            <p>Reference to the root project this run belongs to.</p> </li> <li> <code>voxel_spacings</code>               (<code>List[CopickVoxelSpacing]</code>)           \u2013            <p>Voxel spacings for this run. Either populated from config or lazily loaded when CopickRun.voxel_spacings is accessed for the first time.</p> </li> <li> <code>picks</code>               (<code>List[CopickPicks]</code>)           \u2013            <p>Picks for this run. Either populated from config or lazily loaded when CopickRun.picks is accessed for the first time.</p> </li> <li> <code>meshes</code>               (<code>List[CopickMesh]</code>)           \u2013            <p>Meshes for this run. Either populated from config or lazily loaded when CopickRun.meshes is accessed for the first time.</p> </li> <li> <code>segmentations</code>               (<code>List[CopickSegmentation]</code>)           \u2013            <p>Segmentations for this run. Either populated from config or lazily loaded when CopickRun.segmentations is accessed for the first time.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.query_voxelspacings","title":"<code>query_voxelspacings() -&gt; List[TCopickVoxelSpacing]</code>","text":"<p>Override this method to query for voxel_spacings.</p> <p>Returns:</p> <ul> <li> <code>List[TCopickVoxelSpacing]</code>           \u2013            <p>List[CopickVoxelSpacing]: List of voxel spacings for this run.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.query_picks","title":"<code>query_picks() -&gt; List[TCopickPicks]</code>","text":"<p>Override this method to query for picks.</p> <p>Returns:</p> <ul> <li> <code>List[TCopickPicks]</code>           \u2013            <p>List[CopickPicks]: List of picks for this run.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.query_meshes","title":"<code>query_meshes() -&gt; List[TCopickMesh]</code>","text":"<p>Override this method to query for meshes.</p> <p>Returns:</p> <ul> <li> <code>List[TCopickMesh]</code>           \u2013            <p>List[CopickMesh]: List of meshes for this run.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.query_segmentations","title":"<code>query_segmentations() -&gt; List[TCopickSegmentation]</code>","text":"<p>Override this method to query for segmentations.</p> <p>Returns:</p> <ul> <li> <code>List[TCopickSegmentation]</code>           \u2013            <p>List[CopickSegmentation]: List of segmentations for this run.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.get_voxel_spacing","title":"<code>get_voxel_spacing(voxel_size: float, **kwargs) -&gt; Union[TCopickVoxelSpacing, None]</code>","text":"<p>Get voxel spacing object by voxel size value.</p> <p>Parameters:</p> <ul> <li> <code>voxel_size</code>               (<code>float</code>)           \u2013            <p>Voxel size value to search for.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional keyword arguments for the voxel spacing metadata.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CopickVoxelSpacing</code> (              <code>Union[TCopickVoxelSpacing, None]</code> )          \u2013            <p>The voxel spacing object with the given voxel size value, or None if not found.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.user_picks","title":"<code>user_picks() -&gt; List[TCopickPicks]</code>","text":"<p>Get all user generated picks (i.e. picks that have <code>CopickPicks.session_id != 0</code>).</p> <p>Returns:</p> <ul> <li> <code>List[TCopickPicks]</code>           \u2013            <p>List[CopickPicks]: List of user-generated picks.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.tool_picks","title":"<code>tool_picks() -&gt; List[TCopickPicks]</code>","text":"<p>Get all tool generated picks (i.e. picks that have <code>CopickPicks.session_id == 0</code>).</p> <p>Returns:</p> <ul> <li> <code>List[TCopickPicks]</code>           \u2013            <p>List[CopickPicks]: List of tool-generated picks.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.get_picks","title":"<code>get_picks(object_name: str = None, user_id: str = None, session_id: str = None) -&gt; List[TCopickPicks]</code>","text":"<p>Get picks by name, user_id or session_id (or combinations).</p> <p>Parameters:</p> <ul> <li> <code>object_name</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Name of the object to search for.</p> </li> <li> <code>user_id</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>User ID to search for.</p> </li> <li> <code>session_id</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Session ID to search for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[TCopickPicks]</code>           \u2013            <p>List[CopickPicks]: List of picks that match the search criteria.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.user_meshes","title":"<code>user_meshes() -&gt; List[TCopickMesh]</code>","text":"<p>Get all user generated meshes (i.e. meshes that have <code>CopickMesh.session_id != 0</code>).</p> <p>Returns:</p> <ul> <li> <code>List[TCopickMesh]</code>           \u2013            <p>List[CopickMesh]: List of user-generated meshes.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.tool_meshes","title":"<code>tool_meshes() -&gt; List[TCopickMesh]</code>","text":"<p>Get all tool generated meshes (i.e. meshes that have <code>CopickMesh.session_id == 0</code>).</p> <p>Returns:</p> <ul> <li> <code>List[TCopickMesh]</code>           \u2013            <p>List[CopickMesh]: List of tool-generated meshes.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.get_meshes","title":"<code>get_meshes(object_name: str = None, user_id: str = None, session_id: str = None) -&gt; List[TCopickMesh]</code>","text":"<p>Get meshes by name, user_id or session_id (or combinations).</p> <p>Parameters:</p> <ul> <li> <code>object_name</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Name of the object to search for.</p> </li> <li> <code>user_id</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>User ID to search for.</p> </li> <li> <code>session_id</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Session ID to search for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[TCopickMesh]</code>           \u2013            <p>List[CopickMesh]: List of meshes that match the search criteria.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.user_segmentations","title":"<code>user_segmentations() -&gt; List[TCopickSegmentation]</code>","text":"<p>Get all user generated segmentations (i.e. segmentations that have <code>CopickSegmentation.session_id != 0</code>).</p> <p>Returns:</p> <ul> <li> <code>List[TCopickSegmentation]</code>           \u2013            <p>List[CopickSegmentation]: List of user-generated segmentations.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.tool_segmentations","title":"<code>tool_segmentations() -&gt; List[TCopickSegmentation]</code>","text":"<p>Get all tool generated segmentations (i.e. segmentations that have <code>CopickSegmentation.session_id == 0</code>).</p> <p>Returns:</p> <ul> <li> <code>List[TCopickSegmentation]</code>           \u2013            <p>List[CopickSegmentation]: List of tool-generated segmentations.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.get_segmentations","title":"<code>get_segmentations(user_id: str = None, session_id: str = None, is_multilabel: bool = None, name: str = None, voxel_size: float = None) -&gt; List[TCopickSegmentation]</code>","text":"<p>Get segmentations by user_id, session_id, name, type or voxel_size (or combinations).</p> <p>Parameters:</p> <ul> <li> <code>user_id</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>User ID to search for.</p> </li> <li> <code>session_id</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Session ID to search for.</p> </li> <li> <code>is_multilabel</code>               (<code>bool</code>, default:                   <code>None</code> )           \u2013            <p>Whether the segmentation is multilabel or not.</p> </li> <li> <code>name</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Name of the segmentation to search for.</p> </li> <li> <code>voxel_size</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>Voxel size to search for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[TCopickSegmentation]</code>           \u2013            <p>List[CopickSegmentation]: List of segmentations that match the search criteria.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.new_voxel_spacing","title":"<code>new_voxel_spacing(voxel_size: float, **kwargs) -&gt; TCopickVoxelSpacing</code>","text":"<p>Create a new voxel spacing object.</p> <p>Parameters:</p> <ul> <li> <code>voxel_size</code>               (<code>float</code>)           \u2013            <p>Voxel size value for the contained tomograms.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional keyword arguments for the voxel spacing metadata.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CopickVoxelSpacing</code> (              <code>TCopickVoxelSpacing</code> )          \u2013            <p>The newly created voxel spacing object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If a voxel spacing with the given voxel size already exists for this run.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.new_picks","title":"<code>new_picks(object_name: str, session_id: str, user_id: Optional[str] = None) -&gt; TCopickPicks</code>","text":"<p>Create a new picks object.</p> <p>Parameters:</p> <ul> <li> <code>object_name</code>               (<code>str</code>)           \u2013            <p>Name of the object to pick.</p> </li> <li> <code>session_id</code>               (<code>str</code>)           \u2013            <p>Session ID for the picks.</p> </li> <li> <code>user_id</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>User ID for the picks.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CopickPicks</code> (              <code>TCopickPicks</code> )          \u2013            <p>The newly created picks object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If picks for the given object name, session ID and user ID already exist, if the object name is not found in the pickable objects, or if the user ID is not set in the root config or supplied.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.new_mesh","title":"<code>new_mesh(object_name: str, session_id: str, user_id: Optional[str] = None, **kwargs) -&gt; TCopickMesh</code>","text":"<p>Create a new mesh object.</p> <p>Parameters:</p> <ul> <li> <code>object_name</code>               (<code>str</code>)           \u2013            <p>Name of the object to mesh.</p> </li> <li> <code>session_id</code>               (<code>str</code>)           \u2013            <p>Session ID for the mesh.</p> </li> <li> <code>user_id</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>User ID for the mesh.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional keyword arguments for the mesh metadata.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CopickMesh</code> (              <code>TCopickMesh</code> )          \u2013            <p>The newly created mesh object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If a mesh for the given object name, session ID and user ID already exist, if the object name is not found in the pickable objects, or if the user ID is not set in the root config or supplied.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.new_segmentation","title":"<code>new_segmentation(voxel_size: float, name: str, session_id: str, is_multilabel: bool, user_id: Optional[str] = None, **kwargs) -&gt; TCopickSegmentation</code>","text":"<p>Create a new segmentation object.</p> <p>Parameters:</p> <ul> <li> <code>voxel_size</code>               (<code>float</code>)           \u2013            <p>Voxel size for the segmentation.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name of the segmentation.</p> </li> <li> <code>session_id</code>               (<code>str</code>)           \u2013            <p>Session ID for the segmentation.</p> </li> <li> <code>is_multilabel</code>               (<code>bool</code>)           \u2013            <p>Whether the segmentation is multilabel or not.</p> </li> <li> <code>user_id</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>User ID for the segmentation.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional keyword arguments for the segmentation metadata.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CopickSegmentation</code> (              <code>TCopickSegmentation</code> )          \u2013            <p>The newly created segmentation object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If a segmentation for the given name, session ID, user ID, voxel size and multilabel flag already exist, if the object name is not found in the pickable objects, if the voxel size is not found in the voxel spacings, or if the user ID is not set in the root config or supplied.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.refresh_voxel_spacings","title":"<code>refresh_voxel_spacings() -&gt; None</code>","text":"<p>Refresh the voxel spacings.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.refresh_picks","title":"<code>refresh_picks() -&gt; None</code>","text":"<p>Refresh the picks.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.refresh_meshes","title":"<code>refresh_meshes() -&gt; None</code>","text":"<p>Refresh the meshes.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.refresh_segmentations","title":"<code>refresh_segmentations() -&gt; None</code>","text":"<p>Refresh the segmentations.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.refresh","title":"<code>refresh() -&gt; None</code>","text":"<p>Refresh all child types.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickRun/#copick.models.CopickRun.ensure","title":"<code>ensure(create: bool = False) -&gt; bool</code>","text":"<p>Check if the run record exists, optionally create it if it does not.</p> <p>Parameters:</p> <ul> <li> <code>create</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to create the run record if it does not exist.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the run record exists, False otherwise.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickSegmentation/","title":"CopickSegmentation","text":""},{"location":"api_reference/base_classes/data_entity_models/CopickSegmentation/#copick.models.CopickSegmentation","title":"<code>copick.models.CopickSegmentation</code>","text":"<p>Encapsulates all data pertaining to a specific segmentation. This includes the Zarr-store for the segmentation and other metadata.</p> <p>Attributes:</p> <ul> <li> <code>run</code>               (<code>CopickRun</code>)           \u2013            <p>Reference to the run this segmentation belongs to.</p> </li> <li> <code>meta</code>               (<code>CopickSegmentationMeta</code>)           \u2013            <p>Metadata for this segmentation.</p> </li> <li> <code>zarr</code>               (<code>MutableMapping</code>)           \u2013            <p>Zarr store for this segmentation. Either populated from storage or lazily loaded when <code>CopickSegmentation.zarr</code> is accessed for the first time.</p> </li> <li> <code>from_tool</code>               (<code>bool</code>)           \u2013            <p>Flag to indicate if this segmentation was generated by a tool.</p> </li> <li> <code>from_user</code>               (<code>bool</code>)           \u2013            <p>Flag to indicate if this segmentation was generated by a user.</p> </li> <li> <code>user_id</code>               (<code>str</code>)           \u2013            <p>Unique identifier for the user or tool name.</p> </li> <li> <code>session_id</code>               (<code>str</code>)           \u2013            <p>Unique identifier for the segmentation session</p> </li> <li> <code>is_multilabel</code>               (<code>bool</code>)           \u2013            <p>Flag to indicate if this is a multilabel segmentation. If False, it is a single label segmentation.</p> </li> <li> <code>voxel_size</code>               (<code>float</code>)           \u2013            <p>Voxel size of the tomogram this segmentation belongs to.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Pickable Object name or multilabel name of the segmentation.</p> </li> <li> <code>color</code>           \u2013            <p>Color of the pickable object this segmentation belongs to.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickSegmentation/#copick.models.CopickSegmentation.__init__","title":"<code>__init__(run: TCopickRun, meta: CopickSegmentationMeta)</code>","text":"<p>Parameters:</p> <ul> <li> <code>run</code>               (<code>TCopickRun</code>)           \u2013            <p>Reference to the run this segmentation belongs to.</p> </li> <li> <code>meta</code>               (<code>CopickSegmentationMeta</code>)           \u2013            <p>Metadata for this segmentation.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickSegmentation/#copick.models.CopickSegmentation.zarr","title":"<code>zarr() -&gt; MutableMapping</code>","text":"<p>Override to return the Zarr store for this segmentation. Also needs to handle creating the store if it doesn't exist.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickTomogram/","title":"CopickTomogram","text":""},{"location":"api_reference/base_classes/data_entity_models/CopickTomogram/#copick.models.CopickTomogram","title":"<code>copick.models.CopickTomogram</code>","text":"<p>Encapsulates all data pertaining to a specific tomogram. This includes the features for this tomogram and the associated Zarr-store.</p> <p>Attributes:</p> <ul> <li> <code>voxel_spacing</code>               (<code>CopickVoxelSpacing</code>)           \u2013            <p>Reference to the voxel spacing this tomogram belongs to.</p> </li> <li> <code>meta</code>               (<code>CopickTomogramMeta</code>)           \u2013            <p>Metadata for this tomogram.</p> </li> <li> <code>features</code>               (<code>List[CopickFeatures]</code>)           \u2013            <p>Features for this tomogram. Either populated from config or lazily loaded when <code>CopickTomogram.features</code> is accessed for the first time.</p> </li> <li> <code>tomo_type</code>               (<code>str</code>)           \u2013            <p>Type of the tomogram.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickTomogram/#copick.models.CopickTomogram.get_features","title":"<code>get_features(feature_type: str) -&gt; Union[TCopickFeatures, None]</code>","text":"<p>Get feature maps by type.</p> <p>Parameters:</p> <ul> <li> <code>feature_type</code>               (<code>str</code>)           \u2013            <p>Type of the feature map to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CopickFeatures</code> (              <code>Union[TCopickFeatures, None]</code> )          \u2013            <p>The feature map with the given type, or <code>None</code> if not found.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickTomogram/#copick.models.CopickTomogram.new_features","title":"<code>new_features(feature_type: str, **kwargs) -&gt; TCopickFeatures</code>","text":"<p>Create a new feature map object. Also creates the Zarr-store for the map in the storage backend.</p> <p>Parameters:</p> <ul> <li> <code>feature_type</code>               (<code>str</code>)           \u2013            <p>Type of the feature map to create.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional keyword arguments for the feature map metadata.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CopickFeatures</code> (              <code>TCopickFeatures</code> )          \u2013            <p>The newly created feature map object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If a feature map with the given type already exists for this tomogram.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickTomogram/#copick.models.CopickTomogram.query_features","title":"<code>query_features() -&gt; List[TCopickFeatures]</code>","text":"<p>Override this method to query for features.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickTomogram/#copick.models.CopickTomogram.refresh_features","title":"<code>refresh_features() -&gt; None</code>","text":"<p>Refresh <code>CopickTomogram.features</code> from storage.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickTomogram/#copick.models.CopickTomogram.refresh","title":"<code>refresh() -&gt; None</code>","text":"<p>Refresh <code>CopickTomogram.features</code> from storage.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickTomogram/#copick.models.CopickTomogram.zarr","title":"<code>zarr() -&gt; MutableMapping</code>","text":"<p>Override to return the Zarr store for this tomogram. Also needs to handle creating the store if it doesn't exist.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickVoxelSpacing/","title":"CopickVoxelSpacing","text":""},{"location":"api_reference/base_classes/data_entity_models/CopickVoxelSpacing/#copick.models.CopickVoxelSpacing","title":"<code>copick.models.CopickVoxelSpacing</code>","text":"<p>Encapsulates all data pertaining to a specific voxel spacing. This includes the tomograms and feature maps at this voxel spacing.</p> <p>Attributes:</p> <ul> <li> <code>run</code>               (<code>CopickRun</code>)           \u2013            <p>Reference to the run this voxel spacing belongs to.</p> </li> <li> <code>meta</code>               (<code>CopickVoxelSpacingMeta</code>)           \u2013            <p>Metadata for this voxel spacing.</p> </li> <li> <code>tomograms</code>               (<code>List[CopickTomogram]</code>)           \u2013            <p>Tomograms for this voxel spacing. Either populated from config or lazily loaded when CopickVoxelSpacing.tomograms is accessed for the first time.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickVoxelSpacing/#copick.models.CopickVoxelSpacing.__init__","title":"<code>__init__(run: TCopickRun, meta: CopickVoxelSpacingMeta, config: Optional[TCopickConfig] = None)</code>","text":"<p>Parameters:</p> <ul> <li> <code>run</code>               (<code>TCopickRun</code>)           \u2013            <p>Reference to the run this voxel spacing belongs to.</p> </li> <li> <code>meta</code>               (<code>CopickVoxelSpacingMeta</code>)           \u2013            <p>Metadata for this voxel spacing.</p> </li> <li> <code>config</code>               (<code>Optional[TCopickConfig]</code>, default:                   <code>None</code> )           \u2013            <p>Configuration of the copick project.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickVoxelSpacing/#copick.models.CopickVoxelSpacing.query_tomograms","title":"<code>query_tomograms() -&gt; List[TCopickTomogram]</code>","text":"<p>Override this method to query for tomograms.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickVoxelSpacing/#copick.models.CopickVoxelSpacing.get_tomogram","title":"<code>get_tomogram(tomo_type: str, **kwargs) -&gt; Union[TCopickTomogram, None]</code>","text":"<p>Get tomogram by type.</p> <p>Parameters:</p> <ul> <li> <code>tomo_type</code>               (<code>str</code>)           \u2013            <p>Type of the tomogram to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CopickTomogram</code> (              <code>Union[TCopickTomogram, None]</code> )          \u2013            <p>The tomogram with the given type, or <code>None</code> if not found.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickVoxelSpacing/#copick.models.CopickVoxelSpacing.refresh_tomograms","title":"<code>refresh_tomograms() -&gt; None</code>","text":"<p>Refresh <code>CopickVoxelSpacing.tomograms</code> from storage.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickVoxelSpacing/#copick.models.CopickVoxelSpacing.refresh","title":"<code>refresh() -&gt; None</code>","text":"<p>Refresh <code>CopickVoxelSpacing.tomograms</code> from storage.</p>"},{"location":"api_reference/base_classes/data_entity_models/CopickVoxelSpacing/#copick.models.CopickVoxelSpacing.new_tomogram","title":"<code>new_tomogram(tomo_type: str, **kwargs) -&gt; TCopickTomogram</code>","text":"<p>Create a new tomogram object, also creates the Zarr-store in the storage backend.</p> <p>Parameters:</p> <ul> <li> <code>tomo_type</code>               (<code>str</code>)           \u2013            <p>Type of the tomogram to create.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional keyword arguments for the tomogram metadata.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CopickTomogram</code> (              <code>TCopickTomogram</code> )          \u2013            <p>The newly created tomogram object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If a tomogram with the given type already exists for this voxel spacing.</p> </li> </ul>"},{"location":"api_reference/base_classes/data_entity_models/CopickVoxelSpacing/#copick.models.CopickVoxelSpacing.ensure","title":"<code>ensure(create: bool = False) -&gt; bool</code>","text":"<p>Override to check if the voxel spacing record exists, optionally create it if it does not.</p> <p>Parameters:</p> <ul> <li> <code>create</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to create the voxel spacing record if it does not exist.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the voxel spacing record exists, False otherwise.</p> </li> </ul>"},{"location":"api_reference/base_classes/metadata_models/CopickConfig/","title":"CopickConfig","text":""},{"location":"api_reference/base_classes/metadata_models/CopickConfig/#copick.models.CopickConfig","title":"<code>copick.models.CopickConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for a copick project. Defines the available objects, user_id and optionally an index for runs.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>Optional[str]</code>)           \u2013            <p>Name of the CoPick project.</p> </li> <li> <code>description</code>               (<code>Optional[str]</code>)           \u2013            <p>Description of the CoPick project.</p> </li> <li> <code>version</code>               (<code>Optional[str]</code>)           \u2013            <p>Version of the CoPick API.</p> </li> <li> <code>pickable_objects</code>               (<code>List[PickableObject]</code>)           \u2013            <p>Index for available pickable objects.</p> </li> <li> <code>user_id</code>               (<code>Optional[str]</code>)           \u2013            <p>Unique identifier for the user (e.g. when distributing the config file to users).</p> </li> <li> <code>session_id</code>               (<code>Optional[str]</code>)           \u2013            <p>Unique identifier for the session.</p> </li> <li> <code>runs</code>               (<code>Optional[List[str]]</code>)           \u2013            <p>Index for run names.</p> </li> <li> <code>voxel_spacings</code>               (<code>Optional[List[float]]</code>)           \u2013            <p>Index for available voxel spacings.</p> </li> <li> <code>tomograms</code>               (<code>Optional[Dict[float, List[str]]]</code>)           \u2013            <p>Index for available voxel spacings and tomogram types.</p> </li> </ul>"},{"location":"api_reference/base_classes/metadata_models/CopickConfig/#copick.models.CopickConfig.name","title":"<code>name: Optional[str] = 'CoPick'</code>","text":""},{"location":"api_reference/base_classes/metadata_models/CopickConfig/#copick.models.CopickConfig.description","title":"<code>description: Optional[str] = \"Let's CoPick!\"</code>","text":""},{"location":"api_reference/base_classes/metadata_models/CopickConfig/#copick.models.CopickConfig.version","title":"<code>version: Optional[str] = '0.2.0'</code>","text":""},{"location":"api_reference/base_classes/metadata_models/CopickConfig/#copick.models.CopickConfig.pickable_objects","title":"<code>pickable_objects: List[TPickableObject]</code>","text":""},{"location":"api_reference/base_classes/metadata_models/CopickConfig/#copick.models.CopickConfig.user_id","title":"<code>user_id: Optional[str] = None</code>","text":""},{"location":"api_reference/base_classes/metadata_models/CopickConfig/#copick.models.CopickConfig.session_id","title":"<code>session_id: Optional[str] = None</code>","text":""},{"location":"api_reference/base_classes/metadata_models/CopickConfig/#copick.models.CopickConfig.runs","title":"<code>runs: Optional[List[str]] = None</code>","text":""},{"location":"api_reference/base_classes/metadata_models/CopickConfig/#copick.models.CopickConfig.voxel_spacings","title":"<code>voxel_spacings: Optional[List[float]] = None</code>","text":""},{"location":"api_reference/base_classes/metadata_models/CopickConfig/#copick.models.CopickConfig.tomograms","title":"<code>tomograms: Optional[Dict[float, List[str]]] = {}</code>","text":""},{"location":"api_reference/base_classes/metadata_models/CopickConfig/#copick.models.CopickConfig.from_file","title":"<code>from_file(filename: str) -&gt; TCopickConfig</code>","text":"<p>Load a CopickConfig from a file and create a CopickConfig object.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>path to the file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CopickConfig</code> (              <code>TCopickConfig</code> )          \u2013            <p>Initialized CopickConfig object</p> </li> </ul>"},{"location":"api_reference/base_classes/metadata_models/CopickFeaturesMeta/","title":"CopickFeaturesMeta","text":""},{"location":"api_reference/base_classes/metadata_models/CopickFeaturesMeta/#copick.models.CopickFeaturesMeta","title":"<code>copick.models.CopickFeaturesMeta</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Data model for feature map metadata.</p> <p>Attributes:</p> <ul> <li> <code>tomo_type</code>               (<code>str</code>)           \u2013            <p>Type of the tomogram that the features were computed on.</p> </li> <li> <code>feature_type</code>               (<code>str</code>)           \u2013            <p>Type of the features contained.</p> </li> </ul>"},{"location":"api_reference/base_classes/metadata_models/CopickFeaturesMeta/#copick.models.CopickFeaturesMeta.tomo_type","title":"<code>tomo_type: str</code>","text":""},{"location":"api_reference/base_classes/metadata_models/CopickFeaturesMeta/#copick.models.CopickFeaturesMeta.feature_type","title":"<code>feature_type: str</code>","text":""},{"location":"api_reference/base_classes/metadata_models/CopickMeshMeta/","title":"CopickMeshMeta","text":""},{"location":"api_reference/base_classes/metadata_models/CopickMeshMeta/#copick.models.CopickMeshMeta","title":"<code>copick.models.CopickMeshMeta</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Data model for mesh metadata.</p> <p>Attributes:</p> <ul> <li> <code>pickable_object_name</code>               (<code>str</code>)           \u2013            <p>Pickable object name from <code>CopickConfig.pickable_objects[...].name</code></p> </li> <li> <code>user_id</code>               (<code>str</code>)           \u2013            <p>Unique identifier for the user or tool name.</p> </li> <li> <code>session_id</code>               (<code>Union[str, Literal['0']]</code>)           \u2013            <p>Unique identifier for the pick session. If it is 0, this pick was generated by a tool.</p> </li> </ul>"},{"location":"api_reference/base_classes/metadata_models/CopickMeshMeta/#copick.models.CopickMeshMeta.pickable_object_name","title":"<code>pickable_object_name: str</code>","text":""},{"location":"api_reference/base_classes/metadata_models/CopickMeshMeta/#copick.models.CopickMeshMeta.user_id","title":"<code>user_id: str</code>","text":""},{"location":"api_reference/base_classes/metadata_models/CopickMeshMeta/#copick.models.CopickMeshMeta.session_id","title":"<code>session_id: Union[str, Literal['0']]</code>","text":""},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/","title":"CopickPicksFile","text":""},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickPicksFile","title":"<code>copick.models.CopickPicksFile</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Datamodel for a collection of locations, orientations and other metadata for one pickable object.</p> <p>Attributes:</p> <ul> <li> <code>pickable_object_name</code>               (<code>str</code>)           \u2013            <p>Pickable object name from CopickConfig.pickable_objects[X].name</p> </li> <li> <code>user_id</code>               (<code>str</code>)           \u2013            <p>Unique identifier for the user or tool name.</p> </li> <li> <code>session_id</code>               (<code>Union[str, Literal['0']]</code>)           \u2013            <p>Unique identifier for the pick session (prevent race if they run multiple instances of napari, ChimeraX, etc.) If it is 0, this pick was generated by a tool.</p> </li> <li> <code>run_name</code>               (<code>Optional[str]</code>)           \u2013            <p>Name of the run this pick belongs to.</p> </li> <li> <code>voxel_spacing</code>               (<code>Optional[float]</code>)           \u2013            <p>Voxel spacing for the tomogram this pick belongs to.</p> </li> <li> <code>unit</code>               (<code>str</code>)           \u2013            <p>Unit for the location of the pick.</p> </li> <li> <code>points</code>               (<code>List[CopickPoint]</code>)           \u2013            <p>References to the points for this pick.</p> </li> <li> <code>trust_orientation</code>               (<code>Optional[bool]</code>)           \u2013            <p>Flag to indicate if the angles are known for this pick or should be ignored.</p> </li> </ul>"},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickPicksFile.pickable_object_name","title":"<code>pickable_object_name: str</code>","text":""},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickPicksFile.user_id","title":"<code>user_id: str</code>","text":""},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickPicksFile.session_id","title":"<code>session_id: Union[str, Literal['0']]</code>","text":""},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickPicksFile.run_name","title":"<code>run_name: Optional[str]</code>","text":""},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickPicksFile.voxel_spacing","title":"<code>voxel_spacing: Optional[float]</code>","text":""},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickPicksFile.unit","title":"<code>unit: str = 'angstrom'</code>","text":""},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickPicksFile.points","title":"<code>points: Optional[List[TCopickPoint]] = None</code>","text":""},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickPicksFile.trust_orientation","title":"<code>trust_orientation: Optional[bool] = True</code>","text":""},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickPoint","title":"<code>copick.models.CopickPoint</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Point in 3D space with an associated orientation, score value and instance ID.</p> <p>Attributes:</p> <ul> <li> <code>location</code>               (<code>CopickLocation</code>)           \u2013            <p>Location in 3D space.</p> </li> <li> <code>transformation</code>               (<code>ndarray</code>)           \u2013            <p>Transformation matrix.</p> </li> <li> <code>instance_id</code>               (<code>Optional[int]</code>)           \u2013            <p>Instance ID.</p> </li> <li> <code>score</code>               (<code>Optional[float]</code>)           \u2013            <p>Score value.</p> </li> </ul>"},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickPoint.location","title":"<code>location: TCopickLocation</code>","text":""},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickPoint.transformation_","title":"<code>transformation_: Optional[List[List[float]]] = [[1.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0], [0.0, 0.0, 0.0, 1.0]]</code>","text":""},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickPoint.instance_id","title":"<code>instance_id: Optional[int] = 0</code>","text":""},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickPoint.score","title":"<code>score: Optional[float] = 1.0</code>","text":""},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickPoint.transformation","title":"<code>transformation: np.ndarray</code>","text":"<p>The transformation necessary to transform coordinates from the object space to the tomogram space.</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: 4x4 transformation matrix.</p> </li> </ul>"},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickPoint.Config","title":"<code>Config</code>","text":""},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickPoint.Config.arbitrary_types_allowed","title":"<code>arbitrary_types_allowed = True</code>","text":""},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickPoint.validate_transformation","title":"<code>validate_transformation(v) -&gt; List[List[float]]</code>","text":"<p>Validate the transformation matrix.</p>"},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickLocation","title":"<code>copick.models.CopickLocation</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Location in 3D space.</p> <p>Attributes:</p> <ul> <li> <code>x</code>               (<code>float</code>)           \u2013            <p>x-coordinate.</p> </li> <li> <code>y</code>               (<code>float</code>)           \u2013            <p>y-coordinate.</p> </li> <li> <code>z</code>               (<code>float</code>)           \u2013            <p>z-coordinate.</p> </li> </ul>"},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickLocation.x","title":"<code>x: float</code>","text":""},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickLocation.y","title":"<code>y: float</code>","text":""},{"location":"api_reference/base_classes/metadata_models/CopickPicksFile/#copick.models.CopickLocation.z","title":"<code>z: float</code>","text":""},{"location":"api_reference/base_classes/metadata_models/CopickRunMeta/","title":"CopickRunMeta","text":""},{"location":"api_reference/base_classes/metadata_models/CopickRunMeta/#copick.models.CopickRunMeta","title":"<code>copick.models.CopickRunMeta</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Data model for run level metadata.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name of the run.</p> </li> </ul>"},{"location":"api_reference/base_classes/metadata_models/CopickRunMeta/#copick.models.CopickRunMeta.name","title":"<code>name: str</code>","text":""},{"location":"api_reference/base_classes/metadata_models/CopickSegmentationMeta/","title":"CopickSegmentationMeta","text":""},{"location":"api_reference/base_classes/metadata_models/CopickSegmentationMeta/#copick.models.CopickSegmentationMeta","title":"<code>copick.models.CopickSegmentationMeta</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Datamodel for segmentation metadata.</p> <p>Attributes:</p> <ul> <li> <code>user_id</code>               (<code>str</code>)           \u2013            <p>Unique identifier for the user or tool name.</p> </li> <li> <code>session_id</code>               (<code>Union[str, Literal['0']]</code>)           \u2013            <p>Unique identifier for the segmentation session. If it is 0, this segmentation was generated by a tool.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Pickable Object name or multilabel name of the segmentation.</p> </li> <li> <code>is_multilabel</code>               (<code>bool</code>)           \u2013            <p>Flag to indicate if this is a multilabel segmentation. If False, it is a single label segmentation.</p> </li> <li> <code>voxel_size</code>               (<code>float</code>)           \u2013            <p>Voxel size in angstrom of the tomogram this segmentation belongs to. Rounded to the third decimal.</p> </li> </ul>"},{"location":"api_reference/base_classes/metadata_models/CopickSegmentationMeta/#copick.models.CopickSegmentationMeta.user_id","title":"<code>user_id: str</code>","text":""},{"location":"api_reference/base_classes/metadata_models/CopickSegmentationMeta/#copick.models.CopickSegmentationMeta.session_id","title":"<code>session_id: Union[str, Literal['0']]</code>","text":""},{"location":"api_reference/base_classes/metadata_models/CopickSegmentationMeta/#copick.models.CopickSegmentationMeta.name","title":"<code>name: str</code>","text":""},{"location":"api_reference/base_classes/metadata_models/CopickSegmentationMeta/#copick.models.CopickSegmentationMeta.is_multilabel","title":"<code>is_multilabel: bool</code>","text":""},{"location":"api_reference/base_classes/metadata_models/CopickSegmentationMeta/#copick.models.CopickSegmentationMeta.voxel_size","title":"<code>voxel_size: float</code>","text":""},{"location":"api_reference/base_classes/metadata_models/CopickTomogramMeta/","title":"CopickTomogramMeta","text":""},{"location":"api_reference/base_classes/metadata_models/CopickTomogramMeta/#copick.models.CopickTomogramMeta","title":"<code>copick.models.CopickTomogramMeta</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Data model for tomogram metadata.</p> <p>Attributes:</p> <ul> <li> <code>tomo_type</code>               (<code>str</code>)           \u2013            <p>Type of the tomogram.</p> </li> </ul>"},{"location":"api_reference/base_classes/metadata_models/CopickTomogramMeta/#copick.models.CopickTomogramMeta.tomo_type","title":"<code>tomo_type: str</code>","text":""},{"location":"api_reference/base_classes/metadata_models/CopickVoxelSpacingMeta/","title":"CopickVoxelSpacingMeta","text":""},{"location":"api_reference/base_classes/metadata_models/CopickVoxelSpacingMeta/#copick.models.CopickVoxelSpacingMeta","title":"<code>copick.models.CopickVoxelSpacingMeta</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Data model for voxel spacing metadata.</p> <p>Attributes:</p> <ul> <li> <code>voxel_size</code>               (<code>float</code>)           \u2013            <p>Voxel size in angstrom, rounded to the third decimal.</p> </li> </ul>"},{"location":"api_reference/base_classes/metadata_models/CopickVoxelSpacingMeta/#copick.models.CopickVoxelSpacingMeta.voxel_size","title":"<code>voxel_size: float</code>","text":""},{"location":"api_reference/base_classes/metadata_models/PickableObject/","title":"PickableObject","text":""},{"location":"api_reference/base_classes/metadata_models/PickableObject/#copick.models.PickableObject","title":"<code>copick.models.PickableObject</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Metadata for a pickable objects.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name of the object.</p> </li> <li> <code>is_particle</code>               (<code>bool</code>)           \u2013            <p>Whether this object should be represented by points (True) or segmentation masks (False).</p> </li> <li> <code>label</code>               (<code>Optional[int]</code>)           \u2013            <p>Numeric label/id for the object, as used in multilabel segmentation masks. Must be unique.</p> </li> <li> <code>color</code>               (<code>Optional[Tuple[int, int, int, int]]</code>)           \u2013            <p>RGBA color for the object.</p> </li> <li> <code>emdb_id</code>               (<code>Optional[str]</code>)           \u2013            <p>EMDB ID for the object.</p> </li> <li> <code>pdb_id</code>               (<code>Optional[str]</code>)           \u2013            <p>PDB ID for the object.</p> </li> <li> <code>map_threshold</code>               (<code>Optional[float]</code>)           \u2013            <p>Threshold to apply to the map when rendering the isosurface.</p> </li> <li> <code>radius</code>               (<code>Optional[float]</code>)           \u2013            <p>Radius of the particle, when displaying as a sphere.</p> </li> </ul>"},{"location":"api_reference/base_classes/metadata_models/PickableObject/#copick.models.PickableObject.name","title":"<code>name: str</code>","text":""},{"location":"api_reference/base_classes/metadata_models/PickableObject/#copick.models.PickableObject.is_particle","title":"<code>is_particle: bool</code>","text":""},{"location":"api_reference/base_classes/metadata_models/PickableObject/#copick.models.PickableObject.label","title":"<code>label: Optional[int]</code>","text":""},{"location":"api_reference/base_classes/metadata_models/PickableObject/#copick.models.PickableObject.color","title":"<code>color: Optional[Tuple[int, int, int, int]]</code>","text":""},{"location":"api_reference/base_classes/metadata_models/PickableObject/#copick.models.PickableObject.emdb_id","title":"<code>emdb_id: Optional[str] = None</code>","text":""},{"location":"api_reference/base_classes/metadata_models/PickableObject/#copick.models.PickableObject.pdb_id","title":"<code>pdb_id: Optional[str] = None</code>","text":""},{"location":"api_reference/base_classes/metadata_models/PickableObject/#copick.models.PickableObject.map_threshold","title":"<code>map_threshold: Optional[float] = None</code>","text":""},{"location":"api_reference/base_classes/metadata_models/PickableObject/#copick.models.PickableObject.radius","title":"<code>radius: Optional[float] = None</code>","text":""},{"location":"api_reference/base_classes/metadata_models/PickableObject/#copick.models.PickableObject.validate_label","title":"<code>validate_label(v) -&gt; int</code>","text":"<p>Validate the label.</p>"},{"location":"api_reference/base_classes/metadata_models/PickableObject/#copick.models.PickableObject.validate_color","title":"<code>validate_color(v) -&gt; Tuple[int, int, int, int]</code>","text":"<p>Validate the color.</p>"},{"location":"api_reference/implementations/Filesystem/","title":"File System","text":"<p>The filesystem implementation is a concrete implementation of the abstract copick API that reads and writes data to/from any storage supported by <code>fsspec</code>. The filesystem implementation is defined in the <code>copick.impl.filesystem</code> module.</p>"},{"location":"api_reference/implementations/Filesystem/#metadata-models","title":"Metadata Models","text":""},{"location":"api_reference/implementations/Filesystem/#copick.impl.filesystem.CopickConfigFSSpec","title":"<code>copick.impl.filesystem.CopickConfigFSSpec</code>","text":"<p>               Bases: <code>CopickConfig</code></p> <p>Copick configuration for fsspec-based storage.</p> <p>Attributes:</p> <ul> <li> <code>overlay_root</code>               (<code>str</code>)           \u2013            <p>The root URL for the overlay storage.</p> </li> <li> <code>static_root</code>               (<code>Optional[str]</code>)           \u2013            <p>The root URL for the static storage.</p> </li> <li> <code>overlay_fs_args</code>               (<code>Optional[Dict[str, Any]]</code>)           \u2013            <p>Additional arguments for the overlay filesystem.</p> </li> <li> <code>static_fs_args</code>               (<code>Optional[Dict[str, Any]]</code>)           \u2013            <p>Additional arguments for the static filesystem.</p> </li> </ul>"},{"location":"api_reference/implementations/Filesystem/#data-entities","title":"Data Entities","text":""},{"location":"api_reference/implementations/Filesystem/#copick.impl.filesystem.CopickRootFSSpec","title":"<code>copick.impl.filesystem.CopickRootFSSpec</code>","text":"<p>               Bases: <code>CopickRoot</code></p> <p>CopickRoot class backed by fspec storage.</p> <p>Attributes:</p> <ul> <li> <code>fs_overlay</code>               (<code>AbstractFileSystem</code>)           \u2013            <p>The filesystem for the overlay storage.</p> </li> <li> <code>fs_static</code>               (<code>Optional[AbstractFileSystem]</code>)           \u2013            <p>The filesystem for the static storage.</p> </li> <li> <code>root_overlay</code>               (<code>str</code>)           \u2013            <p>The root path for the overlay storage.</p> </li> <li> <code>root_static</code>               (<code>Optional[str]</code>)           \u2013            <p>The root path for the static storage.</p> </li> </ul>"},{"location":"api_reference/implementations/Filesystem/#copick.impl.filesystem.CopickRootFSSpec.__init__","title":"<code>__init__(config: CopickConfigFSSpec)</code>","text":"<p>Parameters:</p> <ul> <li> <code>config</code>               (<code>CopickConfigFSSpec</code>)           \u2013            <p>Copick configuration for fsspec-based storage.</p> </li> </ul>"},{"location":"api_reference/implementations/Filesystem/#copick.impl.filesystem.CopickRootFSSpec.from_file","title":"<code>from_file(path: str) -&gt; CopickRootFSSpec</code>","text":"<p>Initialize a CopickRootFSSpec from a configuration file on disk.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>Path to the configuration file on disk.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CopickRootFSSpec</code> (              <code>CopickRootFSSpec</code> )          \u2013            <p>The initialized CopickRootFSSpec object.</p> </li> </ul>"},{"location":"api_reference/implementations/Filesystem/#copick.impl.filesystem.CopickObjectFSSpec","title":"<code>copick.impl.filesystem.CopickObjectFSSpec</code>","text":"<p>               Bases: <code>CopickObjectOverlay</code></p> <p>CopickObject class backed by fsspec storage.</p> <p>Attributes:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path to the object file.</p> </li> <li> <code>fs</code>               (<code>AbstractFileSystem</code>)           \u2013            <p>The filesystem containing the object file.</p> </li> </ul>"},{"location":"api_reference/implementations/Filesystem/#copick.impl.filesystem.CopickObjectFSSpec.zarr","title":"<code>zarr() -&gt; Union[None, zarr.storage.FSStore]</code>","text":"<p>Get the zarr store for the object.</p> <p>Returns:</p> <ul> <li> <code>Union[None, FSStore]</code>           \u2013            <p>Union[None, zarr.storage.FSStore]: The zarr store for the object, or None if the object is not a particle.</p> </li> </ul>"},{"location":"api_reference/implementations/Filesystem/#copick.impl.filesystem.CopickRunFSSpec","title":"<code>copick.impl.filesystem.CopickRunFSSpec</code>","text":"<p>               Bases: <code>CopickRunOverlay</code></p> <p>CopickRun class backed by fsspec storage.</p> <p>Attributes:</p> <ul> <li> <code>static_path</code>               (<code>str</code>)           \u2013            <p>The path to the run on the static source.</p> </li> <li> <code>overlay_path</code>               (<code>str</code>)           \u2013            <p>The path to the run on the overlay source.</p> </li> <li> <code>fs_static</code>               (<code>AbstractFileSystem</code>)           \u2013            <p>The filesystem containing the run on the static source.</p> </li> <li> <code>fs_overlay</code>               (<code>AbstractFileSystem</code>)           \u2013            <p>The filesystem containing the run on the overlay source.</p> </li> <li> <code>static_is_overlay</code>               (<code>bool</code>)           \u2013            <p>Whether the static and overlay sources are the same.</p> </li> </ul>"},{"location":"api_reference/implementations/Filesystem/#copick.impl.filesystem.CopickRunFSSpec.ensure","title":"<code>ensure(create: bool = False) -&gt; bool</code>","text":"<p>Checks if the run record exists in the static or overlay directory, optionally creating it in the overlay filesystem if it does not.</p> <p>Parameters:</p> <ul> <li> <code>create</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to create the run record if it does not exist.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the run record exists, False otherwise.</p> </li> </ul>"},{"location":"api_reference/implementations/Filesystem/#copick.impl.filesystem.CopickPicksFSSpec","title":"<code>copick.impl.filesystem.CopickPicksFSSpec</code>","text":"<p>               Bases: <code>CopickPicksOverlay</code></p> <p>CopickPicks class backed by fsspec storage.</p> <p>Attributes:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path to the picks file.</p> </li> <li> <code>directory</code>               (<code>str</code>)           \u2013            <p>The directory containing the picks file.</p> </li> <li> <code>fs</code>               (<code>AbstractFileSystem</code>)           \u2013            <p>The filesystem containing the picks file.</p> </li> </ul>"},{"location":"api_reference/implementations/Filesystem/#copick.impl.filesystem.CopickMeshFSSpec","title":"<code>copick.impl.filesystem.CopickMeshFSSpec</code>","text":"<p>               Bases: <code>CopickMeshOverlay</code></p> <p>CopickMesh class backed by fspec storage.</p> <p>Attributes:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path to the mesh file.</p> </li> <li> <code>directory</code>               (<code>str</code>)           \u2013            <p>The directory containing the mesh file.</p> </li> <li> <code>fs</code>               (<code>AbstractFileSystem</code>)           \u2013            <p>The filesystem containing the mesh file.</p> </li> </ul>"},{"location":"api_reference/implementations/Filesystem/#copick.impl.filesystem.CopickSegmentationFSSpec","title":"<code>copick.impl.filesystem.CopickSegmentationFSSpec</code>","text":"<p>               Bases: <code>CopickSegmentationOverlay</code></p> <p>CopickSegmentation class backed by fsspec storage.</p> <p>Attributes:</p> <ul> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>The filename of the segmentation file.</p> </li> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path to the segmentation file.</p> </li> <li> <code>fs</code>               (<code>AbstractFileSystem</code>)           \u2013            <p>The filesystem containing the segmentation file.</p> </li> </ul>"},{"location":"api_reference/implementations/Filesystem/#copick.impl.filesystem.CopickSegmentationFSSpec.zarr","title":"<code>zarr() -&gt; zarr.storage.FSStore</code>","text":"<p>Get the zarr store for the segmentation object.</p> <p>Returns:</p> <ul> <li> <code>FSStore</code>           \u2013            <p>zarr.storage.FSStore: The zarr store for the segmentation object.</p> </li> </ul>"},{"location":"api_reference/implementations/Filesystem/#copick.impl.filesystem.CopickVoxelSpacingFSSpec","title":"<code>copick.impl.filesystem.CopickVoxelSpacingFSSpec</code>","text":"<p>               Bases: <code>CopickVoxelSpacingOverlay</code></p> <p>CopickVoxelSpacing class backed by fsspec storage.</p> <p>Attributes:</p> <ul> <li> <code>static_path</code>               (<code>str</code>)           \u2013            <p>The path to the voxel spacing on the static source.</p> </li> <li> <code>overlay_path</code>               (<code>str</code>)           \u2013            <p>The path to the voxel spacing on the overlay source.</p> </li> <li> <code>fs_static</code>               (<code>AbstractFileSystem</code>)           \u2013            <p>The filesystem containing the voxel spacing on the static source.</p> </li> <li> <code>fs_overlay</code>               (<code>AbstractFileSystem</code>)           \u2013            <p>The filesystem containing the voxel spacing on the overlay source.</p> </li> <li> <code>static_is_overlay</code>               (<code>bool</code>)           \u2013            <p>Whether the static and overlay sources are the same.</p> </li> </ul>"},{"location":"api_reference/implementations/Filesystem/#copick.impl.filesystem.CopickVoxelSpacingFSSpec.ensure","title":"<code>ensure(create: bool = False) -&gt; bool</code>","text":"<p>Checks if the voxel spacing record exists in the static or overlay directory, optionally creating it in the overlay filesystem if it does not.</p> <p>Parameters:</p> <ul> <li> <code>create</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to create the voxel spacing record if it does not exist.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the voxel spacing record exists, False otherwise.</p> </li> </ul>"},{"location":"api_reference/implementations/Filesystem/#copick.impl.filesystem.CopickTomogramFSSpec","title":"<code>copick.impl.filesystem.CopickTomogramFSSpec</code>","text":"<p>               Bases: <code>CopickTomogramOverlay</code></p> <p>CopickTomogram class backed by fsspec storage.</p> <p>Attributes:</p> <ul> <li> <code>static_path</code>               (<code>str</code>)           \u2013            <p>The path to the tomogram on the static source.</p> </li> <li> <code>overlay_path</code>               (<code>str</code>)           \u2013            <p>The path to the tomogram on the overlay source.</p> </li> <li> <code>static_stem</code>               (<code>str</code>)           \u2013            <p>The stem of the tomogram on the static source.</p> </li> <li> <code>overlay_stem</code>               (<code>str</code>)           \u2013            <p>The stem of the tomogram on the overlay source.</p> </li> <li> <code>fs_static</code>               (<code>AbstractFileSystem</code>)           \u2013            <p>The filesystem containing the tomogram on the static source.</p> </li> <li> <code>fs_overlay</code>               (<code>AbstractFileSystem</code>)           \u2013            <p>The filesystem containing the tomogram on the overlay source.</p> </li> <li> <code>static_is_overlay</code>               (<code>bool</code>)           \u2013            <p>Whether the static and overlay sources are the same.</p> </li> </ul>"},{"location":"api_reference/implementations/Filesystem/#copick.impl.filesystem.CopickTomogramFSSpec.zarr","title":"<code>zarr() -&gt; zarr.storage.FSStore</code>","text":"<p>Get the zarr store for the tomogram object.</p> <p>Returns:</p> <ul> <li> <code>FSStore</code>           \u2013            <p>zarr.storage.FSStore: The zarr store for the tomogram object.</p> </li> </ul>"},{"location":"api_reference/implementations/Filesystem/#copick.impl.filesystem.CopickFeaturesFSSpec","title":"<code>copick.impl.filesystem.CopickFeaturesFSSpec</code>","text":"<p>               Bases: <code>CopickFeaturesOverlay</code></p> <p>CopickFeatures class backed by fsspec storage.</p> <p>Attributes:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path to the features file.</p> </li> <li> <code>fs</code>               (<code>AbstractFileSystem</code>)           \u2013            <p>The filesystem containing the features file.</p> </li> </ul>"},{"location":"api_reference/implementations/Filesystem/#copick.impl.filesystem.CopickFeaturesFSSpec.zarr","title":"<code>zarr() -&gt; zarr.storage.FSStore</code>","text":"<p>Get the zarr store for the features object.</p> <p>Returns:</p> <ul> <li> <code>FSStore</code>           \u2013            <p>zarr.storage.FSStore: The zarr store for the features object.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/","title":"Overlay","text":"<p>The overlay implementation is an extension of the abstract copick API implementation that adds methods to seamlessly overlay data from two different sources. Each overlay implementation is a subclass of the corresponding abstract data entity and implements methods to overlay data from two sources. The overlay implementations are defined in the <code>copick.impl.overlay</code> module.</p> <p>One source is considered read-only ('static'), while the other source is considered read-write ('overlay').</p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickRunOverlay","title":"<code>copick.impl.overlay.CopickRunOverlay</code>","text":"<p>               Bases: <code>CopickRun</code></p> <p>CopickRun class that queries two different storage locations for runs. The first location is read-only (static) and the second location is writable (overlay).</p>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickRunOverlay._query_static_picks","title":"<code>_query_static_picks() -&gt; List[CopickPicksOverlay]</code>","text":"<p>Override to query the static source for the picks. All returned picks must be read-only.</p> <p>Returns:</p> <ul> <li> <code>List[CopickPicksOverlay]</code>           \u2013            <p>List[CopickPicksOverlay]: List of read-only picks.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickRunOverlay._query_overlay_picks","title":"<code>_query_overlay_picks() -&gt; List[CopickPicksOverlay]</code>","text":"<p>Override to query the overlay source for the picks.</p> <p>Returns:</p> <ul> <li> <code>List[CopickPicksOverlay]</code>           \u2013            <p>List[CopickPicksOverlay]: List of writable picks.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickRunOverlay.query_picks","title":"<code>query_picks() -&gt; List[CopickPicksOverlay]</code>","text":"<p>Query all picks.</p> <p>Returns:</p> <ul> <li> <code>List[CopickPicksOverlay]</code>           \u2013            <p>List[CopickPicksOverlay]: List of picks from both sources.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickRunOverlay._query_static_meshes","title":"<code>_query_static_meshes() -&gt; List[CopickMeshOverlay]</code>","text":"<p>Override to query the static source for the meshes. All returned meshes must be read-only.</p> <p>Returns:</p> <ul> <li> <code>List[CopickMeshOverlay]</code>           \u2013            <p>List[CopickMeshOverlay]: List of read-only meshes.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickRunOverlay._query_overlay_meshes","title":"<code>_query_overlay_meshes() -&gt; List[CopickMeshOverlay]</code>","text":"<p>Override to query the overlay source for the meshes.</p> <p>Returns:</p> <ul> <li> <code>List[CopickMeshOverlay]</code>           \u2013            <p>List[CopickMeshOverlay]: List of writable meshes.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickRunOverlay.query_meshes","title":"<code>query_meshes() -&gt; List[CopickMeshOverlay]</code>","text":"<p>Query all meshes.</p> <p>Returns:</p> <ul> <li> <code>List[CopickMeshOverlay]</code>           \u2013            <p>List[CopickMeshOverlay]: List of meshes from both sources.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickRunOverlay._query_static_segmentations","title":"<code>_query_static_segmentations() -&gt; List[CopickSegmentationOverlay]</code>","text":"<p>Override to query the static source for the segmentations. All returned segmentations must be read-only.</p> <p>Returns:</p> <ul> <li> <code>List[CopickSegmentationOverlay]</code>           \u2013            <p>List[CopickSegmentationOverlay]: List of read-only segmentations.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickRunOverlay._query_overlay_segmentations","title":"<code>_query_overlay_segmentations() -&gt; List[CopickSegmentationOverlay]</code>","text":"<p>Override to query the overlay source for the segmentations.</p> <p>Returns:</p> <ul> <li> <code>List[CopickSegmentationOverlay]</code>           \u2013            <p>List[CopickSegmentationOverlay]: List of writable segmentations.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickRunOverlay.query_segmentations","title":"<code>query_segmentations() -&gt; List[CopickSegmentationOverlay]</code>","text":"<p>Query all segmentations.</p> <p>Returns:</p> <ul> <li> <code>List[CopickSegmentationOverlay]</code>           \u2013            <p>List[CopickSegmentationOverlay]: List of segmentations from both sources.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickObjectOverlay","title":"<code>copick.impl.overlay.CopickObjectOverlay</code>","text":"<p>               Bases: <code>CopickObject</code></p> <p>CopickObject class that keeps track of whether the object is read-only.</p> <p>Attributes:</p> <ul> <li> <code>read_only</code>               (<code>bool</code>)           \u2013            <p>Whether the object is read-only.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickPicksOverlay","title":"<code>copick.impl.overlay.CopickPicksOverlay</code>","text":"<p>               Bases: <code>CopickPicks</code></p> <p>CopickPicks class that keeps track of whether the picks are read-only.</p> <p>Attributes:</p> <ul> <li> <code>read_only</code>               (<code>bool</code>)           \u2013            <p>Whether the picks are read-only.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickPicksOverlay.store","title":"<code>store()</code>","text":"<p>Store the picks, making sure the source is writable.</p>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickMeshOverlay","title":"<code>copick.impl.overlay.CopickMeshOverlay</code>","text":"<p>               Bases: <code>CopickMesh</code></p> <p>CopickMesh class that keeps track of whether the mesh is read-only.</p> <p>Attributes:</p> <ul> <li> <code>read_only</code>               (<code>bool</code>)           \u2013            <p>Whether the mesh is read-only.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickMeshOverlay.store","title":"<code>store()</code>","text":"<p>Store the mesh, making sure the source is writable.</p>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickSegmentationOverlay","title":"<code>copick.impl.overlay.CopickSegmentationOverlay</code>","text":"<p>               Bases: <code>CopickSegmentation</code></p> <p>CopickSegmentation class that keeps track of whether the segmentation is read-only.</p> <p>Attributes:</p> <ul> <li> <code>read_only</code>               (<code>bool</code>)           \u2013            <p>Whether the segmentation is read-only.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickVoxelSpacingOverlay","title":"<code>copick.impl.overlay.CopickVoxelSpacingOverlay</code>","text":"<p>               Bases: <code>CopickVoxelSpacing</code></p> <p>CopickVoxelSpacing class that queries two different storage locations for voxel spacings. The first location is read-only (static) and the second location is writable (overlay).</p>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickVoxelSpacingOverlay._query_static_tomograms","title":"<code>_query_static_tomograms() -&gt; List[CopickTomogramOverlay]</code>","text":"<p>Override to query the static source for the tomograms. All returned tomograms must be read-only.</p> <p>Returns:</p> <ul> <li> <code>List[CopickTomogramOverlay]</code>           \u2013            <p>List[CopickTomogramOverlay]: List of read-only tomograms.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickVoxelSpacingOverlay._query_overlay_tomograms","title":"<code>_query_overlay_tomograms() -&gt; List[CopickTomogramOverlay]</code>","text":"<p>Override to query the overlay source for the tomograms.</p> <p>Returns:</p> <ul> <li> <code>List[CopickTomogramOverlay]</code>           \u2013            <p>List[CopickTomogramOverlay]: List of writable tomograms.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickVoxelSpacingOverlay.query_tomograms","title":"<code>query_tomograms() -&gt; List[CopickTomogramOverlay]</code>","text":"<p>Query all tomograms.</p> <p>Returns:</p> <ul> <li> <code>List[CopickTomogramOverlay]</code>           \u2013            <p>List[CopickTomogramOverlay]: List of tomograms from both sources.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickTomogramOverlay","title":"<code>copick.impl.overlay.CopickTomogramOverlay</code>","text":"<p>               Bases: <code>CopickTomogram</code></p> <p>CopickTomogram class that keeps track of whether the tomogram is read-only and queries two different storage locations for tomograms. The first location is read-only (static) and the second location is writable (overlay).</p> <p>Attributes:</p> <ul> <li> <code>read_only</code>               (<code>bool</code>)           \u2013            <p>Whether the tomogram is read-only.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickTomogramOverlay._query_static_features","title":"<code>_query_static_features() -&gt; List[CopickFeaturesOverlay]</code>","text":"<p>Override to query the static source for the features. All returned features must be read-only.</p> <p>Returns:</p> <ul> <li> <code>List[CopickFeaturesOverlay]</code>           \u2013            <p>List[CopickFeaturesOverlay]: List of read-only features.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickTomogramOverlay._query_overlay_features","title":"<code>_query_overlay_features() -&gt; List[CopickFeaturesOverlay]</code>","text":"<p>Override to query the overlay source for the features.</p> <p>Returns:</p> <ul> <li> <code>List[CopickFeaturesOverlay]</code>           \u2013            <p>List[CopickFeaturesOverlay]: List of writable features.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickTomogramOverlay.query_features","title":"<code>query_features() -&gt; List[CopickFeaturesOverlay]</code>","text":"<p>Query all features.</p> <p>Returns:</p> <ul> <li> <code>List[CopickFeaturesOverlay]</code>           \u2013            <p>List[CopickFeaturesOverlay]: List of features from both sources.</p> </li> </ul>"},{"location":"api_reference/implementations/Overlay/#copick.impl.overlay.CopickFeaturesOverlay","title":"<code>copick.impl.overlay.CopickFeaturesOverlay</code>","text":"<p>               Bases: <code>CopickFeatures</code></p> <p>CopickFeatures class that keeps track of whether the features are read-only.</p> <p>Attributes:</p> <ul> <li> <code>read_only</code>               (<code>bool</code>)           \u2013            <p>Whether the features are read-only.</p> </li> </ul>"}]}